/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/@vercel/analytics/dist/react/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@vercel/analytics/dist/react/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Analytics: () => (/* binding */ Analytics),\n/* harmony export */   track: () => (/* binding */ track)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* __next_internal_client_entry_do_not_use__ Analytics,track auto */ var _s = $RefreshSig$();\n// src/react/index.tsx\n\n// package.json\nvar name = \"@vercel/analytics\";\nvar version = \"1.6.1\";\n// src/queue.ts\nvar initQueue = ()=>{\n    if (window.va) return;\n    window.va = function a() {\n        for(var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++){\n            params[_key] = arguments[_key];\n        }\n        (window.vaq = window.vaq || []).push(params);\n    };\n};\n// src/utils.ts\nfunction isBrowser() {\n    return typeof window !== \"undefined\";\n}\nfunction detectEnvironment() {\n    try {\n        const env = \"development\";\n        if (env === \"development\" || env === \"test\") {\n            return \"development\";\n        }\n    } catch (e) {}\n    return \"production\";\n}\nfunction setMode() {\n    let mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"auto\";\n    if (mode === \"auto\") {\n        window.vam = detectEnvironment();\n        return;\n    }\n    window.vam = mode;\n}\nfunction getMode() {\n    const mode = isBrowser() ? window.vam : detectEnvironment();\n    return mode || \"production\";\n}\nfunction isProduction() {\n    return getMode() === \"production\";\n}\nfunction isDevelopment() {\n    return getMode() === \"development\";\n}\nfunction removeKey(key, param) {\n    let { [key]: _, ...rest } = param;\n    return rest;\n}\nfunction parseProperties(properties, options) {\n    if (!properties) return void 0;\n    let props = properties;\n    const errorProperties = [];\n    for (const [key, value] of Object.entries(properties)){\n        if (typeof value === \"object\" && value !== null) {\n            if (options.strip) {\n                props = removeKey(key, props);\n            } else {\n                errorProperties.push(key);\n            }\n        }\n    }\n    if (errorProperties.length > 0 && !options.strip) {\n        throw Error(\"The following properties are not valid: \".concat(errorProperties.join(\", \"), \". Only strings, numbers, booleans, and null are allowed.\"));\n    }\n    return props;\n}\nfunction getScriptSrc(props) {\n    if (props.scriptSrc) {\n        return props.scriptSrc;\n    }\n    if (isDevelopment()) {\n        return \"https://va.vercel-scripts.com/v1/script.debug.js\";\n    }\n    if (props.basePath) {\n        return \"\".concat(props.basePath, \"/insights/script.js\");\n    }\n    return \"/_vercel/insights/script.js\";\n}\n// src/generic.ts\nfunction inject() {\n    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {\n        debug: true\n    };\n    var _a;\n    if (!isBrowser()) return;\n    setMode(props.mode);\n    initQueue();\n    if (props.beforeSend) {\n        (_a = window.va) == null ? void 0 : _a.call(window, \"beforeSend\", props.beforeSend);\n    }\n    const src = getScriptSrc(props);\n    if (document.head.querySelector('script[src*=\"'.concat(src, '\"]'))) return;\n    const script = document.createElement(\"script\");\n    script.src = src;\n    script.defer = true;\n    script.dataset.sdkn = name + (props.framework ? \"/\".concat(props.framework) : \"\");\n    script.dataset.sdkv = version;\n    if (props.disableAutoTrack) {\n        script.dataset.disableAutoTrack = \"1\";\n    }\n    if (props.endpoint) {\n        script.dataset.endpoint = props.endpoint;\n    } else if (props.basePath) {\n        script.dataset.endpoint = \"\".concat(props.basePath, \"/insights\");\n    }\n    if (props.dsn) {\n        script.dataset.dsn = props.dsn;\n    }\n    script.onerror = ()=>{\n        const errorMessage = isDevelopment() ? \"Please check if any ad blockers are enabled and try again.\" : \"Be sure to enable Web Analytics for your project and deploy again. See https://vercel.com/docs/analytics/quickstart for more information.\";\n        console.log(\"[Vercel Web Analytics] Failed to load script from \".concat(src, \". \").concat(errorMessage));\n    };\n    if (isDevelopment() && props.debug === false) {\n        script.dataset.debug = \"false\";\n    }\n    document.head.appendChild(script);\n}\nfunction track(name2, properties, options) {\n    var _a, _b;\n    if (!isBrowser()) {\n        const msg = \"[Vercel Web Analytics] Please import `track` from `@vercel/analytics/server` when using this function in a server environment\";\n        if (isProduction()) {\n            console.warn(msg);\n        } else {\n            throw new Error(msg);\n        }\n        return;\n    }\n    if (!properties) {\n        (_a = window.va) == null ? void 0 : _a.call(window, \"event\", {\n            name: name2,\n            options\n        });\n        return;\n    }\n    try {\n        const props = parseProperties(properties, {\n            strip: isProduction()\n        });\n        (_b = window.va) == null ? void 0 : _b.call(window, \"event\", {\n            name: name2,\n            data: props,\n            options\n        });\n    } catch (err) {\n        if (err instanceof Error && isDevelopment()) {\n            console.error(err);\n        }\n    }\n}\nfunction pageview(param) {\n    let { route, path } = param;\n    var _a;\n    (_a = window.va) == null ? void 0 : _a.call(window, \"pageview\", {\n        route,\n        path\n    });\n}\n// src/react/utils.ts\nfunction getBasePath() {\n    if (typeof process === \"undefined\" || typeof process.env === \"undefined\") {\n        return void 0;\n    }\n    return process.env.REACT_APP_VERCEL_OBSERVABILITY_BASEPATH;\n}\n// src/react/index.tsx\nfunction Analytics(props) {\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"Analytics.useEffect\": ()=>{\n            var _a;\n            if (props.beforeSend) {\n                (_a = window.va) == null ? void 0 : _a.call(window, \"beforeSend\", props.beforeSend);\n            }\n        }\n    }[\"Analytics.useEffect\"], [\n        props.beforeSend\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"Analytics.useEffect\": ()=>{\n            var _props_basePath;\n            inject({\n                framework: props.framework || \"react\",\n                basePath: (_props_basePath = props.basePath) !== null && _props_basePath !== void 0 ? _props_basePath : getBasePath(),\n                ...props.route !== void 0 && {\n                    disableAutoTrack: true\n                },\n                ...props\n            });\n        }\n    }[\"Analytics.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"Analytics.useEffect\": ()=>{\n            if (props.route && props.path) {\n                pageview({\n                    route: props.route,\n                    path: props.path\n                });\n            }\n        }\n    }[\"Analytics.useEffect\"], [\n        props.route,\n        props.path\n    ]);\n    return null;\n}\n_s(Analytics, \"ewq31d5h+FnD/qJW52w5UqeNMN4=\");\n_c = Analytics;\n //# sourceMappingURL=index.mjs.map\nvar _c;\n$RefreshReg$(_c, \"Analytics\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdmVyY2VsL2FuYWx5dGljcy9kaXN0L3JlYWN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFDMEI7O0FDQXhCLFdBQVE7QUFDUixjQUFXOztBQ0ZOLElBQU0sWUFBWTtJQUV2QixJQUFJLE9BQU8sR0FBSTtJQUVmLE9BQU8sS0FBSyxTQUFTO1FBQUE7WUFBSyxPQUFMLHVCQUFLOztTQUN2QixPQUFPLE1BQU0sT0FBTyxPQUFPLEVBQUMsRUFBRyxLQUFLLE1BQU07SUFDN0M7QUFDRjs7QUNMTyxTQUFTLFlBQXFCO0lBQ25DLE9BQU8sT0FBTyxXQUFXO0FBQzNCO0FBRUEsU0FBUyxvQkFBa0Q7SUFDekQsSUFBSTtRQUNGLE1BQU0sTUFBa0IsUUFBSixJQUFJO1FBQ3hCLElBQUksUUFBUSxpQkFBaUIsUUFBUSxRQUFRO1lBQzNDLE9BQU87UUFDVDtJQUNGLFNBQVMsR0FBRyxDQUVaO0lBQ0EsT0FBTztBQUNUO0FBRU8sU0FBUztlQUFRLGlFQUFhO0lBQ25DLElBQUksU0FBUyxRQUFRO1FBQ25CLE9BQU8sTUFBTSxrQkFBa0I7UUFDL0I7SUFDRjtJQUVBLE9BQU8sTUFBTTtBQUNmO0FBRU8sU0FBUyxVQUFnQjtJQUM5QixNQUFNLE9BQU8sVUFBVSxJQUFJLE9BQU8sTUFBTSxrQkFBa0I7SUFDMUQsT0FBTyxRQUFRO0FBQ2pCO0FBRU8sU0FBUyxlQUF3QjtJQUN0QyxPQUFPLFFBQVEsTUFBTTtBQUN2QjtBQUVPLFNBQVMsZ0JBQXlCO0lBQ3ZDLE9BQU8sUUFBUSxNQUFNO0FBQ3ZCO0FBRUEsU0FBUyxVQUNQLFVBQ29CO1VBQWxCLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQ0ssQ0FEekI7SUFFQSxPQUFPO0FBQ1Q7QUFFTyxTQUFTLGdCQUNkLFlBQ0EsU0FHMkQ7SUFDM0QsSUFBSSxDQUFDLFdBQVksUUFBTztJQUN4QixJQUFJLFFBQVE7SUFDWixNQUFNLGtCQUE0QixDQUFD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QUFDeEM7O0FDckpPLFNBQVMsY0FBa0M7SUFLaEQsSUFBSSxPQUFPLE9BQU8sS0FBSyxlQUFlLE9BQU8sT0FBTyxDQUFDLFFBQVEsYUFBYTtRQUN4RSxPQUFPO0lBQ1Q7SUFDQSxPQUFPLE9BQU8sQ0FBQyxJQUFJO0FBQ3JCOztBTG9CQSxtQkFDRSxPQU1NOztJQUNOLGdEQUFTOytCQUFDO1lBckNaO1lBc0NJLElBQUksTUFBTSxZQUFZO2dCQUNwQixhQUFPLE9BQVAsZ0NBQVksY0FBYyxNQUFNO1lBQ2xDO1FBQ0Y7OEJBQUc7UUFBQyxNQUFNLFVBQVU7S0FBQztJQUdyQixnREFBUzsrQkFBQzs7WUFDUixPQUFPO2dCQUNMLFdBQVcsTUFBTSxhQUFhO2dCQUM5QixXQUFVLHdCQUFNLHFFQUFZLFlBQVk7Z0JBQ3hDLEdBQUksTUFBTSxVQUFVLFVBQWE7b0JBQUUsa0JBQWtCO2dCQUFLO2dCQUMxRCxHQUFHO1lBQ0wsQ0FBQztRQUVIOzhCQUFHLENBQUMsQ0FBQztJQUVMLGdEQUFTOytCQUFDO1lBRVIsSUFBSSxNQUFNLFNBQVMsTUFBTSxNQUFNO2dCQUM3QixTQUFTO29CQUFFLE9BQU8sTUFBTTtvQkFBTyxNQUFNLE1BQU07Z0JBQUssQ0FBQztZQUNuRDtRQUNGOzhCQUFHO1FBQUMsTUFBTTtRQUFPLE1BQU0sSUFBSTtLQUFDO0lBRTVCLE9BQU87QUFDVDs7S0FqQ1MiLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL1BlZHJvU1NEL3NyYy9yZWFjdC9pbmRleC50c3giLCIvVm9sdW1lcy9QZWRyb1NTRC9wYWNrYWdlLmpzb24iLCIvVm9sdW1lcy9QZWRyb1NTRC9zcmMvcXVldWUudHMiLCIvVm9sdW1lcy9QZWRyb1NTRC9zcmMvdXRpbHMudHMiLCIvVm9sdW1lcy9QZWRyb1NTRC9zcmMvZ2VuZXJpYy50cyIsIi9Wb2x1bWVzL1BlZHJvU1NEL3NyYy9yZWFjdC91dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpbmplY3QsIHRyYWNrLCBwYWdldmlldyB9IGZyb20gJy4uL2dlbmVyaWMnO1xuaW1wb3J0IHR5cGUgeyBBbmFseXRpY3NQcm9wcywgQmVmb3JlU2VuZCwgQmVmb3JlU2VuZEV2ZW50IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0QmFzZVBhdGggfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBJbmplY3RzIHRoZSBWZXJjZWwgV2ViIEFuYWx5dGljcyBzY3JpcHQgaW50byB0aGUgcGFnZSBoZWFkIGFuZCBzdGFydHMgdHJhY2tpbmcgcGFnZSB2aWV3cy4gUmVhZCBtb3JlIGluIG91ciBbZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly92ZXJjZWwuY29tL2RvY3MvY29uY2VwdHMvYW5hbHl0aWNzL3BhY2thZ2UpLlxuICogQHBhcmFtIFtwcm9wc10gLSBBbmFseXRpY3Mgb3B0aW9ucy5cbiAqIEBwYXJhbSBbcHJvcHMubW9kZV0gLSBUaGUgbW9kZSB0byB1c2UgZm9yIHRoZSBhbmFseXRpY3Mgc2NyaXB0LiBEZWZhdWx0cyB0byBgYXV0b2AuXG4gKiAgLSBgYXV0b2AgLSBBdXRvbWF0aWNhbGx5IGRldGVjdCB0aGUgZW52aXJvbm1lbnQuICBVc2VzIGBwcm9kdWN0aW9uYCBpZiB0aGUgZW52aXJvbm1lbnQgY2Fubm90IGJlIGRldGVybWluZWQuXG4gKiAgLSBgcHJvZHVjdGlvbmAgLSBBbHdheXMgdXNlIHRoZSBwcm9kdWN0aW9uIHNjcmlwdC4gKFNlbmRzIGV2ZW50cyB0byB0aGUgc2VydmVyKVxuICogIC0gYGRldmVsb3BtZW50YCAtIEFsd2F5cyB1c2UgdGhlIGRldmVsb3BtZW50IHNjcmlwdC4gKExvZ3MgZXZlbnRzIHRvIHRoZSBjb25zb2xlKVxuICogQHBhcmFtIFtwcm9wcy5kZWJ1Z10gLSBXaGV0aGVyIHRvIGVuYWJsZSBkZWJ1ZyBsb2dnaW5nIGluIGRldmVsb3BtZW50LiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKiBAcGFyYW0gW3Byb3BzLmJlZm9yZVNlbmRdIC0gQSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIG1vZGlmeSBldmVudHMgYmVmb3JlIHRoZXkgYXJlIHNlbnQuIFNob3VsZCByZXR1cm4gdGhlIGV2ZW50IG9iamVjdCBvciBgbnVsbGAgdG8gY2FuY2VsIHRoZSBldmVudC5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgQW5hbHl0aWNzIH0gZnJvbSAnQHZlcmNlbC9hbmFseXRpY3MvcmVhY3QnO1xuICpcbiAqIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFwcCgpIHtcbiAqICByZXR1cm4gKFxuICogICA8ZGl2PlxuICogICAgPEFuYWx5dGljcyAvPlxuICogICAgPGgxPk15IEFwcDwvaDE+XG4gKiAgPC9kaXY+XG4gKiApO1xuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIEFuYWx5dGljcyhcbiAgcHJvcHM6IEFuYWx5dGljc1Byb3BzICYge1xuICAgIGZyYW1ld29yaz86IHN0cmluZztcbiAgICByb3V0ZT86IHN0cmluZyB8IG51bGw7XG4gICAgcGF0aD86IHN0cmluZyB8IG51bGw7XG4gICAgYmFzZVBhdGg/OiBzdHJpbmc7XG4gIH1cbik6IG51bGwge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcm9wcy5iZWZvcmVTZW5kKSB7XG4gICAgICB3aW5kb3cudmE/LignYmVmb3JlU2VuZCcsIHByb3BzLmJlZm9yZVNlbmQpO1xuICAgIH1cbiAgfSwgW3Byb3BzLmJlZm9yZVNlbmRdKTtcblxuICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb3JyZWN0bmVzcy91c2VFeGhhdXN0aXZlRGVwZW5kZW5jaWVzOiBvbmx5IHJ1biBvbmNlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaW5qZWN0KHtcbiAgICAgIGZyYW1ld29yazogcHJvcHMuZnJhbWV3b3JrIHx8ICdyZWFjdCcsXG4gICAgICBiYXNlUGF0aDogcHJvcHMuYmFzZVBhdGggPz8gZ2V0QmFzZVBhdGgoKSxcbiAgICAgIC4uLihwcm9wcy5yb3V0ZSAhPT0gdW5kZWZpbmVkICYmIHsgZGlzYWJsZUF1dG9UcmFjazogdHJ1ZSB9KSxcbiAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgLS0gb25seSBydW4gb25jZVxuICB9LCBbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBleHBsaWNpdGVseSB0cmFjayBwYWdlIHZpZXcsIHNpbmNlIHdlIGRpc2FibGVkIGF1dG8gdHJhY2tpbmdcbiAgICBpZiAocHJvcHMucm91dGUgJiYgcHJvcHMucGF0aCkge1xuICAgICAgcGFnZXZpZXcoeyByb3V0ZTogcHJvcHMucm91dGUsIHBhdGg6IHByb3BzLnBhdGggfSk7XG4gICAgfVxuICB9LCBbcHJvcHMucm91dGUsIHByb3BzLnBhdGhdKTtcblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IHsgdHJhY2ssIEFuYWx5dGljcyB9O1xuZXhwb3J0IHR5cGUgeyBBbmFseXRpY3NQcm9wcywgQmVmb3JlU2VuZCwgQmVmb3JlU2VuZEV2ZW50IH07XG4iLCJ7XG4gIFwibmFtZVwiOiBcIkB2ZXJjZWwvYW5hbHl0aWNzXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuNi4xXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJHYWluIHJlYWwtdGltZSB0cmFmZmljIGluc2lnaHRzIHdpdGggVmVyY2VsIFdlYiBBbmFseXRpY3NcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJhbmFseXRpY3NcIixcbiAgICBcInZlcmNlbFwiXG4gIF0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ1cmxcIjogXCJnaXRodWI6dmVyY2VsL2FuYWx5dGljc1wiLFxuICAgIFwiZGlyZWN0b3J5XCI6IFwicGFja2FnZXMvd2ViXCJcbiAgfSxcbiAgXCJsaWNlbnNlXCI6IFwiTVBMLTIuMFwiLFxuICBcImV4cG9ydHNcIjoge1xuICAgIFwiLi9wYWNrYWdlLmpzb25cIjogXCIuL3BhY2thZ2UuanNvblwiLFxuICAgIFwiLlwiOiB7XG4gICAgICBcImJyb3dzZXJcIjogXCIuL2Rpc3QvaW5kZXgubWpzXCIsXG4gICAgICBcImltcG9ydFwiOiBcIi4vZGlzdC9pbmRleC5tanNcIixcbiAgICAgIFwicmVxdWlyZVwiOiBcIi4vZGlzdC9pbmRleC5qc1wiXG4gICAgfSxcbiAgICBcIi4vYXN0cm9cIjoge1xuICAgICAgXCJpbXBvcnRcIjogXCIuL2Rpc3QvYXN0cm8vY29tcG9uZW50LnRzXCJcbiAgICB9LFxuICAgIFwiLi9uZXh0XCI6IHtcbiAgICAgIFwiYnJvd3NlclwiOiBcIi4vZGlzdC9uZXh0L2luZGV4Lm1qc1wiLFxuICAgICAgXCJpbXBvcnRcIjogXCIuL2Rpc3QvbmV4dC9pbmRleC5tanNcIixcbiAgICAgIFwicmVxdWlyZVwiOiBcIi4vZGlzdC9uZXh0L2luZGV4LmpzXCJcbiAgICB9LFxuICAgIFwiLi9udXh0XCI6IHtcbiAgICAgIFwiYnJvd3NlclwiOiBcIi4vZGlzdC9udXh0L2luZGV4Lm1qc1wiLFxuICAgICAgXCJpbXBvcnRcIjogXCIuL2Rpc3QvbnV4dC9pbmRleC5tanNcIixcbiAgICAgIFwicmVxdWlyZVwiOiBcIi4vZGlzdC9udXh0L2luZGV4LmpzXCJcbiAgICB9LFxuICAgIFwiLi9yZWFjdFwiOiB7XG4gICAgICBcImJyb3dzZXJcIjogXCIuL2Rpc3QvcmVhY3QvaW5kZXgubWpzXCIsXG4gICAgICBcImltcG9ydFwiOiBcIi4vZGlzdC9yZWFjdC9pbmRleC5tanNcIixcbiAgICAgIFwicmVxdWlyZVwiOiBcIi4vZGlzdC9yZWFjdC9pbmRleC5qc1wiXG4gICAgfSxcbiAgICBcIi4vcmVtaXhcIjoge1xuICAgICAgXCJicm93c2VyXCI6IFwiLi9kaXN0L3JlbWl4L2luZGV4Lm1qc1wiLFxuICAgICAgXCJpbXBvcnRcIjogXCIuL2Rpc3QvcmVtaXgvaW5kZXgubWpzXCIsXG4gICAgICBcInJlcXVpcmVcIjogXCIuL2Rpc3QvcmVtaXgvaW5kZXguanNcIlxuICAgIH0sXG4gICAgXCIuL3NlcnZlclwiOiB7XG4gICAgICBcIm5vZGVcIjogXCIuL2Rpc3Qvc2VydmVyL2luZGV4Lm1qc1wiLFxuICAgICAgXCJlZGdlLWxpZ2h0XCI6IFwiLi9kaXN0L3NlcnZlci9pbmRleC5tanNcIixcbiAgICAgIFwiaW1wb3J0XCI6IFwiLi9kaXN0L3NlcnZlci9pbmRleC5tanNcIixcbiAgICAgIFwicmVxdWlyZVwiOiBcIi4vZGlzdC9zZXJ2ZXIvaW5kZXguanNcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIi4vZGlzdC9zZXJ2ZXIvaW5kZXguanNcIlxuICAgIH0sXG4gICAgXCIuL3N2ZWx0ZWtpdFwiOiB7XG4gICAgICBcInN2ZWx0ZVwiOiBcIi4vZGlzdC9zdmVsdGVraXQvaW5kZXgubWpzXCIsXG4gICAgICBcInR5cGVzXCI6IFwiLi9kaXN0L3N2ZWx0ZWtpdC9pbmRleC5kLnRzXCJcbiAgICB9LFxuICAgIFwiLi92dWVcIjoge1xuICAgICAgXCJicm93c2VyXCI6IFwiLi9kaXN0L3Z1ZS9pbmRleC5tanNcIixcbiAgICAgIFwiaW1wb3J0XCI6IFwiLi9kaXN0L3Z1ZS9pbmRleC5tanNcIixcbiAgICAgIFwicmVxdWlyZVwiOiBcIi4vZGlzdC92dWUvaW5kZXguanNcIlxuICAgIH1cbiAgfSxcbiAgXCJtYWluXCI6IFwiLi9kaXN0L2luZGV4Lm1qc1wiLFxuICBcInR5cGVzXCI6IFwiLi9kaXN0L2luZGV4LmQudHNcIixcbiAgXCJ0eXBlc1ZlcnNpb25zXCI6IHtcbiAgICBcIipcIjoge1xuICAgICAgXCIqXCI6IFtcbiAgICAgICAgXCJkaXN0L2luZGV4LmQudHNcIlxuICAgICAgXSxcbiAgICAgIFwibmV4dFwiOiBbXG4gICAgICAgIFwiZGlzdC9uZXh0L2luZGV4LmQudHNcIlxuICAgICAgXSxcbiAgICAgIFwibnV4dFwiOiBbXG4gICAgICAgIFwiZGlzdC9udXh0L2luZGV4LmQudHNcIlxuICAgICAgXSxcbiAgICAgIFwicmVhY3RcIjogW1xuICAgICAgICBcImRpc3QvcmVhY3QvaW5kZXguZC50c1wiXG4gICAgICBdLFxuICAgICAgXCJyZW1peFwiOiBbXG4gICAgICAgIFwiZGlzdC9yZW1peC9pbmRleC5kLnRzXCJcbiAgICAgIF0sXG4gICAgICBcInNlcnZlclwiOiBbXG4gICAgICAgIFwiZGlzdC9zZXJ2ZXIvaW5kZXguZC50c1wiXG4gICAgICBdLFxuICAgICAgXCJzdmVsdGVraXRcIjogW1xuICAgICAgICBcImRpc3Qvc3ZlbHRla2l0L2luZGV4LmQudHNcIlxuICAgICAgXSxcbiAgICAgIFwidnVlXCI6IFtcbiAgICAgICAgXCJkaXN0L3Z1ZS9pbmRleC5kLnRzXCJcbiAgICAgIF1cbiAgICB9XG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJidWlsZFwiOiBcInRzdXAgJiYgcG5wbSBjb3B5LWFzdHJvXCIsXG4gICAgXCJjb3B5LWFzdHJvXCI6IFwiY3AgLVIgc3JjL2FzdHJvIGRpc3QvXCIsXG4gICAgXCJkZXZcIjogXCJwbnBtIGNvcHktYXN0cm8gJiYgdHN1cCAtLXdhdGNoXCIsXG4gICAgXCJsaW50XCI6IFwiZXNsaW50IC5cIixcbiAgICBcImxpbnQtZml4XCI6IFwiZXNsaW50IC4gLS1maXhcIixcbiAgICBcInRlc3RcIjogXCJ2aXRlc3RcIixcbiAgICBcInR5cGUtY2hlY2tcIjogXCJ0c2MgLS1ub0VtaXRcIlxuICB9LFxuICBcImVzbGludENvbmZpZ1wiOiB7XG4gICAgXCJleHRlbmRzXCI6IFtcbiAgICAgIFwiQHZlcmNlbC9lc2xpbnQtY29uZmlnXCJcbiAgICBdLFxuICAgIFwicnVsZXNcIjoge1xuICAgICAgXCJ0c2RvYy9zeW50YXhcIjogXCJvZmZcIlxuICAgIH0sXG4gICAgXCJpZ25vcmVQYXR0ZXJuc1wiOiBbXG4gICAgICBcImplc3Quc2V0dXAudHNcIlxuICAgIF1cbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHN3Yy9jb3JlXCI6IFwiXjEuOS4yXCIsXG4gICAgXCJAdGVzdGluZy1saWJyYXJ5L2plc3QtZG9tXCI6IFwiXjYuNi4zXCIsXG4gICAgXCJAdGVzdGluZy1saWJyYXJ5L3JlYWN0XCI6IFwiXjE2LjAuMVwiLFxuICAgIFwiQHR5cGVzL25vZGVcIjogXCJeMjIuOS4wXCIsXG4gICAgXCJAdHlwZXMvcmVhY3RcIjogXCJeMTguMy4xMlwiLFxuICAgIFwiQHZlcmNlbC9lc2xpbnQtY29uZmlnXCI6IFwid29ya3NwYWNlOjAuMC4wXCIsXG4gICAgXCJzZXJ2ZXItb25seVwiOiBcIl4wLjAuMVwiLFxuICAgIFwic3ZlbHRlXCI6IFwiXjUuMS4xMFwiLFxuICAgIFwidHN1cFwiOiBcIjguMy41XCIsXG4gICAgXCJ2aXRlc3RcIjogXCJeMi4xLjVcIixcbiAgICBcInZ1ZVwiOiBcIl4zLjUuMTJcIixcbiAgICBcInZ1ZS1yb3V0ZXJcIjogXCJeNC40LjVcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHJlbWl4LXJ1bi9yZWFjdFwiOiBcIl4yXCIsXG4gICAgXCJAc3ZlbHRlanMva2l0XCI6IFwiXjEgfHwgXjJcIixcbiAgICBcIm5leHRcIjogXCI+PSAxM1wiLFxuICAgIFwicmVhY3RcIjogXCJeMTggfHwgXjE5IHx8IF4xOS4wLjAtcmNcIixcbiAgICBcInN2ZWx0ZVwiOiBcIj49IDRcIixcbiAgICBcInZ1ZVwiOiBcIl4zXCIsXG4gICAgXCJ2dWUtcm91dGVyXCI6IFwiXjRcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNNZXRhXCI6IHtcbiAgICBcIkByZW1peC1ydW4vcmVhY3RcIjoge1xuICAgICAgXCJvcHRpb25hbFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIkBzdmVsdGVqcy9raXRcIjoge1xuICAgICAgXCJvcHRpb25hbFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIm5leHRcIjoge1xuICAgICAgXCJvcHRpb25hbFwiOiB0cnVlXG4gICAgfSxcbiAgICBcInJlYWN0XCI6IHtcbiAgICAgIFwib3B0aW9uYWxcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJzdmVsdGVcIjoge1xuICAgICAgXCJvcHRpb25hbFwiOiB0cnVlXG4gICAgfSxcbiAgICBcInZ1ZVwiOiB7XG4gICAgICBcIm9wdGlvbmFsXCI6IHRydWVcbiAgICB9LFxuICAgIFwidnVlLXJvdXRlclwiOiB7XG4gICAgICBcIm9wdGlvbmFsXCI6IHRydWVcbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCBjb25zdCBpbml0UXVldWUgPSAoKTogdm9pZCA9PiB7XG4gIC8vIGluaXRpYWxpemUgdmEgdW50aWwgc2NyaXB0IGlzIGxvYWRlZFxuICBpZiAod2luZG93LnZhKSByZXR1cm47XG5cbiAgd2luZG93LnZhID0gZnVuY3Rpb24gYSguLi5wYXJhbXMpOiB2b2lkIHtcbiAgICAod2luZG93LnZhcSA9IHdpbmRvdy52YXEgfHwgW10pLnB1c2gocGFyYW1zKTtcbiAgfTtcbn07XG4iLCJpbXBvcnQgdHlwZSB7IEFsbG93ZWRQcm9wZXJ0eVZhbHVlcywgQW5hbHl0aWNzUHJvcHMsIE1vZGUgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQnJvd3NlcigpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xufVxuXG5mdW5jdGlvbiBkZXRlY3RFbnZpcm9ubWVudCgpOiAnZGV2ZWxvcG1lbnQnIHwgJ3Byb2R1Y3Rpb24nIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBlbnYgPSBwcm9jZXNzLmVudi5OT0RFX0VOVjtcbiAgICBpZiAoZW52ID09PSAnZGV2ZWxvcG1lbnQnIHx8IGVudiA9PT0gJ3Rlc3QnKSB7XG4gICAgICByZXR1cm4gJ2RldmVsb3BtZW50JztcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBkbyBub3RoaW5nLCB0aGlzIGlzIG9rYXlcbiAgfVxuICByZXR1cm4gJ3Byb2R1Y3Rpb24nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0TW9kZShtb2RlOiBNb2RlID0gJ2F1dG8nKTogdm9pZCB7XG4gIGlmIChtb2RlID09PSAnYXV0bycpIHtcbiAgICB3aW5kb3cudmFtID0gZGV0ZWN0RW52aXJvbm1lbnQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB3aW5kb3cudmFtID0gbW9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vZGUoKTogTW9kZSB7XG4gIGNvbnN0IG1vZGUgPSBpc0Jyb3dzZXIoKSA/IHdpbmRvdy52YW0gOiBkZXRlY3RFbnZpcm9ubWVudCgpO1xuICByZXR1cm4gbW9kZSB8fCAncHJvZHVjdGlvbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Byb2R1Y3Rpb24oKTogYm9vbGVhbiB7XG4gIHJldHVybiBnZXRNb2RlKCkgPT09ICdwcm9kdWN0aW9uJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGV2ZWxvcG1lbnQoKTogYm9vbGVhbiB7XG4gIHJldHVybiBnZXRNb2RlKCkgPT09ICdkZXZlbG9wbWVudCc7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUtleShcbiAga2V5OiBzdHJpbmcsXG4gIHsgW2tleV06IF8sIC4uLnJlc3QgfVxuKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICByZXR1cm4gcmVzdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUHJvcGVydGllcyhcbiAgcHJvcGVydGllczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCB1bmRlZmluZWQsXG4gIG9wdGlvbnM6IHtcbiAgICBzdHJpcD86IGJvb2xlYW47XG4gIH1cbik6IEVycm9yIHwgUmVjb3JkPHN0cmluZywgQWxsb3dlZFByb3BlcnR5VmFsdWVzPiB8IHVuZGVmaW5lZCB7XG4gIGlmICghcHJvcGVydGllcykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgbGV0IHByb3BzID0gcHJvcGVydGllcztcbiAgY29uc3QgZXJyb3JQcm9wZXJ0aWVzOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdHJpcCkge1xuICAgICAgICBwcm9wcyA9IHJlbW92ZUtleShrZXksIHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yUHJvcGVydGllcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGVycm9yUHJvcGVydGllcy5sZW5ndGggPiAwICYmICFvcHRpb25zLnN0cmlwKSB7XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBgVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBub3QgdmFsaWQ6ICR7ZXJyb3JQcm9wZXJ0aWVzLmpvaW4oXG4gICAgICAgICcsICdcbiAgICAgICl9LiBPbmx5IHN0cmluZ3MsIG51bWJlcnMsIGJvb2xlYW5zLCBhbmQgbnVsbCBhcmUgYWxsb3dlZC5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcHJvcHMgYXMgUmVjb3JkPHN0cmluZywgQWxsb3dlZFByb3BlcnR5VmFsdWVzPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVSb3V0ZShcbiAgcGF0aG5hbWU6IHN0cmluZyB8IG51bGwsXG4gIHBhdGhQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdPiB8IG51bGxcbik6IHN0cmluZyB8IG51bGwge1xuICBpZiAoIXBhdGhuYW1lIHx8ICFwYXRoUGFyYW1zKSB7XG4gICAgcmV0dXJuIHBhdGhuYW1lO1xuICB9XG5cbiAgbGV0IHJlc3VsdCA9IHBhdGhuYW1lO1xuICB0cnkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhwYXRoUGFyYW1zKTtcbiAgICAvLyBzaW1wbGUga2V5cyBtdXN0IGJlIGhhbmRsZWQgZmlyc3RcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXIgPSB0dXJuVmFsdWVUb1JlZ0V4cCh2YWx1ZSk7XG4gICAgICAgIGlmIChtYXRjaGVyLnRlc3QocmVzdWx0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKG1hdGNoZXIsIGAvWyR7a2V5fV1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBhcnJheSB2YWx1ZXMgbmV4dFxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBtYXRjaGVyID0gdHVyblZhbHVlVG9SZWdFeHAodmFsdWUuam9pbignLycpKTtcbiAgICAgICAgaWYgKG1hdGNoZXIudGVzdChyZXN1bHQpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UobWF0Y2hlciwgYC9bLi4uJHtrZXl9XWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gcGF0aG5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHVyblZhbHVlVG9SZWdFeHAodmFsdWU6IHN0cmluZyk6IFJlZ0V4cCB7XG4gIHJldHVybiBuZXcgUmVnRXhwKGAvJHtlc2NhcGVSZWdFeHAodmFsdWUpfSg/PVsvPyNdfCQpYCk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjcmlwdFNyYyhcbiAgcHJvcHM6IEFuYWx5dGljc1Byb3BzICYgeyBiYXNlUGF0aD86IHN0cmluZyB9XG4pOiBzdHJpbmcge1xuICBpZiAocHJvcHMuc2NyaXB0U3JjKSB7XG4gICAgcmV0dXJuIHByb3BzLnNjcmlwdFNyYztcbiAgfVxuICBpZiAoaXNEZXZlbG9wbWVudCgpKSB7XG4gICAgcmV0dXJuICdodHRwczovL3ZhLnZlcmNlbC1zY3JpcHRzLmNvbS92MS9zY3JpcHQuZGVidWcuanMnO1xuICB9XG4gIGlmIChwcm9wcy5iYXNlUGF0aCkge1xuICAgIHJldHVybiBgJHtwcm9wcy5iYXNlUGF0aH0vaW5zaWdodHMvc2NyaXB0LmpzYDtcbiAgfVxuICByZXR1cm4gJy9fdmVyY2VsL2luc2lnaHRzL3NjcmlwdC5qcyc7XG59XG4iLCJpbXBvcnQgeyBuYW1lIGFzIHBhY2thZ2VOYW1lLCB2ZXJzaW9uIH0gZnJvbSAnLi4vcGFja2FnZS5qc29uJztcbmltcG9ydCB7IGluaXRRdWV1ZSB9IGZyb20gJy4vcXVldWUnO1xuaW1wb3J0IHR5cGUge1xuICBBbGxvd2VkUHJvcGVydHlWYWx1ZXMsXG4gIEFuYWx5dGljc1Byb3BzLFxuICBGbGFnc0RhdGFJbnB1dCxcbiAgQmVmb3JlU2VuZCxcbiAgQmVmb3JlU2VuZEV2ZW50LFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7XG4gIGlzQnJvd3NlcixcbiAgcGFyc2VQcm9wZXJ0aWVzLFxuICBzZXRNb2RlLFxuICBpc0RldmVsb3BtZW50LFxuICBpc1Byb2R1Y3Rpb24sXG4gIGNvbXB1dGVSb3V0ZSxcbiAgZ2V0U2NyaXB0U3JjLFxufSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBJbmplY3RzIHRoZSBWZXJjZWwgV2ViIEFuYWx5dGljcyBzY3JpcHQgaW50byB0aGUgcGFnZSBoZWFkIGFuZCBzdGFydHMgdHJhY2tpbmcgcGFnZSB2aWV3cy4gUmVhZCBtb3JlIGluIG91ciBbZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly92ZXJjZWwuY29tL2RvY3MvY29uY2VwdHMvYW5hbHl0aWNzL3BhY2thZ2UpLlxuICogQHBhcmFtIFtwcm9wc10gLSBBbmFseXRpY3Mgb3B0aW9ucy5cbiAqIEBwYXJhbSBbcHJvcHMubW9kZV0gLSBUaGUgbW9kZSB0byB1c2UgZm9yIHRoZSBhbmFseXRpY3Mgc2NyaXB0LiBEZWZhdWx0cyB0byBgYXV0b2AuXG4gKiAgLSBgYXV0b2AgLSBBdXRvbWF0aWNhbGx5IGRldGVjdCB0aGUgZW52aXJvbm1lbnQuICBVc2VzIGBwcm9kdWN0aW9uYCBpZiB0aGUgZW52aXJvbm1lbnQgY2Fubm90IGJlIGRldGVybWluZWQuXG4gKiAgLSBgcHJvZHVjdGlvbmAgLSBBbHdheXMgdXNlIHRoZSBwcm9kdWN0aW9uIHNjcmlwdC4gKFNlbmRzIGV2ZW50cyB0byB0aGUgc2VydmVyKVxuICogIC0gYGRldmVsb3BtZW50YCAtIEFsd2F5cyB1c2UgdGhlIGRldmVsb3BtZW50IHNjcmlwdC4gKExvZ3MgZXZlbnRzIHRvIHRoZSBjb25zb2xlKVxuICogQHBhcmFtIFtwcm9wcy5kZWJ1Z10gLSBXaGV0aGVyIHRvIGVuYWJsZSBkZWJ1ZyBsb2dnaW5nIGluIGRldmVsb3BtZW50LiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKiBAcGFyYW0gW3Byb3BzLmJlZm9yZVNlbmRdIC0gQSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIG1vZGlmeSBldmVudHMgYmVmb3JlIHRoZXkgYXJlIHNlbnQuIFNob3VsZCByZXR1cm4gdGhlIGV2ZW50IG9iamVjdCBvciBgbnVsbGAgdG8gY2FuY2VsIHRoZSBldmVudC5cbiAqIEBwYXJhbSBbcHJvcHMuZHNuXSAtIFRoZSBEU04gb2YgdGhlIHByb2plY3QgdG8gc2VuZCBldmVudHMgdG8uIE9ubHkgcmVxdWlyZWQgd2hlbiBzZWxmLWhvc3RpbmcuXG4gKiBAcGFyYW0gW3Byb3BzLmRpc2FibGVBdXRvVHJhY2tdIC0gV2hldGhlciB0aGUgaW5qZWN0ZWQgc2NyaXB0IHNob3VsZCB0cmFjayBwYWdlIHZpZXdzIGZyb20gcHVzaFN0YXRlIGV2ZW50cy4gRGlzYWJsZSBpZiByb3V0ZSBpcyB1cGRhdGVkIGFmdGVyIHB1c2hTdGF0ZSwgYSBtYW51YWxseSBjYWxsIHBhZ2UgcGFnZXZpZXcoKS5cbiAqL1xuZnVuY3Rpb24gaW5qZWN0KFxuICBwcm9wczogQW5hbHl0aWNzUHJvcHMgJiB7XG4gICAgZnJhbWV3b3JrPzogc3RyaW5nO1xuICAgIGRpc2FibGVBdXRvVHJhY2s/OiBib29sZWFuO1xuICAgIGJhc2VQYXRoPzogc3RyaW5nO1xuICB9ID0ge1xuICAgIGRlYnVnOiB0cnVlLFxuICB9XG4pOiB2b2lkIHtcbiAgaWYgKCFpc0Jyb3dzZXIoKSkgcmV0dXJuO1xuXG4gIHNldE1vZGUocHJvcHMubW9kZSk7XG5cbiAgaW5pdFF1ZXVlKCk7XG5cbiAgaWYgKHByb3BzLmJlZm9yZVNlbmQpIHtcbiAgICB3aW5kb3cudmE/LignYmVmb3JlU2VuZCcsIHByb3BzLmJlZm9yZVNlbmQpO1xuICB9XG5cbiAgY29uc3Qgc3JjID0gZ2V0U2NyaXB0U3JjKHByb3BzKTtcblxuICBpZiAoZG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yKGBzY3JpcHRbc3JjKj1cIiR7c3JjfVwiXWApKSByZXR1cm47XG5cbiAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHNjcmlwdC5zcmMgPSBzcmM7XG4gIHNjcmlwdC5kZWZlciA9IHRydWU7XG4gIHNjcmlwdC5kYXRhc2V0LnNka24gPVxuICAgIHBhY2thZ2VOYW1lICsgKHByb3BzLmZyYW1ld29yayA/IGAvJHtwcm9wcy5mcmFtZXdvcmt9YCA6ICcnKTtcbiAgc2NyaXB0LmRhdGFzZXQuc2RrdiA9IHZlcnNpb247XG5cbiAgaWYgKHByb3BzLmRpc2FibGVBdXRvVHJhY2spIHtcbiAgICBzY3JpcHQuZGF0YXNldC5kaXNhYmxlQXV0b1RyYWNrID0gJzEnO1xuICB9XG4gIGlmIChwcm9wcy5lbmRwb2ludCkge1xuICAgIHNjcmlwdC5kYXRhc2V0LmVuZHBvaW50ID0gcHJvcHMuZW5kcG9pbnQ7XG4gIH0gZWxzZSBpZiAocHJvcHMuYmFzZVBhdGgpIHtcbiAgICBzY3JpcHQuZGF0YXNldC5lbmRwb2ludCA9IGAke3Byb3BzLmJhc2VQYXRofS9pbnNpZ2h0c2A7XG4gIH1cbiAgaWYgKHByb3BzLmRzbikge1xuICAgIHNjcmlwdC5kYXRhc2V0LmRzbiA9IHByb3BzLmRzbjtcbiAgfVxuXG4gIHNjcmlwdC5vbmVycm9yID0gKCk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGlzRGV2ZWxvcG1lbnQoKVxuICAgICAgPyAnUGxlYXNlIGNoZWNrIGlmIGFueSBhZCBibG9ja2VycyBhcmUgZW5hYmxlZCBhbmQgdHJ5IGFnYWluLidcbiAgICAgIDogJ0JlIHN1cmUgdG8gZW5hYmxlIFdlYiBBbmFseXRpY3MgZm9yIHlvdXIgcHJvamVjdCBhbmQgZGVwbG95IGFnYWluLiBTZWUgaHR0cHM6Ly92ZXJjZWwuY29tL2RvY3MvYW5hbHl0aWNzL3F1aWNrc3RhcnQgZm9yIG1vcmUgaW5mb3JtYXRpb24uJztcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlIC0tIExvZ2dpbmcgdG8gY29uc29sZSBpcyBpbnRlbnRpb25hbFxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYFtWZXJjZWwgV2ViIEFuYWx5dGljc10gRmFpbGVkIHRvIGxvYWQgc2NyaXB0IGZyb20gJHtzcmN9LiAke2Vycm9yTWVzc2FnZX1gXG4gICAgKTtcbiAgfTtcblxuICBpZiAoaXNEZXZlbG9wbWVudCgpICYmIHByb3BzLmRlYnVnID09PSBmYWxzZSkge1xuICAgIHNjcmlwdC5kYXRhc2V0LmRlYnVnID0gJ2ZhbHNlJztcbiAgfVxuXG4gIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbn1cblxuLyoqXG4gKiBUcmFja3MgYSBjdXN0b20gZXZlbnQuIFBsZWFzZSByZWZlciB0byB0aGUgW2RvY3VtZW50YXRpb25dKGh0dHBzOi8vdmVyY2VsLmNvbS9kb2NzL2NvbmNlcHRzL2FuYWx5dGljcy9jdXN0b20tZXZlbnRzKSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBjdXN0b20gZXZlbnRzLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gKiAqIEV4YW1wbGVzOiBgUHVyY2hhc2VgLCBgQ2xpY2sgQnV0dG9uYCwgb3IgYFBsYXkgVmlkZW9gLlxuICogQHBhcmFtIFtwcm9wZXJ0aWVzXSAtIEFkZGl0aW9uYWwgcHJvcGVydGllcyBvZiB0aGUgZXZlbnQuIE5lc3RlZCBvYmplY3RzIGFyZSBub3Qgc3VwcG9ydGVkLiBBbGxvd2VkIHZhbHVlcyBhcmUgYHN0cmluZ2AsIGBudW1iZXJgLCBgYm9vbGVhbmAsIGFuZCBgbnVsbGAuXG4gKi9cbmZ1bmN0aW9uIHRyYWNrKFxuICBuYW1lOiBzdHJpbmcsXG4gIHByb3BlcnRpZXM/OiBSZWNvcmQ8c3RyaW5nLCBBbGxvd2VkUHJvcGVydHlWYWx1ZXM+LFxuICBvcHRpb25zPzoge1xuICAgIGZsYWdzPzogRmxhZ3NEYXRhSW5wdXQ7XG4gIH1cbik6IHZvaWQge1xuICBpZiAoIWlzQnJvd3NlcigpKSB7XG4gICAgY29uc3QgbXNnID1cbiAgICAgICdbVmVyY2VsIFdlYiBBbmFseXRpY3NdIFBsZWFzZSBpbXBvcnQgYHRyYWNrYCBmcm9tIGBAdmVyY2VsL2FuYWx5dGljcy9zZXJ2ZXJgIHdoZW4gdXNpbmcgdGhpcyBmdW5jdGlvbiBpbiBhIHNlcnZlciBlbnZpcm9ubWVudCc7XG5cbiAgICBpZiAoaXNQcm9kdWN0aW9uKCkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlIC0tIFNob3cgd2FybmluZyBpbiBwcm9kdWN0aW9uXG4gICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFwcm9wZXJ0aWVzKSB7XG4gICAgd2luZG93LnZhPy4oJ2V2ZW50JywgeyBuYW1lLCBvcHRpb25zIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgcHJvcHMgPSBwYXJzZVByb3BlcnRpZXMocHJvcGVydGllcywge1xuICAgICAgc3RyaXA6IGlzUHJvZHVjdGlvbigpLFxuICAgIH0pO1xuXG4gICAgd2luZG93LnZhPy4oJ2V2ZW50Jywge1xuICAgICAgbmFtZSxcbiAgICAgIGRhdGE6IHByb3BzLFxuICAgICAgb3B0aW9ucyxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmIGlzRGV2ZWxvcG1lbnQoKSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGUgLS0gTG9nZ2luZyB0byBjb25zb2xlIGlzIGludGVudGlvbmFsXG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhZ2V2aWV3KHtcbiAgcm91dGUsXG4gIHBhdGgsXG59OiB7XG4gIHJvdXRlPzogc3RyaW5nIHwgbnVsbDtcbiAgcGF0aD86IHN0cmluZztcbn0pOiB2b2lkIHtcbiAgd2luZG93LnZhPy4oJ3BhZ2V2aWV3JywgeyByb3V0ZSwgcGF0aCB9KTtcbn1cblxuZXhwb3J0IHsgaW5qZWN0LCB0cmFjaywgcGFnZXZpZXcsIGNvbXB1dGVSb3V0ZSB9O1xuZXhwb3J0IHR5cGUgeyBBbmFseXRpY3NQcm9wcywgQmVmb3JlU2VuZCwgQmVmb3JlU2VuZEV2ZW50IH07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZGVmYXVsdC1leHBvcnQgLS0gRGVmYXVsdCBleHBvcnQgaXMgaW50ZW50aW9uYWxcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5qZWN0LFxuICB0cmFjayxcbiAgY29tcHV0ZVJvdXRlLFxufTtcbiIsImV4cG9ydCBmdW5jdGlvbiBnZXRCYXNlUGF0aCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAvLyAhISBpbXBvcnRhbnQgISFcbiAgLy8gZG8gbm90IGFjY2VzcyBlbnYgdmFyaWFibGVzIHVzaW5nIHByb2Nlc3MuZW52W3Zhcm5hbWVdXG4gIC8vIHNvbWUgYnVuZGxlcyB3b24ndCByZXBsYWNlIHRoZSB2YWx1ZSBhdCBidWlsZCB0aW1lLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1vcHRpb25hbC1jaGFpbiAtLSB3ZSBjYW4ndCB1c2Ugb3B0aW9ubmFsIGhlcmUsIGl0J2xsIGJyZWFrIGlmIHByb2Nlc3MgZG9lcyBub3QgZXhpc3QuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHByb2Nlc3MuZW52ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHByb2Nlc3MuZW52LlJFQUNUX0FQUF9WRVJDRUxfT0JTRVJWQUJJTElUWV9CQVNFUEFUSDtcbn1cbiJdLCJuYW1lcyI6WyJuYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@vercel/analytics/dist/react/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@vercel/speed-insights/dist/react/index.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@vercel/speed-insights/dist/react/index.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpeedInsights: () => (/* binding */ SpeedInsights),\n/* harmony export */   computeRoute: () => (/* binding */ computeRoute)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* __next_internal_client_entry_do_not_use__ SpeedInsights,computeRoute auto */ var _s = $RefreshSig$();\n// src/react/index.tsx\n\n// package.json\nvar name = \"@vercel/speed-insights\";\nvar version = \"1.3.1\";\n// src/queue.ts\nvar initQueue = ()=>{\n    if (window.si) return;\n    window.si = function a() {\n        for(var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++){\n            params[_key] = arguments[_key];\n        }\n        (window.siq = window.siq || []).push(params);\n    };\n};\n// src/utils.ts\nfunction isBrowser() {\n    return typeof window !== \"undefined\";\n}\nfunction detectEnvironment() {\n    try {\n        const env = \"development\";\n        if (env === \"development\" || env === \"test\") {\n            return \"development\";\n        }\n    } catch (e) {}\n    return \"production\";\n}\nfunction isDevelopment() {\n    return detectEnvironment() === \"development\";\n}\nfunction computeRoute(pathname, pathParams) {\n    if (!pathname || !pathParams) {\n        return pathname;\n    }\n    let result = pathname;\n    try {\n        const entries = Object.entries(pathParams);\n        for (const [key, value] of entries){\n            if (!Array.isArray(value)) {\n                const matcher = turnValueToRegExp(value);\n                if (matcher.test(result)) {\n                    result = result.replace(matcher, \"/[\".concat(key, \"]\"));\n                }\n            }\n        }\n        for (const [key, value] of entries){\n            if (Array.isArray(value)) {\n                const matcher = turnValueToRegExp(value.join(\"/\"));\n                if (matcher.test(result)) {\n                    result = result.replace(matcher, \"/[...\".concat(key, \"]\"));\n                }\n            }\n        }\n        return result;\n    } catch (e) {\n        return pathname;\n    }\n}\nfunction turnValueToRegExp(value) {\n    return new RegExp(\"/\".concat(escapeRegExp(value), \"(?=[/?#]|$)\"));\n}\nfunction escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction getScriptSrc(props) {\n    if (props.scriptSrc) {\n        return props.scriptSrc;\n    }\n    if (isDevelopment()) {\n        return \"https://va.vercel-scripts.com/v1/speed-insights/script.debug.js\";\n    }\n    if (props.dsn) {\n        return \"https://va.vercel-scripts.com/v1/speed-insights/script.js\";\n    }\n    if (props.basePath) {\n        return \"\".concat(props.basePath, \"/speed-insights/script.js\");\n    }\n    return \"/_vercel/speed-insights/script.js\";\n}\n// src/generic.ts\nfunction injectSpeedInsights() {\n    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    var _a;\n    if (!isBrowser() || props.route === null) return null;\n    initQueue();\n    const src = getScriptSrc(props);\n    if (document.head.querySelector('script[src*=\"'.concat(src, '\"]'))) return null;\n    if (props.beforeSend) {\n        (_a = window.si) == null ? void 0 : _a.call(window, \"beforeSend\", props.beforeSend);\n    }\n    const script = document.createElement(\"script\");\n    script.src = src;\n    script.defer = true;\n    script.dataset.sdkn = name + (props.framework ? \"/\".concat(props.framework) : \"\");\n    script.dataset.sdkv = version;\n    if (props.sampleRate) {\n        script.dataset.sampleRate = props.sampleRate.toString();\n    }\n    if (props.route) {\n        script.dataset.route = props.route;\n    }\n    if (props.endpoint) {\n        script.dataset.endpoint = props.endpoint;\n    } else if (props.basePath) {\n        script.dataset.endpoint = \"\".concat(props.basePath, \"/speed-insights/vitals\");\n    }\n    if (props.dsn) {\n        script.dataset.dsn = props.dsn;\n    }\n    if (isDevelopment() && props.debug === false) {\n        script.dataset.debug = \"false\";\n    }\n    script.onerror = ()=>{\n        console.log(\"[Vercel Speed Insights] Failed to load script from \".concat(src, \". Please check if any content blockers are enabled and try again.\"));\n    };\n    document.head.appendChild(script);\n    return {\n        setRoute: (route)=>{\n            script.dataset.route = route !== null && route !== void 0 ? route : void 0;\n        }\n    };\n}\n// src/react/utils.ts\nfunction getBasePath() {\n    if (typeof process === \"undefined\" || typeof process.env === \"undefined\") {\n        return void 0;\n    }\n    return process.env.REACT_APP_VERCEL_OBSERVABILITY_BASEPATH;\n}\n// src/react/index.tsx\nfunction SpeedInsights(props) {\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"SpeedInsights.useEffect\": ()=>{\n            var _a;\n            if (props.beforeSend) {\n                (_a = window.si) == null ? void 0 : _a.call(window, \"beforeSend\", props.beforeSend);\n            }\n        }\n    }[\"SpeedInsights.useEffect\"], [\n        props.beforeSend\n    ]);\n    const setScriptRoute = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"SpeedInsights.useEffect\": ()=>{\n            if (!setScriptRoute.current) {\n                var _props_framework, _props_basePath;\n                const script = injectSpeedInsights({\n                    framework: (_props_framework = props.framework) !== null && _props_framework !== void 0 ? _props_framework : \"react\",\n                    basePath: (_props_basePath = props.basePath) !== null && _props_basePath !== void 0 ? _props_basePath : getBasePath(),\n                    ...props\n                });\n                if (script) {\n                    setScriptRoute.current = script.setRoute;\n                }\n            } else if (props.route) {\n                setScriptRoute.current(props.route);\n            }\n        }\n    }[\"SpeedInsights.useEffect\"], [\n        props.route\n    ]);\n    return null;\n}\n_s(SpeedInsights, \"E0RdZlqeWq0rUoAi6s7Wz4n3yAk=\");\n_c = SpeedInsights;\n //# sourceMappingURL=index.mjs.map\nvar _c;\n$RefreshReg$(_c, \"SpeedInsights\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdmVyY2VsL3NwZWVkLWluc2lnaHRzL2Rpc3QvcmVhY3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUVrQzs7QUNEaEMsV0FBUTtBQUNSLGNBQVc7O0FDRk4sSUFBTSxZQUFZO0lBRXZCLElBQUksT0FBTyxHQUFJO0lBRWYsT0FBTyxLQUFLLFNBQVM7UUFBQTtZQUFLLE9BQUwsdUJBQUs7O1NBQ3ZCLE9BQU8sTUFBTSxPQUFPLE9BQU8sRUFBQyxFQUFHLEtBQUssTUFBTTtJQUM3QztBQUNGOztBQ0xPLFNBQVMsWUFBcUI7SUFDbkMsT0FBTyxPQUFPLFdBQVc7QUFDM0I7QUFFQSxTQUFTLG9CQUFrRDtJQUN6RCxJQUFJO1FBQ0YsTUFBTSxNQUFNLEtBQVEsSUFBSTtRQUN4QixJQUFJLFFBQVEsaUJBQWlCLFFBQVEsUUFBUTtZQUMzQyxPQUFPO1FBQ1Q7SUFDRixTQUFTLEdBQUcsQ0FFWjtJQUNBLE9BQU87QUFDVDtBQU1PLFNBQVMsZ0JBQXlCO0lBQ3ZDLE9BQU8sa0JBQWtCLE1BQU07QUFDakM7QUFFTyxTQUFTLGFBQ2QsVUFDQSxZQUNlO0lBQ2YsSUFBSSxDQUFDLFlBQVksQ0FBQyxZQUFZO1FBQzVCLE9BQU87SUFDVDtJQUVBLElBQUksU0FBUztJQUNiLElBQUk7UUFDRixNQUFNLFVBQVUsT0FBTyxRQUFRLFVBQVU7UUFFekMsV0FBVyxDQUFDLEtBQUssS0FBSyxLQUFLLFFBQVM7WUFDbEMsSUFBSSxDQUFDLE1BQU0sUUFBUSxLQUFLLEdBQUc7Z0JBQ3pCLE1BQU0sVUFBVSxrQkFBa0IsS0FBSztnQkFDdkMsSUFBSSxRQUFRLEtBQUssTUFBTSxHQUFHO29CQUN4QixTQUFTLE9BQU8sUUFBUSxTQUFTLEtBQVEsT0FBSCxHQUFHLElBQUc7Z0JBQzlDO1lBQ0Y7UUFDRjtRQUVBLFdBQVcsQ0FBQyxLQUFLLEtBQUssS0FBSyxRQUFTO1lBQ2xDLElBQUksTUFBTSxRQUFRLEtBQUssR0FB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LHFFQUFZLFlBQVk7b0JBQ3hDLEdBQUc7Z0JBQ0wsQ0FBQztnQkFDRCxJQUFJLFFBQVE7b0JBQ1YsZUFBZSxVQUFVLE9BQU87Z0JBQ2xDO1lBQ0YsV0FBVyxNQUFNLE9BQU87Z0JBQ3RCLGVBQWUsUUFBUSxNQUFNLEtBQUs7WUFDcEM7UUFDRjtrQ0FBRztRQUFDLE1BQU0sS0FBSztLQUFDO0lBRWhCLE9BQU87QUFDVDs7S0E3QmdCIiwic291cmNlcyI6WyIvVm9sdW1lcy9QZWRyb1NTRC9zcmMvcmVhY3QvaW5kZXgudHN4IiwiL1ZvbHVtZXMvUGVkcm9TU0QvcGFja2FnZS5qc29uIiwiL1ZvbHVtZXMvUGVkcm9TU0Qvc3JjL3F1ZXVlLnRzIiwiL1ZvbHVtZXMvUGVkcm9TU0Qvc3JjL3V0aWxzLnRzIiwiL1ZvbHVtZXMvUGVkcm9TU0Qvc3JjL2dlbmVyaWMudHMiLCIvVm9sdW1lcy9QZWRyb1NTRC9zcmMvcmVhY3QvdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIHsgU3BlZWRJbnNpZ2h0c1Byb3BzIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgY29tcHV0ZVJvdXRlLCBpbmplY3RTcGVlZEluc2lnaHRzIH0gZnJvbSAnLi4vZ2VuZXJpYyc7XG5pbXBvcnQgeyBnZXRCYXNlUGF0aCB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gU3BlZWRJbnNpZ2h0cyhcbiAgcHJvcHM6IFNwZWVkSW5zaWdodHNQcm9wcyAmIHtcbiAgICBmcmFtZXdvcms/OiBzdHJpbmc7XG4gICAgYmFzZVBhdGg/OiBzdHJpbmc7XG4gIH0sXG4pOiBKU1guRWxlbWVudCB8IG51bGwge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcm9wcy5iZWZvcmVTZW5kKSB7XG4gICAgICB3aW5kb3cuc2k/LignYmVmb3JlU2VuZCcsIHByb3BzLmJlZm9yZVNlbmQpO1xuICAgIH1cbiAgfSwgW3Byb3BzLmJlZm9yZVNlbmRdKTtcblxuICBjb25zdCBzZXRTY3JpcHRSb3V0ZSA9IHVzZVJlZjwoKHBhdGg6IHN0cmluZykgPT4gdm9pZCkgfCBudWxsPihudWxsKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNldFNjcmlwdFJvdXRlLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IHNjcmlwdCA9IGluamVjdFNwZWVkSW5zaWdodHMoe1xuICAgICAgICBmcmFtZXdvcms6IHByb3BzLmZyYW1ld29yayA/PyAncmVhY3QnLFxuICAgICAgICBiYXNlUGF0aDogcHJvcHMuYmFzZVBhdGggPz8gZ2V0QmFzZVBhdGgoKSxcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICB9KTtcbiAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgc2V0U2NyaXB0Um91dGUuY3VycmVudCA9IHNjcmlwdC5zZXRSb3V0ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BzLnJvdXRlKSB7XG4gICAgICBzZXRTY3JpcHRSb3V0ZS5jdXJyZW50KHByb3BzLnJvdXRlKTtcbiAgICB9XG4gIH0sIFtwcm9wcy5yb3V0ZV0pO1xuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBjb21wdXRlUm91dGUgfTtcbiIsIntcbiAgXCJuYW1lXCI6IFwiQHZlcmNlbC9zcGVlZC1pbnNpZ2h0c1wiLFxuICBcInZlcnNpb25cIjogXCIxLjMuMVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiU3BlZWQgSW5zaWdodHMgaXMgYSB0b29sIGZvciBtZWFzdXJpbmcgd2ViIHBlcmZvcm1hbmNlIGFuZCBwcm92aWRpbmcgc3VnZ2VzdGlvbnMgZm9yIGltcHJvdmVtZW50LlwiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcInNwZWVkLWluc2lnaHRzXCIsXG4gICAgXCJ2ZXJjZWxcIlxuICBdLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidXJsXCI6IFwiZ2l0aHViOnZlcmNlbC9zcGVlZC1pbnNpZ2h0c1wiLFxuICAgIFwiZGlyZWN0b3J5XCI6IFwicGFja2FnZXMvd2ViXCJcbiAgfSxcbiAgXCJsaWNlbnNlXCI6IFwiQXBhY2hlLTIuMFwiLFxuICBcImV4cG9ydHNcIjoge1xuICAgIFwiLi9wYWNrYWdlLmpzb25cIjogXCIuL3BhY2thZ2UuanNvblwiLFxuICAgIFwiLlwiOiB7XG4gICAgICBcImJyb3dzZXJcIjogXCIuL2Rpc3QvaW5kZXgubWpzXCIsXG4gICAgICBcImltcG9ydFwiOiBcIi4vZGlzdC9pbmRleC5tanNcIixcbiAgICAgIFwicmVxdWlyZVwiOiBcIi4vZGlzdC9pbmRleC5qc1wiXG4gICAgfSxcbiAgICBcIi4vYXN0cm9cIjoge1xuICAgICAgXCJpbXBvcnRcIjogXCIuL2Rpc3QvYXN0cm8vY29tcG9uZW50LnRzXCJcbiAgICB9LFxuICAgIFwiLi9uZXh0XCI6IHtcbiAgICAgIFwiYnJvd3NlclwiOiBcIi4vZGlzdC9uZXh0L2luZGV4Lm1qc1wiLFxuICAgICAgXCJpbXBvcnRcIjogXCIuL2Rpc3QvbmV4dC9pbmRleC5tanNcIixcbiAgICAgIFwicmVxdWlyZVwiOiBcIi4vZGlzdC9uZXh0L2luZGV4LmpzXCJcbiAgICB9LFxuICAgIFwiLi9udXh0XCI6IHtcbiAgICAgIFwiYnJvd3NlclwiOiBcIi4vZGlzdC9udXh0L2luZGV4Lm1qc1wiLFxuICAgICAgXCJpbXBvcnRcIjogXCIuL2Rpc3QvbnV4dC9pbmRleC5tanNcIixcbiAgICAgIFwicmVxdWlyZVwiOiBcIi4vZGlzdC9udXh0L2luZGV4LmpzXCJcbiAgICB9LFxuICAgIFwiLi9yZWFjdFwiOiB7XG4gICAgICBcImJyb3dzZXJcIjogXCIuL2Rpc3QvcmVhY3QvaW5kZXgubWpzXCIsXG4gICAgICBcImltcG9ydFwiOiBcIi4vZGlzdC9yZWFjdC9pbmRleC5tanNcIixcbiAgICAgIFwicmVxdWlyZVwiOiBcIi4vZGlzdC9yZWFjdC9pbmRleC5qc1wiXG4gICAgfSxcbiAgICBcIi4vcmVtaXhcIjoge1xuICAgICAgXCJicm93c2VyXCI6IFwiLi9kaXN0L3JlbWl4L2luZGV4Lm1qc1wiLFxuICAgICAgXCJpbXBvcnRcIjogXCIuL2Rpc3QvcmVtaXgvaW5kZXgubWpzXCIsXG4gICAgICBcInJlcXVpcmVcIjogXCIuL2Rpc3QvcmVtaXgvaW5kZXguanNcIlxuICAgIH0sXG4gICAgXCIuL3N2ZWx0ZWtpdFwiOiB7XG4gICAgICBcInR5cGVzXCI6IFwiLi9kaXN0L3N2ZWx0ZWtpdC9pbmRleC5kLnRzXCIsXG4gICAgICBcInN2ZWx0ZVwiOiBcIi4vZGlzdC9zdmVsdGVraXQvaW5kZXgubWpzXCJcbiAgICB9LFxuICAgIFwiLi92dWVcIjoge1xuICAgICAgXCJicm93c2VyXCI6IFwiLi9kaXN0L3Z1ZS9pbmRleC5tanNcIixcbiAgICAgIFwiaW1wb3J0XCI6IFwiLi9kaXN0L3Z1ZS9pbmRleC5tanNcIixcbiAgICAgIFwicmVxdWlyZVwiOiBcIi4vZGlzdC92dWUvaW5kZXguanNcIlxuICAgIH1cbiAgfSxcbiAgXCJtYWluXCI6IFwiLi9kaXN0L2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCIuL2Rpc3QvaW5kZXguZC50c1wiLFxuICBcInR5cGVzVmVyc2lvbnNcIjoge1xuICAgIFwiKlwiOiB7XG4gICAgICBcIipcIjogW1xuICAgICAgICBcImRpc3QvaW5kZXguZC50c1wiXG4gICAgICBdLFxuICAgICAgXCJyZWFjdFwiOiBbXG4gICAgICAgIFwiZGlzdC9yZWFjdC9pbmRleC5kLnRzXCJcbiAgICAgIF0sXG4gICAgICBcIm5leHRcIjogW1xuICAgICAgICBcImRpc3QvbmV4dC9pbmRleC5kLnRzXCJcbiAgICAgIF0sXG4gICAgICBcIm51eHRcIjogW1xuICAgICAgICBcImRpc3QvbnV4dC9pbmRleC5kLnRzXCJcbiAgICAgIF0sXG4gICAgICBcInJlbWl4XCI6IFtcbiAgICAgICAgXCJkaXN0L3JlbWl4L2luZGV4LmQudHNcIlxuICAgICAgXSxcbiAgICAgIFwic3ZlbHRla2l0XCI6IFtcbiAgICAgICAgXCJkaXN0L3N2ZWx0ZWtpdC9pbmRleC5kLnRzXCJcbiAgICAgIF0sXG4gICAgICBcInZ1ZVwiOiBbXG4gICAgICAgIFwiZGlzdC92dWUvaW5kZXguZC50c1wiXG4gICAgICBdXG4gICAgfVxuICB9LFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiYnVpbGRcIjogXCJ0c3VwICYmIHBucG0gY29weS1hc3Ryb1wiLFxuICAgIFwiY29weS1hc3Ryb1wiOiBcImNwIC1SIHNyYy9hc3RybyBkaXN0L1wiLFxuICAgIFwiZGV2XCI6IFwicG5wbSBjb3B5LWFzdHJvICYmIHRzdXAgLS13YXRjaFwiLFxuICAgIFwibGludFwiOiBcImVzbGludCAuXCIsXG4gICAgXCJsaW50LWZpeFwiOiBcImVzbGludCAuIC0tZml4XCIsXG4gICAgXCJ0ZXN0XCI6IFwidml0ZXN0XCIsXG4gICAgXCJ0eXBlLWNoZWNrXCI6IFwidHNjIC0tbm9FbWl0XCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHJlbWl4LXJ1bi9yZWFjdFwiOiBcIl4yLjE0LjBcIixcbiAgICBcIkBzdmVsdGVqcy9raXRcIjogXCJeMi44LjFcIixcbiAgICBcIkBzd2MvY29yZVwiOiBcIl4xLjkuMlwiLFxuICAgIFwiQHRlc3RpbmctbGlicmFyeS9qZXN0LWRvbVwiOiBcIl42LjYuM1wiLFxuICAgIFwiQHRlc3RpbmctbGlicmFyeS9yZWFjdFwiOiBcIl4xNi4wLjFcIixcbiAgICBcIkB0eXBlcy9ub2RlXCI6IFwiXjIyLjkuMVwiLFxuICAgIFwiQHR5cGVzL3JlYWN0XCI6IFwiXjE4LjMuMTJcIixcbiAgICBcImNvcHlmaWxlc1wiOiBcIl4yLjQuMVwiLFxuICAgIFwianNkb21cIjogXCJeMjUuMC4xXCIsXG4gICAgXCJuZXh0XCI6IFwiXjE0LjAuNFwiLFxuICAgIFwicmVhY3RcIjogXCJeMTguMy4xXCIsXG4gICAgXCJyZWFjdC1kb21cIjogXCJeMTguMy4xXCIsXG4gICAgXCJzdmVsdGVcIjogXCJeNS4yLjdcIixcbiAgICBcInRzdXBcIjogXCI4LjMuNVwiLFxuICAgIFwidml0ZXN0XCI6IFwiXjIuMS41XCIsXG4gICAgXCJ2dWVcIjogXCJeMy41LjEzXCIsXG4gICAgXCJ2dWUtcm91dGVyXCI6IFwiXjQuNC41XCJcbiAgfSxcbiAgXCJwZWVyRGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBzdmVsdGVqcy9raXRcIjogXCJeMSB8fCBeMlwiLFxuICAgIFwibmV4dFwiOiBcIj49IDEzXCIsXG4gICAgXCJyZWFjdFwiOiBcIl4xOCB8fCBeMTkgfHwgXjE5LjAuMC1yY1wiLFxuICAgIFwic3ZlbHRlXCI6IFwiPj0gNFwiLFxuICAgIFwidnVlXCI6IFwiXjNcIixcbiAgICBcInZ1ZS1yb3V0ZXJcIjogXCJeNFwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc01ldGFcIjoge1xuICAgIFwiQHN2ZWx0ZWpzL2tpdFwiOiB7XG4gICAgICBcIm9wdGlvbmFsXCI6IHRydWVcbiAgICB9LFxuICAgIFwibmV4dFwiOiB7XG4gICAgICBcIm9wdGlvbmFsXCI6IHRydWVcbiAgICB9LFxuICAgIFwicmVhY3RcIjoge1xuICAgICAgXCJvcHRpb25hbFwiOiB0cnVlXG4gICAgfSxcbiAgICBcInN2ZWx0ZVwiOiB7XG4gICAgICBcIm9wdGlvbmFsXCI6IHRydWVcbiAgICB9LFxuICAgIFwidnVlXCI6IHtcbiAgICAgIFwib3B0aW9uYWxcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJ2dWUtcm91dGVyXCI6IHtcbiAgICAgIFwib3B0aW9uYWxcIjogdHJ1ZVxuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IGluaXRRdWV1ZSA9ICgpOiB2b2lkID0+IHtcbiAgLy8gaW5pdGlhbGl6ZSB2YSB1bnRpbCBzY3JpcHQgaXMgbG9hZGVkXG4gIGlmICh3aW5kb3cuc2kpIHJldHVybjtcblxuICB3aW5kb3cuc2kgPSBmdW5jdGlvbiBhKC4uLnBhcmFtcyk6IHZvaWQge1xuICAgICh3aW5kb3cuc2lxID0gd2luZG93LnNpcSB8fCBbXSkucHVzaChwYXJhbXMpO1xuICB9O1xufTtcbiIsImltcG9ydCB0eXBlIHsgU3BlZWRJbnNpZ2h0c1Byb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Jyb3dzZXIoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cblxuZnVuY3Rpb24gZGV0ZWN0RW52aXJvbm1lbnQoKTogJ2RldmVsb3BtZW50JyB8ICdwcm9kdWN0aW9uJyB7XG4gIHRyeSB7XG4gICAgY29uc3QgZW52ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlY7XG4gICAgaWYgKGVudiA9PT0gJ2RldmVsb3BtZW50JyB8fCBlbnYgPT09ICd0ZXN0Jykge1xuICAgICAgcmV0dXJuICdkZXZlbG9wbWVudCc7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZG8gbm90aGluZywgdGhpcyBpcyBva2F5XG4gIH1cbiAgcmV0dXJuICdwcm9kdWN0aW9uJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvZHVjdGlvbigpOiBib29sZWFuIHtcbiAgcmV0dXJuIGRldGVjdEVudmlyb25tZW50KCkgPT09ICdwcm9kdWN0aW9uJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGV2ZWxvcG1lbnQoKTogYm9vbGVhbiB7XG4gIHJldHVybiBkZXRlY3RFbnZpcm9ubWVudCgpID09PSAnZGV2ZWxvcG1lbnQnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVJvdXRlKFxuICBwYXRobmFtZTogc3RyaW5nIHwgbnVsbCxcbiAgcGF0aFBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+IHwgbnVsbCxcbik6IHN0cmluZyB8IG51bGwge1xuICBpZiAoIXBhdGhuYW1lIHx8ICFwYXRoUGFyYW1zKSB7XG4gICAgcmV0dXJuIHBhdGhuYW1lO1xuICB9XG5cbiAgbGV0IHJlc3VsdCA9IHBhdGhuYW1lO1xuICB0cnkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhwYXRoUGFyYW1zKTtcbiAgICAvLyBzaW1wbGUga2V5cyBtdXN0IGJlIGhhbmRsZWQgZmlyc3RcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXIgPSB0dXJuVmFsdWVUb1JlZ0V4cCh2YWx1ZSk7XG4gICAgICAgIGlmIChtYXRjaGVyLnRlc3QocmVzdWx0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKG1hdGNoZXIsIGAvWyR7a2V5fV1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBhcnJheSB2YWx1ZXMgbmV4dFxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBtYXRjaGVyID0gdHVyblZhbHVlVG9SZWdFeHAodmFsdWUuam9pbignLycpKTtcbiAgICAgICAgaWYgKG1hdGNoZXIudGVzdChyZXN1bHQpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UobWF0Y2hlciwgYC9bLi4uJHtrZXl9XWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gcGF0aG5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHVyblZhbHVlVG9SZWdFeHAodmFsdWU6IHN0cmluZyk6IFJlZ0V4cCB7XG4gIHJldHVybiBuZXcgUmVnRXhwKGAvJHtlc2NhcGVSZWdFeHAodmFsdWUpfSg/PVsvPyNdfCQpYCk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjcmlwdFNyYyhcbiAgcHJvcHM6IFNwZWVkSW5zaWdodHNQcm9wcyAmIHsgYmFzZVBhdGg/OiBzdHJpbmcgfSxcbik6IHN0cmluZyB7XG4gIGlmIChwcm9wcy5zY3JpcHRTcmMpIHtcbiAgICByZXR1cm4gcHJvcHMuc2NyaXB0U3JjO1xuICB9XG4gIGlmIChpc0RldmVsb3BtZW50KCkpIHtcbiAgICByZXR1cm4gJ2h0dHBzOi8vdmEudmVyY2VsLXNjcmlwdHMuY29tL3YxL3NwZWVkLWluc2lnaHRzL3NjcmlwdC5kZWJ1Zy5qcyc7XG4gIH1cbiAgaWYgKHByb3BzLmRzbikge1xuICAgIHJldHVybiAnaHR0cHM6Ly92YS52ZXJjZWwtc2NyaXB0cy5jb20vdjEvc3BlZWQtaW5zaWdodHMvc2NyaXB0LmpzJztcbiAgfVxuICBpZiAocHJvcHMuYmFzZVBhdGgpIHtcbiAgICByZXR1cm4gYCR7cHJvcHMuYmFzZVBhdGh9L3NwZWVkLWluc2lnaHRzL3NjcmlwdC5qc2A7XG4gIH1cbiAgcmV0dXJuICcvX3ZlcmNlbC9zcGVlZC1pbnNpZ2h0cy9zY3JpcHQuanMnO1xufVxuIiwiaW1wb3J0IHsgbmFtZSBhcyBwYWNrYWdlTmFtZSwgdmVyc2lvbiB9IGZyb20gJy4uL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBpbml0UXVldWUgfSBmcm9tICcuL3F1ZXVlJztcbmltcG9ydCB0eXBlIHsgU3BlZWRJbnNpZ2h0c1Byb3BzLCBCZWZvcmVTZW5kTWlkZGxld2FyZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgY29tcHV0ZVJvdXRlLCBnZXRTY3JpcHRTcmMsIGlzQnJvd3NlciwgaXNEZXZlbG9wbWVudCB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIEluamVjdHMgdGhlIFZlcmNlbCBTcGVlZCBJbnNpZ2h0cyBzY3JpcHQgaW50byB0aGUgcGFnZSBoZWFkIGFuZCBzdGFydHMgdHJhY2tpbmcgcGFnZSB2aWV3cy4gUmVhZCBtb3JlIGluIG91ciBbZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly92ZXJjZWwuY29tL2RvY3Mvc3BlZWQtaW5zaWdodHMpLlxuICogQHBhcmFtIFtwcm9wc10gLSBTcGVlZCBJbnNpZ2h0cyBvcHRpb25zLlxuICogQHBhcmFtIFtwcm9wcy5kZWJ1Z10gLSBXaGV0aGVyIHRvIGVuYWJsZSBkZWJ1ZyBsb2dnaW5nIGluIGRldmVsb3BtZW50LiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKiBAcGFyYW0gW3Byb3BzLmJlZm9yZVNlbmRdIC0gQSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIG1vZGlmeSBldmVudHMgYmVmb3JlIHRoZXkgYXJlIHNlbnQuIFNob3VsZCByZXR1cm4gdGhlIGV2ZW50IG9iamVjdCBvciBgbnVsbGAgdG8gY2FuY2VsIHRoZSBldmVudC5cbiAqIEBwYXJhbSBbcHJvcHMuc2FtcGxlUmF0ZV0gLSBXaGVuIHNldHRpbmcgdG8gMC41LCA1MCUgb2YgdGhlIGV2ZW50cyB3aWxsIGJlIHNlbnQgdG8gVmVyY2VsIFNwZWVkIEluc2lnaHRzLiBEZWZhdWx0cyB0byBgMWAuXG4gKiBAcGFyYW0gW3Byb3BzLnJvdXRlXSAtIFRoZSBkeW5hbWljIHJvdXRlIG9mIHRoZSBwYWdlLlxuICogQHBhcmFtIFtwcm9wcy5kc25dIC0gVGhlIERTTiBvZiB0aGUgcHJvamVjdCB0byBzZW5kIGV2ZW50cyB0by4gT25seSByZXF1aXJlZCB3aGVuIHNlbGYtaG9zdGluZy5cbiAqL1xuZnVuY3Rpb24gaW5qZWN0U3BlZWRJbnNpZ2h0cyhcbiAgcHJvcHM6IFNwZWVkSW5zaWdodHNQcm9wcyAmIHtcbiAgICBmcmFtZXdvcms/OiBzdHJpbmc7XG4gICAgYmFzZVBhdGg/OiBzdHJpbmc7XG4gIH0gPSB7fSxcbik6IHtcbiAgc2V0Um91dGU6IChyb3V0ZTogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcbn0gfCBudWxsIHtcbiAgLy8gV2hlbiByb3V0ZSBpcyBudWxsLCBpdCBtZWFucyB0aGF0IHBhZ2VzIHJvdXRlciBpcyBub3QgcmVhZHkgeWV0LiBXaWxsIHJlc29sdmUgc29vblxuICBpZiAoIWlzQnJvd3NlcigpIHx8IHByb3BzLnJvdXRlID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICBpbml0UXVldWUoKTtcblxuICBjb25zdCBzcmMgPSBnZXRTY3JpcHRTcmMocHJvcHMpO1xuXG4gIGlmIChkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoYHNjcmlwdFtzcmMqPVwiJHtzcmN9XCJdYCkpIHJldHVybiBudWxsO1xuXG4gIGlmIChwcm9wcy5iZWZvcmVTZW5kKSB7XG4gICAgd2luZG93LnNpPy4oJ2JlZm9yZVNlbmQnLCBwcm9wcy5iZWZvcmVTZW5kKTtcbiAgfVxuXG4gIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICBzY3JpcHQuc3JjID0gc3JjO1xuICBzY3JpcHQuZGVmZXIgPSB0cnVlO1xuICBzY3JpcHQuZGF0YXNldC5zZGtuID1cbiAgICBwYWNrYWdlTmFtZSArIChwcm9wcy5mcmFtZXdvcmsgPyBgLyR7cHJvcHMuZnJhbWV3b3JrfWAgOiAnJyk7XG4gIHNjcmlwdC5kYXRhc2V0LnNka3YgPSB2ZXJzaW9uO1xuXG4gIGlmIChwcm9wcy5zYW1wbGVSYXRlKSB7XG4gICAgc2NyaXB0LmRhdGFzZXQuc2FtcGxlUmF0ZSA9IHByb3BzLnNhbXBsZVJhdGUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAocHJvcHMucm91dGUpIHtcbiAgICBzY3JpcHQuZGF0YXNldC5yb3V0ZSA9IHByb3BzLnJvdXRlO1xuICB9XG4gIGlmIChwcm9wcy5lbmRwb2ludCkge1xuICAgIHNjcmlwdC5kYXRhc2V0LmVuZHBvaW50ID0gcHJvcHMuZW5kcG9pbnQ7XG4gIH0gZWxzZSBpZiAocHJvcHMuYmFzZVBhdGgpIHtcbiAgICBzY3JpcHQuZGF0YXNldC5lbmRwb2ludCA9IGAke3Byb3BzLmJhc2VQYXRofS9zcGVlZC1pbnNpZ2h0cy92aXRhbHNgO1xuICB9XG4gIGlmIChwcm9wcy5kc24pIHtcbiAgICBzY3JpcHQuZGF0YXNldC5kc24gPSBwcm9wcy5kc247XG4gIH1cbiAgaWYgKGlzRGV2ZWxvcG1lbnQoKSAmJiBwcm9wcy5kZWJ1ZyA9PT0gZmFsc2UpIHtcbiAgICBzY3JpcHQuZGF0YXNldC5kZWJ1ZyA9ICdmYWxzZSc7XG4gIH1cblxuICBzY3JpcHQub25lcnJvciA9ICgpOiB2b2lkID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZSAtLSBMb2dnaW5nIGlzIG9rYXkgaGVyZVxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYFtWZXJjZWwgU3BlZWQgSW5zaWdodHNdIEZhaWxlZCB0byBsb2FkIHNjcmlwdCBmcm9tICR7c3JjfS4gUGxlYXNlIGNoZWNrIGlmIGFueSBjb250ZW50IGJsb2NrZXJzIGFyZSBlbmFibGVkIGFuZCB0cnkgYWdhaW4uYCxcbiAgICApO1xuICB9O1xuXG4gIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblxuICByZXR1cm4ge1xuICAgIHNldFJvdXRlOiAocm91dGU6IHN0cmluZyB8IG51bGwpOiB2b2lkID0+IHtcbiAgICAgIHNjcmlwdC5kYXRhc2V0LnJvdXRlID0gcm91dGUgPz8gdW5kZWZpbmVkO1xuICAgIH0sXG4gIH07XG59XG5cbmV4cG9ydCB7IGluamVjdFNwZWVkSW5zaWdodHMsIGNvbXB1dGVSb3V0ZSB9O1xuZXhwb3J0IHR5cGUgeyBTcGVlZEluc2lnaHRzUHJvcHMsIEJlZm9yZVNlbmRNaWRkbGV3YXJlIH07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZGVmYXVsdC1leHBvcnQgLS0gQWxsb3cgZGVmYXVsdCBleHBvcnRcbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5qZWN0U3BlZWRJbnNpZ2h0cyxcbiAgY29tcHV0ZVJvdXRlLFxufTtcbiIsImV4cG9ydCBmdW5jdGlvbiBnZXRCYXNlUGF0aCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAvLyAhISBpbXBvcnRhbnQgISFcbiAgLy8gZG8gbm90IGFjY2VzcyBlbnYgdmFyaWFibGVzIHVzaW5nIHByb2Nlc3MuZW52W3Zhcm5hbWVdXG4gIC8vIHNvbWUgYnVuZGxlcyB3b24ndCByZXBsYWNlIHRoZSB2YWx1ZSBhdCBidWlsZCB0aW1lLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1vcHRpb25hbC1jaGFpbiAtLSB3ZSBjYW4ndCB1c2Ugb3B0aW9ubmFsIGhlcmUsIGl0J2xsIGJyZWFrIGlmIHByb2Nlc3MgZG9lcyBub3QgZXhpc3QuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHByb2Nlc3MuZW52ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHByb2Nlc3MuZW52LlJFQUNUX0FQUF9WRVJDRUxfT0JTRVJWQUJJTElUWV9CQVNFUEFUSDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@vercel/speed-insights/dist/react/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APILoadingStatus: () => (/* binding */ APILoadingStatus),\n/* harmony export */   APIProvider: () => (/* binding */ APIProvider),\n/* harmony export */   APIProviderContext: () => (/* binding */ APIProviderContext),\n/* harmony export */   AdvancedMarker: () => (/* binding */ AdvancedMarker),\n/* harmony export */   AdvancedMarkerAnchorPoint: () => (/* binding */ AdvancedMarkerAnchorPoint),\n/* harmony export */   AdvancedMarkerContext: () => (/* binding */ AdvancedMarkerContext),\n/* harmony export */   CollisionBehavior: () => (/* binding */ CollisionBehavior),\n/* harmony export */   ColorScheme: () => (/* binding */ ColorScheme),\n/* harmony export */   ControlPosition: () => (/* binding */ ControlPosition),\n/* harmony export */   GoogleMapsContext: () => (/* binding */ GoogleMapsContext),\n/* harmony export */   InfoWindow: () => (/* binding */ InfoWindow),\n/* harmony export */   Map: () => (/* binding */ Map),\n/* harmony export */   MapControl: () => (/* binding */ MapControl),\n/* harmony export */   Marker: () => (/* binding */ Marker),\n/* harmony export */   Pin: () => (/* binding */ Pin),\n/* harmony export */   RenderingType: () => (/* binding */ RenderingType),\n/* harmony export */   StaticMap: () => (/* binding */ StaticMap),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   createStaticMapsUrl: () => (/* binding */ createStaticMapsUrl),\n/* harmony export */   isAdvancedMarker: () => (/* binding */ isAdvancedMarker),\n/* harmony export */   isLatLngLiteral: () => (/* binding */ isLatLngLiteral),\n/* harmony export */   latLngEquals: () => (/* binding */ latLngEquals),\n/* harmony export */   limitTiltRange: () => (/* binding */ limitTiltRange),\n/* harmony export */   toLatLngLiteral: () => (/* binding */ toLatLngLiteral),\n/* harmony export */   useAdvancedMarkerRef: () => (/* binding */ useAdvancedMarkerRef),\n/* harmony export */   useApiIsLoaded: () => (/* binding */ useApiIsLoaded),\n/* harmony export */   useApiLoadingStatus: () => (/* binding */ useApiLoadingStatus),\n/* harmony export */   useMap: () => (/* binding */ useMap),\n/* harmony export */   useMapsLibrary: () => (/* binding */ useMapsLibrary),\n/* harmony export */   useMarkerRef: () => (/* binding */ useMarkerRef)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-deep-equal */ \"(app-pages-browser)/./node_modules/fast-deep-equal/index.js\");\n\n\n\n\n// This file is automatically updated by the build process.\nconst VERSION = '1.7.1';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nconst APILoadingStatus = {\n    NOT_LOADED: 'NOT_LOADED',\n    LOADING: 'LOADING',\n    LOADED: 'LOADED',\n    FAILED: 'FAILED',\n    AUTH_FAILURE: 'AUTH_FAILURE'\n};\n\nconst MAPS_API_BASE_URL = 'https://maps.googleapis.com/maps/api/js';\n/**\n * A GoogleMapsApiLoader to reliably load and unload the Google Maps JavaScript API.\n *\n * The actual loading and unloading is delayed into the microtask queue, to\n * allow using the API in an useEffect hook, without worrying about multiple API loads.\n */\nclass GoogleMapsApiLoader {\n    /**\n     * Loads the Maps JavaScript API with the specified parameters.\n     * Since the Maps library can only be loaded once per page, this will\n     * produce a warning when called multiple times with different\n     * parameters.\n     *\n     * The returned promise resolves when loading completes\n     * and rejects in case of an error or when the loading was aborted.\n     */\n    static load(params, onLoadingStatusChange) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            const libraries = params.libraries ? params.libraries.split(',') : [];\n            const serializedParams = this.serializeParams(params);\n            this.listeners.push(onLoadingStatusChange);\n            // Note: if `google.maps.importLibrary` has been defined externally, we\n            //   assume that loading is complete and successful.\n            //   If it was defined by a previous call to this method, a warning\n            //   message is logged if there are differences in api-parameters used\n            //   for both calls.\n            if ((_b = (_a = window.google) === null || _a === void 0 ? void 0 : _a.maps) === null || _b === void 0 ? void 0 : _b.importLibrary) {\n                // no serialized parameters means it was loaded externally\n                if (!this.serializedApiParams) {\n                    this.loadingStatus = APILoadingStatus.LOADED;\n                }\n                this.notifyLoadingStatusListeners();\n            }\n            else {\n                this.serializedApiParams = serializedParams;\n                this.initImportLibrary(params);\n            }\n            if (this.serializedApiParams &&\n                this.serializedApiParams !== serializedParams) {\n                console.warn(`[google-maps-api-loader] The maps API has already been loaded ` +\n                    `with different parameters and will not be loaded again. Refresh the ` +\n                    `page for new values to have effect.`);\n            }\n            const librariesToLoad = ['maps', ...libraries];\n            yield Promise.all(librariesToLoad.map(name => google.maps.importLibrary(name)));\n        });\n    }\n    /**\n     * Serialize the parameters used to load the library for easier comparison.\n     */\n    static serializeParams(params) {\n        return [\n            params.v,\n            params.key,\n            params.language,\n            params.region,\n            params.authReferrerPolicy,\n            params.solutionChannel\n        ].join('/');\n    }\n    /**\n     * Creates the global `google.maps.importLibrary` function for bootstrapping.\n     * This is essentially a formatted version of the dynamic loading script\n     * from the official documentation with some minor adjustments.\n     *\n     * The created importLibrary function will load the Google Maps JavaScript API,\n     * which will then replace the `google.maps.importLibrary` function with the full\n     * implementation.\n     *\n     * @see https://developers.google.com/maps/documentation/javascript/load-maps-js-api#dynamic-library-import\n     */\n    static initImportLibrary(params) {\n        if (!window.google)\n            window.google = {};\n        if (!window.google.maps)\n            window.google.maps = {};\n        if (window.google.maps['importLibrary']) {\n            console.error('[google-maps-api-loader-internal]: initImportLibrary must only be called once');\n            return;\n        }\n        let apiPromise = null;\n        const loadApi = () => {\n            if (apiPromise)\n                return apiPromise;\n            apiPromise = new Promise((resolve, reject) => {\n                var _a;\n                const scriptElement = document.createElement('script');\n                const urlParams = new URLSearchParams();\n                for (const [key, value] of Object.entries(params)) {\n                    const urlParamName = key.replace(/[A-Z]/g, t => '_' + t[0].toLowerCase());\n                    urlParams.set(urlParamName, String(value));\n                }\n                urlParams.set('loading', 'async');\n                urlParams.set('callback', '__googleMapsCallback__');\n                scriptElement.async = true;\n                scriptElement.src = MAPS_API_BASE_URL + `?` + urlParams.toString();\n                scriptElement.nonce =\n                    ((_a = document.querySelector('script[nonce]')) === null || _a === void 0 ? void 0 : _a.nonce) || '';\n                scriptElement.onerror = () => {\n                    this.loadingStatus = APILoadingStatus.FAILED;\n                    this.notifyLoadingStatusListeners();\n                    reject(new Error('The Google Maps JavaScript API could not load.'));\n                };\n                window.__googleMapsCallback__ = () => {\n                    this.loadingStatus = APILoadingStatus.LOADED;\n                    this.notifyLoadingStatusListeners();\n                    resolve();\n                };\n                window.gm_authFailure = () => {\n                    this.loadingStatus = APILoadingStatus.AUTH_FAILURE;\n                    this.notifyLoadingStatusListeners();\n                };\n                this.loadingStatus = APILoadingStatus.LOADING;\n                this.notifyLoadingStatusListeners();\n                document.head.append(scriptElement);\n            });\n            return apiPromise;\n        };\n        // for the first load, we declare an importLibrary function that will\n        // be overwritten once the api is loaded.\n        google.maps.importLibrary = libraryName => loadApi().then(() => google.maps.importLibrary(libraryName));\n    }\n    /**\n     * Calls all registered loadingStatusListeners after a status update.\n     */\n    static notifyLoadingStatusListeners() {\n        for (const fn of this.listeners) {\n            fn(this.loadingStatus);\n        }\n    }\n}\n/**\n * The current loadingStatus of the API.\n */\nGoogleMapsApiLoader.loadingStatus = APILoadingStatus.NOT_LOADED;\n/**\n * A list of functions to be notified when the loading status changes.\n */\nGoogleMapsApiLoader.listeners = [];\n\nconst DEFAULT_SOLUTION_CHANNEL = 'GMP_visgl_rgmlibrary_v1_default';\nconst DEFAULT_INTERNAL_USAGE_ATTRIBUTION_IDS = [\n    `gmp_visgl_reactgooglemaps_v${VERSION}`\n];\nconst APIProviderContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * local hook to set up the map-instance management context.\n */\nfunction useMapInstances() {\n    const [mapInstances, setMapInstances] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const addMapInstance = (mapInstance, id = 'default') => {\n        setMapInstances(instances => (Object.assign(Object.assign({}, instances), { [id]: mapInstance })));\n    };\n    const removeMapInstance = (id = 'default') => {\n        setMapInstances((_a) => {\n            var _b = id; _a[_b]; var remaining = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n            return remaining;\n        });\n    };\n    const clearMapInstances = () => {\n        setMapInstances({});\n    };\n    return { mapInstances, addMapInstance, removeMapInstance, clearMapInstances };\n}\n/**\n * local hook to handle the loading of the maps API, returns the current loading status\n * @param props\n */\nfunction useGoogleMapsApiLoader(props) {\n    const { onLoad, onError, apiKey, version, libraries = [] } = props, otherApiParams = __rest(props, [\"onLoad\", \"onError\", \"apiKey\", \"version\", \"libraries\"]);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(GoogleMapsApiLoader.loadingStatus);\n    const [loadedLibraries, addLoadedLibrary] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((loadedLibraries, action) => {\n        return loadedLibraries[action.name]\n            ? loadedLibraries\n            : Object.assign(Object.assign({}, loadedLibraries), { [action.name]: action.value });\n    }, {});\n    const librariesString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => libraries === null || libraries === void 0 ? void 0 : libraries.join(','), [libraries]);\n    const serializedParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => JSON.stringify(Object.assign({ apiKey, version }, otherApiParams)), [apiKey, version, otherApiParams]);\n    const importLibrary = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name) => __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        if (loadedLibraries[name]) {\n            return loadedLibraries[name];\n        }\n        if (!((_a = google === null || google === void 0 ? void 0 : google.maps) === null || _a === void 0 ? void 0 : _a.importLibrary)) {\n            throw new Error('[api-provider-internal] importLibrary was called before ' +\n                'google.maps.importLibrary was defined.');\n        }\n        const res = yield window.google.maps.importLibrary(name);\n        addLoadedLibrary({ name, value: res });\n        return res;\n    }), [loadedLibraries]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        (() => __awaiter(this, void 0, void 0, function* () {\n            try {\n                const params = Object.assign({ key: apiKey }, otherApiParams);\n                if (version)\n                    params.v = version;\n                if ((librariesString === null || librariesString === void 0 ? void 0 : librariesString.length) > 0)\n                    params.libraries = librariesString;\n                if (params.channel === undefined ||\n                    params.channel < 0 ||\n                    params.channel > 999)\n                    delete params.channel;\n                if (params.solutionChannel === undefined)\n                    params.solutionChannel = DEFAULT_SOLUTION_CHANNEL;\n                else if (params.solutionChannel === '')\n                    delete params.solutionChannel;\n                yield GoogleMapsApiLoader.load(params, status => setStatus(status));\n                for (const name of ['core', 'maps', ...libraries]) {\n                    yield importLibrary(name);\n                }\n                if (onLoad) {\n                    onLoad();\n                }\n            }\n            catch (error) {\n                if (onError) {\n                    onError(error);\n                }\n                else {\n                    console.error('<ApiProvider> failed to load the Google Maps JavaScript API', error);\n                }\n            }\n        }))();\n    }, \n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [apiKey, librariesString, serializedParams]);\n    return {\n        status,\n        loadedLibraries,\n        importLibrary\n    };\n}\nfunction useInternalUsageAttributionIds(props) {\n    const internalUsageAttributionIds = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => props.disableUsageAttribution\n        ? null\n        : DEFAULT_INTERNAL_USAGE_ATTRIBUTION_IDS, [props.disableUsageAttribution]);\n    return internalUsageAttributionIds;\n}\n/**\n * Component to wrap the components from this library and load the Google Maps JavaScript API\n */\nconst APIProvider = props => {\n    const { children } = props, loaderProps = __rest(props, [\"children\"]);\n    const { mapInstances, addMapInstance, removeMapInstance, clearMapInstances } = useMapInstances();\n    const { status, loadedLibraries, importLibrary } = useGoogleMapsApiLoader(loaderProps);\n    const internalUsageAttributionIds = useInternalUsageAttributionIds(loaderProps);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n        mapInstances,\n        addMapInstance,\n        removeMapInstance,\n        clearMapInstances,\n        status,\n        loadedLibraries,\n        importLibrary,\n        internalUsageAttributionIds\n    }), [\n        mapInstances,\n        addMapInstance,\n        removeMapInstance,\n        clearMapInstances,\n        status,\n        loadedLibraries,\n        importLibrary,\n        internalUsageAttributionIds\n    ]);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(APIProviderContext.Provider, { value: contextValue }, children));\n};\n\n/**\n * Sets up effects to bind event-handlers for all event-props in MapEventProps.\n * @internal\n */\nfunction useMapEvents(map, props) {\n    // note: calling a useEffect hook from within a loop is prohibited by the\n    // rules of hooks, but it's ok here since it's unconditional and the number\n    // and order of iterations is always strictly the same.\n    // (see https://legacy.reactjs.org/docs/hooks-rules.html)\n    for (const propName of eventPropNames) {\n        // fixme: this cast is essentially a 'trust me, bro' for typescript, but\n        //   a proper solution seems way too complicated right now\n        const handler = props[propName];\n        const eventType = propNameToEventType[propName];\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n            if (!map)\n                return;\n            if (!handler)\n                return;\n            const listener = google.maps.event.addListener(map, eventType, (ev) => {\n                handler(createMapEvent(eventType, map, ev));\n            });\n            return () => listener.remove();\n        }, [map, eventType, handler]);\n    }\n}\n/**\n * Create the wrapped map-events used for the event-props.\n * @param type the event type as it is specified to the maps api\n * @param map the map instance the event originates from\n * @param srcEvent the source-event if there is one.\n */\nfunction createMapEvent(type, map, srcEvent) {\n    var _a;\n    const ev = {\n        type,\n        map,\n        detail: {},\n        stoppable: false,\n        stop: () => { }\n    };\n    if (cameraEventTypes.includes(type)) {\n        const camEvent = ev;\n        const center = map.getCenter();\n        const zoom = map.getZoom();\n        const heading = map.getHeading() || 0;\n        const tilt = map.getTilt() || 0;\n        const bounds = map.getBounds();\n        if (!center || !bounds || !Number.isFinite(zoom)) {\n            console.warn('[createEvent] at least one of the values from the map ' +\n                'returned undefined. This is not expected to happen. Please ' +\n                'report an issue at https://github.com/visgl/react-google-maps/issues/new');\n        }\n        camEvent.detail = {\n            center: (center === null || center === void 0 ? void 0 : center.toJSON()) || { lat: 0, lng: 0 },\n            zoom: zoom || 0,\n            heading: heading,\n            tilt: tilt,\n            bounds: (bounds === null || bounds === void 0 ? void 0 : bounds.toJSON()) || {\n                north: 90,\n                east: 180,\n                south: -90,\n                west: -180\n            }\n        };\n        return camEvent;\n    }\n    else if (mouseEventTypes.includes(type)) {\n        if (!srcEvent)\n            throw new Error('[createEvent] mouse events must provide a srcEvent');\n        const mouseEvent = ev;\n        mouseEvent.domEvent = srcEvent.domEvent;\n        mouseEvent.stoppable = true;\n        mouseEvent.stop = () => srcEvent.stop();\n        mouseEvent.detail = {\n            latLng: ((_a = srcEvent.latLng) === null || _a === void 0 ? void 0 : _a.toJSON()) || null,\n            placeId: srcEvent.placeId\n        };\n        return mouseEvent;\n    }\n    return ev;\n}\n/**\n * maps the camelCased names of event-props to the corresponding event-types\n * used in the maps API.\n */\nconst propNameToEventType = {\n    onBoundsChanged: 'bounds_changed',\n    onCenterChanged: 'center_changed',\n    onClick: 'click',\n    onContextmenu: 'contextmenu',\n    onDblclick: 'dblclick',\n    onDrag: 'drag',\n    onDragend: 'dragend',\n    onDragstart: 'dragstart',\n    onHeadingChanged: 'heading_changed',\n    onIdle: 'idle',\n    onIsFractionalZoomEnabledChanged: 'isfractionalzoomenabled_changed',\n    onMapCapabilitiesChanged: 'mapcapabilities_changed',\n    onMapTypeIdChanged: 'maptypeid_changed',\n    onMousemove: 'mousemove',\n    onMouseout: 'mouseout',\n    onMouseover: 'mouseover',\n    onProjectionChanged: 'projection_changed',\n    onRenderingTypeChanged: 'renderingtype_changed',\n    onTilesLoaded: 'tilesloaded',\n    onTiltChanged: 'tilt_changed',\n    onZoomChanged: 'zoom_changed',\n    // note: onCameraChanged is an alias for the bounds_changed event,\n    // since that is going to be fired in every situation where the camera is\n    // updated.\n    onCameraChanged: 'bounds_changed'\n};\nconst cameraEventTypes = [\n    'bounds_changed',\n    'center_changed',\n    'heading_changed',\n    'tilt_changed',\n    'zoom_changed'\n];\nconst mouseEventTypes = [\n    'click',\n    'contextmenu',\n    'dblclick',\n    'mousemove',\n    'mouseout',\n    'mouseover'\n];\nconst eventPropNames = Object.keys(propNameToEventType);\n\n/**\n * A hook to store the previous value of a variable.\n * @param value The value to store\n * @returns The previous value\n */\nfunction usePrevious(value) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        ref.current = value;\n    });\n    // eslint-disable-next-line react-hooks/refs\n    return ref.current;\n}\n\nfunction useMemoized(value, isEqual) {\n    const previous = usePrevious(value);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if (previous && isEqual(previous, value)) {\n            return previous;\n        }\n        return value;\n    }, [value, previous, isEqual]);\n}\n\nfunction useCustomCompareEffect(effect, dependencies, isEqual) {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(effect, [useMemoized(dependencies, isEqual)]);\n}\n\nfunction useDeepCompareEffect(effect, dependencies) {\n    useCustomCompareEffect(effect, dependencies, fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__);\n}\n\nconst mapOptionKeys = new Set([\n    'backgroundColor',\n    'clickableIcons',\n    'controlSize',\n    'disableDefaultUI',\n    'disableDoubleClickZoom',\n    'draggable',\n    'draggableCursor',\n    'draggingCursor',\n    'fullscreenControl',\n    'fullscreenControlOptions',\n    'gestureHandling',\n    'headingInteractionEnabled',\n    'isFractionalZoomEnabled',\n    'keyboardShortcuts',\n    'mapTypeControl',\n    'mapTypeControlOptions',\n    'mapTypeId',\n    'maxZoom',\n    'minZoom',\n    'noClear',\n    'panControl',\n    'panControlOptions',\n    'restriction',\n    'rotateControl',\n    'rotateControlOptions',\n    'scaleControl',\n    'scaleControlOptions',\n    'scrollwheel',\n    'streetView',\n    'streetViewControl',\n    'streetViewControlOptions',\n    'styles',\n    'tiltInteractionEnabled',\n    'zoomControl',\n    'zoomControlOptions'\n]);\n/**\n * Internal hook to update the map-options when props are changed.\n *\n * @param map the map instance\n * @param mapProps the props to update the map-instance with\n * @internal\n */\nfunction useMapOptions(map, mapProps) {\n    /* eslint-disable react-hooks/exhaustive-deps --\n     *\n     * The following effects aren't triggered when the map is changed.\n     * In that case, the values will be or have been passed to the map\n     * constructor via mapOptions.\n     */\n    const mapOptions = {};\n    const keys = Object.keys(mapProps);\n    for (const key of keys) {\n        if (!mapOptionKeys.has(key))\n            continue;\n        mapOptions[key] = mapProps[key];\n    }\n    // update the map options when mapOptions is changed\n    // Note: due to the destructuring above, mapOptions will be seen as changed\n    //   with every re-render, so we're assuming the maps-api will properly\n    //   deal with unchanged option-values passed into setOptions.\n    useDeepCompareEffect(() => {\n        if (!map)\n            return;\n        map.setOptions(mapOptions);\n    }, [mapOptions]);\n    /* eslint-enable react-hooks/exhaustive-deps */\n}\n\nfunction useApiLoadingStatus() {\n    var _a;\n    return ((_a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext)) === null || _a === void 0 ? void 0 : _a.status) || APILoadingStatus.NOT_LOADED;\n}\n\n/**\n * Internal hook that updates the camera when deck.gl viewState changes.\n * @internal\n */\nfunction useDeckGLCameraUpdate(map, props) {\n    const { viewport, viewState } = props;\n    const isDeckGlControlled = !!viewport;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        if (!map || !viewState)\n            return;\n        const { latitude, longitude, bearing: heading, pitch: tilt, zoom } = viewState;\n        map.moveCamera({\n            center: { lat: latitude, lng: longitude },\n            heading,\n            tilt,\n            zoom: zoom + 1\n        });\n    }, [map, viewState]);\n    return isDeckGlControlled;\n}\n\nfunction isLatLngLiteral(obj) {\n    if (!obj || typeof obj !== 'object')\n        return false;\n    if (!('lat' in obj && 'lng' in obj))\n        return false;\n    return Number.isFinite(obj.lat) && Number.isFinite(obj.lng);\n}\nfunction latLngEquals(a, b) {\n    if (!a || !b)\n        return false;\n    const A = toLatLngLiteral(a);\n    const B = toLatLngLiteral(b);\n    if (A.lat !== B.lat || A.lng !== B.lng)\n        return false;\n    return true;\n}\nfunction toLatLngLiteral(obj) {\n    if (isLatLngLiteral(obj))\n        return obj;\n    return obj.toJSON();\n}\n\nfunction useMapCameraParams(map, cameraStateRef, mapProps) {\n    const center = mapProps.center ? toLatLngLiteral(mapProps.center) : null;\n    let lat = null;\n    let lng = null;\n    if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n        lat = center.lat;\n        lng = center.lng;\n    }\n    const zoom = Number.isFinite(mapProps.zoom)\n        ? mapProps.zoom\n        : null;\n    const heading = Number.isFinite(mapProps.heading)\n        ? mapProps.heading\n        : null;\n    const tilt = Number.isFinite(mapProps.tilt)\n        ? mapProps.tilt\n        : null;\n    // the following effect runs for every render of the map component and checks\n    // if there are differences between the known state of the map instance\n    // (cameraStateRef, which is updated by all bounds_changed events) and the\n    // desired state in the props.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        if (!map)\n            return;\n        const nextCamera = {};\n        let needsUpdate = false;\n        if (lat !== null &&\n            lng !== null &&\n            (cameraStateRef.current.center.lat !== lat ||\n                cameraStateRef.current.center.lng !== lng)) {\n            nextCamera.center = { lat, lng };\n            needsUpdate = true;\n        }\n        if (zoom !== null && cameraStateRef.current.zoom !== zoom) {\n            nextCamera.zoom = zoom;\n            needsUpdate = true;\n        }\n        if (heading !== null && cameraStateRef.current.heading !== heading) {\n            nextCamera.heading = heading;\n            needsUpdate = true;\n        }\n        if (tilt !== null && cameraStateRef.current.tilt !== tilt) {\n            nextCamera.tilt = tilt;\n            needsUpdate = true;\n        }\n        if (needsUpdate) {\n            map.moveCamera(nextCamera);\n        }\n    });\n}\n\nconst AuthFailureMessage = () => {\n    const style = {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0,\n        zIndex: 999,\n        display: 'flex',\n        flexFlow: 'column nowrap',\n        textAlign: 'center',\n        justifyContent: 'center',\n        fontSize: '.8rem',\n        color: 'rgba(0,0,0,0.6)',\n        background: '#dddddd',\n        padding: '1rem 1.5rem'\n    };\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: style },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Error: AuthFailure\"),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null,\n            \"A problem with your API key prevents the map from rendering correctly. Please make sure the value of the \",\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", null, \"APIProvider.apiKey\"),\n            \" prop is correct. Check the error-message in the console for further details.\")));\n};\n\nfunction useCallbackRef() {\n    const [el, setEl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value) => setEl(value), [setEl]);\n    return [el, ref];\n}\n\n/**\n * Hook to check if the Maps JavaScript API is loaded\n */\nfunction useApiIsLoaded() {\n    const status = useApiLoadingStatus();\n    return status === APILoadingStatus.LOADED;\n}\n\nfunction useForceUpdate() {\n    const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(x => x + 1, 0);\n    return forceUpdate;\n}\n\nfunction handleBoundsChange(map, ref) {\n    const center = map.getCenter();\n    const zoom = map.getZoom();\n    const heading = map.getHeading() || 0;\n    const tilt = map.getTilt() || 0;\n    const bounds = map.getBounds();\n    if (!center || !bounds || !Number.isFinite(zoom)) {\n        console.warn('[useTrackedCameraState] at least one of the values from the map ' +\n            'returned undefined. This is not expected to happen. Please ' +\n            'report an issue at https://github.com/visgl/react-google-maps/issues/new');\n    }\n    // fixme: do we need the `undefined` cases for the camera-params? When are they used in the maps API?\n    Object.assign(ref.current, {\n        center: (center === null || center === void 0 ? void 0 : center.toJSON()) || { lat: 0, lng: 0 },\n        zoom: zoom || 0,\n        heading: heading,\n        tilt: tilt\n    });\n}\n/**\n * Creates a mutable ref object to track the last known state of the map camera.\n * This is used in `useMapCameraParams` to reduce stuttering in normal operation\n * by avoiding updates of the map camera with values that have already been processed.\n */\nfunction useTrackedCameraStateRef(map) {\n    const forceUpdate = useForceUpdate();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        center: { lat: 0, lng: 0 },\n        heading: 0,\n        tilt: 0,\n        zoom: 0\n    });\n    // Record camera state with every bounds_changed event dispatched by the map.\n    // This data is used to prevent feeding these values back to the\n    // map-instance when a typical \"controlled component\" setup (state variable is\n    // fed into and updated by the map).\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!map)\n            return;\n        const listener = google.maps.event.addListener(map, 'bounds_changed', () => {\n            handleBoundsChange(map, ref);\n            // When an event is occured, we have to update during the next cycle.\n            // The application could decide to ignore the event and not update any\n            // camera props of the map, meaning that in that case we will have to\n            // 'undo' the change to the camera.\n            forceUpdate();\n        });\n        return () => listener.remove();\n    }, [map, forceUpdate]);\n    return ref;\n}\n\n/**\n * Stores a stack of map-instances for each mapId. Whenever an\n * instance is used, it is removed from the stack while in use,\n * and returned to the stack when the component unmounts.\n * This allows us to correctly implement caching for multiple\n * maps om the same page, while reusing as much as possible.\n *\n * FIXME: while it should in theory be possible to reuse maps solely\n *   based on the mapId (as all other parameters can be changed at\n *   runtime), we don't yet have good enough tracking of options to\n *   reliably unset all the options that have been set.\n */\nclass CachedMapStack {\n    static has(key) {\n        return this.entries[key] && this.entries[key].length > 0;\n    }\n    static pop(key) {\n        if (!this.entries[key])\n            return null;\n        return this.entries[key].pop() || null;\n    }\n    static push(key, value) {\n        if (!this.entries[key])\n            this.entries[key] = [];\n        this.entries[key].push(value);\n    }\n}\nCachedMapStack.entries = {};\n/**\n * The main hook takes care of creating map-instances and registering them in\n * the api-provider context.\n * @return a tuple of the map-instance created (or null) and the callback\n *   ref that will be used to pass the map-container into this hook.\n * @internal\n */\nfunction useMapInstance(props, context) {\n    const apiIsLoaded = useApiIsLoaded();\n    const [map, setMap] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [container, containerRef] = useCallbackRef();\n    const cameraStateRef = useTrackedCameraStateRef(map);\n    const { id, defaultBounds, defaultCenter, defaultZoom, defaultHeading, defaultTilt, reuseMaps, renderingType, colorScheme } = props, mapOptions = __rest(props, [\"id\", \"defaultBounds\", \"defaultCenter\", \"defaultZoom\", \"defaultHeading\", \"defaultTilt\", \"reuseMaps\", \"renderingType\", \"colorScheme\"]);\n    const hasZoom = props.zoom !== undefined || props.defaultZoom !== undefined;\n    const hasCenter = props.center !== undefined || props.defaultCenter !== undefined;\n    if (!defaultBounds && (!hasZoom || !hasCenter)) {\n        console.warn('<Map> component is missing configuration. ' +\n            'You have to provide zoom and center (via the `zoom`/`defaultZoom` and ' +\n            '`center`/`defaultCenter` props) or specify the region to show using ' +\n            '`defaultBounds`. See ' +\n            'https://visgl.github.io/react-google-maps/docs/api-reference/components/map#required');\n    }\n    // apply default camera props if available and not overwritten by controlled props\n    if (!mapOptions.center && defaultCenter)\n        mapOptions.center = defaultCenter;\n    if (!mapOptions.zoom && Number.isFinite(defaultZoom))\n        mapOptions.zoom = defaultZoom;\n    if (!mapOptions.heading && Number.isFinite(defaultHeading))\n        mapOptions.heading = defaultHeading;\n    if (!mapOptions.tilt && Number.isFinite(defaultTilt))\n        mapOptions.tilt = defaultTilt;\n    // Handle internalUsageAttributionIds\n    const customIds = mapOptions.internalUsageAttributionIds;\n    if (customIds == null) {\n        // Not specified - use context default (which may be null if disabled)\n        mapOptions.internalUsageAttributionIds =\n            context.internalUsageAttributionIds;\n    }\n    else {\n        // Merge context defaults with custom IDs\n        mapOptions.internalUsageAttributionIds = [\n            ...(context.internalUsageAttributionIds || []),\n            ...customIds\n        ];\n    }\n    for (const key of Object.keys(mapOptions))\n        if (mapOptions[key] === undefined)\n            delete mapOptions[key];\n    const savedMapStateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    // create the map instance and register it in the context\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!container || !apiIsLoaded)\n            return;\n        const { addMapInstance, removeMapInstance } = context;\n        // note: colorScheme (upcoming feature) isn't yet in the typings, remove once that is fixed:\n        const { mapId } = props;\n        const cacheKey = `${mapId || 'default'}:${renderingType || 'default'}:${colorScheme || 'LIGHT'}`;\n        let mapDiv;\n        let map;\n        if (reuseMaps && CachedMapStack.has(cacheKey)) {\n            map = CachedMapStack.pop(cacheKey);\n            mapDiv = map.getDiv();\n            container.appendChild(mapDiv);\n            map.setOptions(mapOptions);\n            // detaching the element from the DOM lets the map fall back to its default\n            // size, setting the center will trigger reloading the map.\n            setTimeout(() => map.setCenter(map.getCenter()), 0);\n        }\n        else {\n            mapDiv = document.createElement('div');\n            mapDiv.style.height = '100%';\n            container.appendChild(mapDiv);\n            map = new google.maps.Map(mapDiv, Object.assign(Object.assign(Object.assign({}, mapOptions), (renderingType\n                ? { renderingType: renderingType }\n                : {})), (colorScheme\n                ? { colorScheme: colorScheme }\n                : {})));\n        }\n        setMap(map);\n        addMapInstance(map, id);\n        if (defaultBounds) {\n            const { padding } = defaultBounds, defBounds = __rest(defaultBounds, [\"padding\"]);\n            map.fitBounds(defBounds, padding);\n        }\n        // prevent map not rendering due to missing configuration\n        else if (!hasZoom || !hasCenter) {\n            map.fitBounds({ east: 180, west: -180, south: -90, north: 90 });\n        }\n        // the savedMapState is used to restore the camera parameters when the mapId is changed\n        if (savedMapStateRef.current) {\n            const { mapId: savedMapId, cameraState: savedCameraState } = savedMapStateRef.current;\n            if (savedMapId !== mapId) {\n                map.setOptions(savedCameraState);\n            }\n        }\n        return () => {\n            savedMapStateRef.current = {\n                mapId,\n                // eslint-disable-next-line react-hooks/exhaustive-deps\n                cameraState: cameraStateRef.current\n            };\n            // detach the map-div from the dom\n            mapDiv.remove();\n            if (reuseMaps) {\n                // push back on the stack\n                CachedMapStack.push(cacheKey, map);\n            }\n            else {\n                // remove all event-listeners to minimize the possibility of memory-leaks\n                google.maps.event.clearInstanceListeners(map);\n            }\n            setMap(null);\n            removeMapInstance(id);\n        };\n    }, \n    // some dependencies are ignored in the list below:\n    //  - defaultBounds and the default* camera props will only be used once, and\n    //    changes should be ignored\n    //  - mapOptions has special hooks that take care of updating the options\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        container,\n        apiIsLoaded,\n        id,\n        // these props can't be changed after initialization and require a new\n        // instance to be created\n        props.mapId,\n        props.renderingType,\n        props.colorScheme\n    ]);\n    return [map, containerRef, cameraStateRef];\n}\n\nconst GoogleMapsContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n// ColorScheme and RenderingType are redefined here to make them usable before the\n// maps API has been fully loaded.\nconst ColorScheme = {\n    DARK: 'DARK',\n    LIGHT: 'LIGHT',\n    FOLLOW_SYSTEM: 'FOLLOW_SYSTEM'\n};\nconst RenderingType = {\n    VECTOR: 'VECTOR',\n    RASTER: 'RASTER',\n    UNINITIALIZED: 'UNINITIALIZED'\n};\nconst Map = (props) => {\n    const { children, id, className, style } = props;\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    const loadingStatus = useApiLoadingStatus();\n    if (!context) {\n        throw new Error('<Map> can only be used inside an <ApiProvider> component.');\n    }\n    const [map, mapRef, cameraStateRef] = useMapInstance(props, context);\n    useMapCameraParams(map, cameraStateRef, props);\n    useMapEvents(map, props);\n    useMapOptions(map, props);\n    const isDeckGlControlled = useDeckGLCameraUpdate(map, props);\n    const isControlledExternally = !!props.controlled;\n    // disable interactions with the map for externally controlled maps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!map)\n            return;\n        // fixme: this doesn't seem to belong here (and it's mostly there for convenience anyway).\n        //   The reasoning is that a deck.gl canvas will be put on top of the map, rendering\n        //   any default map controls pretty much useless\n        if (isDeckGlControlled) {\n            map.setOptions({ disableDefaultUI: true });\n        }\n        // disable all control-inputs when the map is controlled externally\n        if (isDeckGlControlled || isControlledExternally) {\n            map.setOptions({\n                gestureHandling: 'none',\n                keyboardShortcuts: false\n            });\n        }\n        return () => {\n            map.setOptions({\n                gestureHandling: props.gestureHandling,\n                keyboardShortcuts: props.keyboardShortcuts\n            });\n        };\n    }, [\n        map,\n        isDeckGlControlled,\n        isControlledExternally,\n        props.gestureHandling,\n        props.keyboardShortcuts\n    ]);\n    // setup a stable cameraOptions object that can be used as dependency\n    const center = props.center ? toLatLngLiteral(props.center) : null;\n    let lat = null;\n    let lng = null;\n    if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n        lat = center.lat;\n        lng = center.lng;\n    }\n    const cameraOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        var _a, _b, _c;\n        return {\n            center: { lat: lat !== null && lat !== void 0 ? lat : 0, lng: lng !== null && lng !== void 0 ? lng : 0 },\n            zoom: (_a = props.zoom) !== null && _a !== void 0 ? _a : 0,\n            heading: (_b = props.heading) !== null && _b !== void 0 ? _b : 0,\n            tilt: (_c = props.tilt) !== null && _c !== void 0 ? _c : 0\n        };\n    }, [lat, lng, props.zoom, props.heading, props.tilt]);\n    // externally controlled mode: reject all camera changes that don't correspond to changes in props\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        if (!map || !isControlledExternally)\n            return;\n        map.moveCamera(cameraOptions);\n        const listener = map.addListener('bounds_changed', () => {\n            map.moveCamera(cameraOptions);\n        });\n        return () => listener.remove();\n    }, [map, isControlledExternally, cameraOptions]);\n    const combinedStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (Object.assign({ width: '100%', height: '100%', position: 'relative', \n        // when using deckgl, the map should be sent to the back\n        zIndex: isDeckGlControlled ? -1 : 0 }, style)), [style, isDeckGlControlled]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({ map }), [map]);\n    if (loadingStatus === APILoadingStatus.AUTH_FAILURE) {\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: Object.assign({ position: 'relative' }, (className ? {} : combinedStyle)), className: className },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(AuthFailureMessage, null)));\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Object.assign({ ref: mapRef, \"data-testid\": 'map', style: className ? undefined : combinedStyle, className: className }, (id ? { id } : {})), map ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleMapsContext.Provider, { value: contextValue }, children)) : null));\n};\n// The deckGLViewProps flag here indicates to deck.gl that the Map component is\n// able to handle viewProps from deck.gl when deck.gl is used to control the map.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nMap.deckGLViewProps = true;\n\nconst shownMessages = new Set();\nfunction logErrorOnce(...args) {\n    const key = JSON.stringify(args);\n    if (!shownMessages.has(key)) {\n        shownMessages.add(key);\n        console.error(...args);\n    }\n}\n\n/**\n * Retrieves a map-instance from the context. This is either an instance\n * identified by id or the parent map instance if no id is specified.\n * Returns null if neither can be found.\n */\nconst useMap = (id = null) => {\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    const { map } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext) || {};\n    if (ctx === null) {\n        logErrorOnce('useMap(): failed to retrieve APIProviderContext. ' +\n            'Make sure that the <APIProvider> component exists and that the ' +\n            'component you are calling `useMap()` from is a sibling of the ' +\n            '<APIProvider>.');\n        return null;\n    }\n    const { mapInstances } = ctx;\n    // if an id is specified, the corresponding map or null is returned\n    if (id !== null)\n        return mapInstances[id] || null;\n    // otherwise, return the closest ancestor\n    if (map)\n        return map;\n    // finally, return the default map instance\n    return mapInstances['default'] || null;\n};\n\nfunction useMapsLibrary(name) {\n    const apiIsLoaded = useApiIsLoaded();\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!apiIsLoaded || !ctx)\n            return;\n        // Trigger loading the libraries via our proxy-method.\n        // The returned promise is ignored, since importLibrary will update loadedLibraries\n        // list in the context, triggering a re-render.\n        void ctx.importLibrary(name);\n    }, [apiIsLoaded, ctx, name]);\n    return (ctx === null || ctx === void 0 ? void 0 : ctx.loadedLibraries[name]) || null;\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Internally used to bind events to Maps JavaScript API objects.\n * @internal\n */\nfunction useMapsEventListener(target, name, callback) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!target || !name || !callback)\n            return;\n        const listener = google.maps.event.addListener(target, name, callback);\n        return () => listener.remove();\n    }, [target, name, callback]);\n}\n\n/**\n * Internally used to copy values from props into API-Objects\n * whenever they change.\n *\n * @example\n *   usePropBinding(marker, 'position', position);\n *\n * @internal\n */\nfunction usePropBinding(object, prop, value) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!object)\n            return;\n        // eslint-disable-next-line react-hooks/immutability\n        object[prop] = value;\n    }, [object, prop, value]);\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Internally used to bind events to DOM nodes.\n * @internal\n */\nfunction useDomEventListener(target, name, callback) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!target || !name || !callback)\n            return;\n        target.addEventListener(name, callback);\n        return () => target.removeEventListener(name, callback);\n    }, [target, name, callback]);\n}\n\n// Global style manager to track rendered styles and avoid duplicates\nclass GlobalStyleManager {\n    constructor() {\n        this.renderedStyles = new Set();\n        this.styleElement = null;\n    }\n    getStyleElement() {\n        if (!this.styleElement) {\n            this.styleElement = document.createElement('style');\n            this.styleElement.setAttribute('data-rgm-anchor-styles', '');\n            document.head.appendChild(this.styleElement);\n        }\n        return this.styleElement;\n    }\n    addAdvancedMarkerPointerEventsOverwrite() {\n        if (this.renderedStyles.has('marker-pointer-events')) {\n            return;\n        }\n        const styleElement = this.getStyleElement();\n        styleElement.textContent += `\n      gmp-advanced-marker[data-origin='rgm'] {\n        pointer-events: none !important;\n      }\n    `;\n        this.renderedStyles.add('marker-pointer-events');\n    }\n    cleanup() {\n        if (this.styleElement) {\n            this.styleElement.remove();\n            this.styleElement = null;\n            this.renderedStyles.clear();\n        }\n    }\n}\nconst globalStyleManager = new GlobalStyleManager();\n\nfunction isVersionGreaterEqual(major, minor) {\n    var _a;\n    if (!((_a = google === null || google === void 0 ? void 0 : google.maps) === null || _a === void 0 ? void 0 : _a.version))\n        return undefined;\n    const version = google.maps.version.split('.');\n    const currentMajor = parseInt(version[0], 10);\n    const currentMinor = parseInt(version[1], 10);\n    return (currentMajor > major || (currentMajor === major && currentMinor >= minor));\n}\n\n/* eslint-disable react-hooks/immutability */\n// The `react-hooks/immutability` rule is disabled in this file because the\n// google.maps.marker.AdvancedMarkerElement object is designed to be mutated\n// directly. This is a common pattern when working with imperative APIs like\n// the Google Maps JavaScript API. While this goes against the principles of\n// immutable state in React, it is a necessary evil to integrate with the\n// Google Maps API. The mutations are carefully managed within the `useEffect`\n// hooks to ensure that they only happen when the props change.\n/**\n * Copy of the `google.maps.CollisionBehavior` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */\nconst CollisionBehavior = {\n    REQUIRED: 'REQUIRED',\n    REQUIRED_AND_HIDES_OPTIONAL: 'REQUIRED_AND_HIDES_OPTIONAL',\n    OPTIONAL_AND_HIDES_LOWER_PRIORITY: 'OPTIONAL_AND_HIDES_LOWER_PRIORITY'\n};\nconst AdvancedMarkerContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n// [xPosition, yPosition] when the top left corner is [0, 0]\n/**\n * @deprecated Using `anchorPosition` is deprecated.\n *   Use `anchorLeft` and `anchorTop` instead.\n */\nconst AdvancedMarkerAnchorPoint = {\n    TOP_LEFT: ['0%', '0%'],\n    TOP_CENTER: ['50%', '0%'],\n    TOP: ['50%', '0%'],\n    TOP_RIGHT: ['100%', '0%'],\n    LEFT_CENTER: ['0%', '50%'],\n    LEFT_TOP: ['0%', '0%'],\n    LEFT: ['0%', '50%'],\n    LEFT_BOTTOM: ['0%', '100%'],\n    RIGHT_TOP: ['100%', '0%'],\n    RIGHT: ['100%', '50%'],\n    RIGHT_CENTER: ['100%', '50%'],\n    RIGHT_BOTTOM: ['100%', '100%'],\n    BOTTOM_LEFT: ['0%', '100%'],\n    BOTTOM_CENTER: ['50%', '100%'],\n    BOTTOM: ['50%', '100%'],\n    BOTTOM_RIGHT: ['100%', '100%'],\n    CENTER: ['50%', '50%']\n};\nconst AdvancedMarker = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\n    const { children, style, className, anchorPoint } = props;\n    const [marker, contentContainer] = useAdvancedMarker(props);\n    const advancedMarkerContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (marker ? { marker } : null), [marker]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => marker, [marker]);\n    if (!contentContainer)\n        return null;\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(AdvancedMarkerContext.Provider, { value: advancedMarkerContextValue }, (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(react__WEBPACK_IMPORTED_MODULE_0__.createElement(MarkerContent, { anchorPoint: anchorPoint, styles: style, className: className }, children), contentContainer)));\n});\nAdvancedMarker.displayName = 'AdvancedMarker';\nfunction useAdvancedMarkerRef() {\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((m) => {\n        setMarker(m);\n    }, []);\n    return [refCallback, marker];\n}\nfunction isAdvancedMarker(marker) {\n    return (marker.content !== undefined);\n}\nfunction isElementNode(node) {\n    return node.nodeType === Node.ELEMENT_NODE;\n}\nconst MarkerContent = ({ children, styles, className }) => {\n    /* AdvancedMarker div that user can give styles and classes */\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: className, style: styles }, children));\n};\nfunction useAdvancedMarker(props) {\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [contentContainer, setContentContainer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const map = useMap();\n    const markerLibrary = useMapsLibrary('marker');\n    const { children, onClick, className, onMouseEnter, onMouseLeave, onDrag, onDragStart, onDragEnd, collisionBehavior, clickable, draggable, position, title, zIndex, anchorPoint, anchorLeft, anchorTop } = props;\n    const numChildren = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children);\n    // create an AdvancedMarkerElement instance and add it to the map once available\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!map || !markerLibrary)\n            return;\n        const newMarker = new markerLibrary.AdvancedMarkerElement();\n        newMarker.map = map;\n        setMarker(newMarker);\n        // create the container for marker content if there are children\n        let contentElement = null;\n        if (numChildren > 0) {\n            contentElement = document.createElement('div');\n            newMarker.content = contentElement;\n            setContentContainer(contentElement);\n        }\n        return () => {\n            newMarker.map = null;\n            contentElement === null || contentElement === void 0 ? void 0 : contentElement.remove();\n            setMarker(null);\n            setContentContainer(null);\n        };\n    }, [map, markerLibrary, numChildren]);\n    // When no children are present we don't have our own wrapper div\n    // which usually gets the user provided className. In this case\n    // we set the className directly on the marker.content element that comes\n    // with the AdvancedMarker.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!(marker === null || marker === void 0 ? void 0 : marker.content) || !isElementNode(marker.content) || numChildren > 0)\n            return;\n        marker.content.className = className !== null && className !== void 0 ? className : '';\n    }, [marker, className, numChildren]);\n    useAdvancedMarkerAnchoring(marker, anchorPoint, anchorLeft, anchorTop, numChildren > 0);\n    // copy other props\n    usePropBinding(marker, 'position', position);\n    usePropBinding(marker, 'title', title !== null && title !== void 0 ? title : '');\n    usePropBinding(marker, 'zIndex', zIndex);\n    usePropBinding(marker, 'collisionBehavior', collisionBehavior);\n    // set gmpDraggable from props (when unspecified, it's true if any drag-event\n    // callbacks are specified)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!marker)\n            return;\n        if (draggable !== undefined)\n            marker.gmpDraggable = draggable;\n        else if (onDrag || onDragStart || onDragEnd)\n            marker.gmpDraggable = true;\n        else\n            marker.gmpDraggable = false;\n    }, [marker, draggable, onDrag, onDragEnd, onDragStart]);\n    // set gmpClickable from props (when unspecified, it's true if the onClick or one of\n    // the hover events callbacks are specified)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!marker)\n            return;\n        const gmpClickable = clickable !== undefined ||\n            Boolean(onClick) ||\n            Boolean(onMouseEnter) ||\n            Boolean(onMouseLeave);\n        // gmpClickable is only available in beta version of the\n        // maps api (as of 2024-10-10)\n        marker.gmpClickable = gmpClickable;\n        // enable pointer events for the markers with custom content\n        if (gmpClickable && (marker === null || marker === void 0 ? void 0 : marker.content) && isElementNode(marker.content)) {\n            marker.content.style.pointerEvents = 'all';\n            if (onClick) {\n                marker.content.style.cursor = 'pointer';\n            }\n        }\n    }, [marker, clickable, onClick, onMouseEnter, onMouseLeave]);\n    useMapsEventListener(marker, 'click', onClick);\n    useMapsEventListener(marker, 'drag', onDrag);\n    useMapsEventListener(marker, 'dragstart', onDragStart);\n    useMapsEventListener(marker, 'dragend', onDragEnd);\n    useDomEventListener(marker === null || marker === void 0 ? void 0 : marker.element, 'mouseenter', onMouseEnter);\n    useDomEventListener(marker === null || marker === void 0 ? void 0 : marker.element, 'mouseleave', onMouseLeave);\n    return [marker, contentContainer];\n}\nfunction useAdvancedMarkerAnchoring(marker, anchorPoint, anchorLeft, anchorTop, hasChildren) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!marker || !hasChildren)\n            return;\n        // The anchorLeft and anchorTop options are available since version 3.62.9c\n        // With the release of 3.65 (~May 2026) there will no longer be a version\n        // that doesn't support it.\n        const anchorOptionsSupported = isVersionGreaterEqual(3, 62);\n        const contentElement = marker.content;\n        if (!contentElement || !isElementNode(contentElement))\n            return;\n        if (anchorLeft !== undefined || anchorTop !== undefined) {\n            if (!anchorOptionsSupported) {\n                console.warn('AdvancedMarker: The anchorLeft and anchorTop props are only supported ' +\n                    'in Google Maps API version 3.62 and above. ' +\n                    `The current version is ${google.maps.version}.`);\n            }\n            marker.anchorLeft = anchorLeft;\n            marker.anchorTop = anchorTop;\n            // when anchorLeft and/or anchorTop are set, we'll ignore the anchorPoint\n            if (anchorPoint !== undefined) {\n                console.warn('AdvancedMarker: the anchorPoint prop is ignored when anchorLeft ' +\n                    'and/or anchorTop are set.');\n            }\n            return;\n        }\n        if (anchorPoint !== undefined) {\n            // TODO: add console.warn in a future version to inform about deprecation\n            const [x, y] = anchorPoint !== null && anchorPoint !== void 0 ? anchorPoint : AdvancedMarkerAnchorPoint['BOTTOM'];\n            // NOTE: since x and y can be any valid CSS length-percentage\n            //   value, we need to use calc() to negate them.\n            const translateX = `calc(-1 * ${x})`;\n            const translateY = `calc(-1 * ${y})`;\n            if (anchorOptionsSupported) {\n                // implement anchorPoint using the new anchorLeft and anchorTop options\n                marker.anchorLeft = translateX;\n                marker.anchorTop = translateY;\n                // reset transform from legacy implementation\n                contentElement.style.transform = '';\n            }\n            else {\n                // The \"translate(50%, 100%)\" counters and resets the default\n                // anchoring of the advanced marker element from the api\n                contentElement.style.transform = `translate(50%, 100%) translate(${translateX}, ${translateY})`;\n                // data-origin is needed to identify the custom marker content in the\n                // InfoWindow component as well as in the global CSS used to disable\n                // the pointer event when anchor points are used in older Google Maps\n                // versions.\n                marker.dataset.origin = 'rgm';\n                globalStyleManager.addAdvancedMarkerPointerEventsOverwrite();\n            }\n        }\n    }, [marker, anchorPoint, anchorLeft, anchorTop, hasChildren]);\n}\n\nfunction setValueForStyles(element, styles, prevStyles) {\n    if (styles != null && typeof styles !== 'object') {\n        throw new Error('The `style` prop expects a mapping from style properties to values, ' +\n            \"not a string. For example, style={{marginRight: spacing + 'em'}} when \" +\n            'using JSX.');\n    }\n    const elementStyle = element.style;\n    // without `prevStyles`, just set all values\n    if (prevStyles == null) {\n        if (styles == null)\n            return;\n        for (const styleName in styles) {\n            if (!styles.hasOwnProperty(styleName))\n                continue;\n            setValueForStyle(elementStyle, styleName, styles[styleName]);\n        }\n        return;\n    }\n    // unset all styles in `prevStyles` that aren't in `styles`\n    for (const styleName in prevStyles) {\n        if (prevStyles.hasOwnProperty(styleName) &&\n            (styles == null || !styles.hasOwnProperty(styleName))) {\n            // Clear style\n            const isCustomProperty = styleName.indexOf('--') === 0;\n            if (isCustomProperty) {\n                elementStyle.setProperty(styleName, '');\n            }\n            else if (styleName === 'float') {\n                elementStyle.cssFloat = '';\n            }\n            else {\n                elementStyle[styleName] = '';\n            }\n        }\n    }\n    // only assign values from `styles` that are different from `prevStyles`\n    if (styles == null)\n        return;\n    for (const styleName in styles) {\n        const value = styles[styleName];\n        if (styles.hasOwnProperty(styleName) &&\n            prevStyles[styleName] !== value) {\n            setValueForStyle(elementStyle, styleName, value);\n        }\n    }\n}\nfunction setValueForStyle(elementStyle, styleName, value) {\n    const isCustomProperty = styleName.indexOf('--') === 0;\n    // falsy values will unset the style property\n    if (value == null || typeof value === 'boolean' || value === '') {\n        if (isCustomProperty) {\n            elementStyle.setProperty(styleName, '');\n        }\n        else if (styleName === 'float') {\n            elementStyle.cssFloat = '';\n        }\n        else {\n            elementStyle[styleName] = '';\n        }\n    }\n    // custom properties can't be directly assigned\n    else if (isCustomProperty) {\n        elementStyle.setProperty(styleName, value);\n    }\n    // numeric values are treated as 'px' unless the style property expects unitless numbers\n    else if (typeof value === 'number' &&\n        value !== 0 &&\n        !isUnitlessNumber(styleName)) {\n        elementStyle[styleName] = value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n    }\n    // everything else can just be assigned\n    else {\n        if (styleName === 'float') {\n            elementStyle.cssFloat = value;\n        }\n        else {\n            elementStyle[styleName] = ('' + value).trim();\n        }\n    }\n}\n// CSS properties which accept numbers but are not in units of \"px\".\nconst unitlessNumbers = new Set([\n    'animationIterationCount',\n    'aspectRatio',\n    'borderImageOutset',\n    'borderImageSlice',\n    'borderImageWidth',\n    'boxFlex',\n    'boxFlexGroup',\n    'boxOrdinalGroup',\n    'columnCount',\n    'columns',\n    'flex',\n    'flexGrow',\n    'flexPositive',\n    'flexShrink',\n    'flexNegative',\n    'flexOrder',\n    'gridArea',\n    'gridRow',\n    'gridRowEnd',\n    'gridRowSpan',\n    'gridRowStart',\n    'gridColumn',\n    'gridColumnEnd',\n    'gridColumnSpan',\n    'gridColumnStart',\n    'fontWeight',\n    'lineClamp',\n    'lineHeight',\n    'opacity',\n    'order',\n    'orphans',\n    'scale',\n    'tabSize',\n    'widows',\n    'zIndex',\n    'zoom',\n    'fillOpacity', // SVG-related properties\n    'floodOpacity',\n    'stopOpacity',\n    'strokeDasharray',\n    'strokeDashoffset',\n    'strokeMiterlimit',\n    'strokeOpacity',\n    'strokeWidth'\n]);\nfunction isUnitlessNumber(name) {\n    return unitlessNumbers.has(name);\n}\n\n/**\n * Component to render an Info Window with the Maps JavaScript API\n */\nconst InfoWindow = props => {\n    const { \n    // content options\n    children, headerContent, style, className, pixelOffset, \n    // open options\n    anchor, shouldFocus, \n    // events\n    onClose, onCloseClick } = props, \n    // other options\n    volatileInfoWindowOptions = __rest(props, [\"children\", \"headerContent\", \"style\", \"className\", \"pixelOffset\", \"anchor\", \"shouldFocus\", \"onClose\", \"onCloseClick\"]);\n    // ## create infowindow instance once the mapsLibrary is available.\n    const mapsLibrary = useMapsLibrary('maps');\n    const [infoWindow, setInfoWindow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const contentContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const headerContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const infoWindowOptions = useMemoized(volatileInfoWindowOptions, fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!mapsLibrary)\n            return;\n        contentContainerRef.current = document.createElement('div');\n        headerContainerRef.current = document.createElement('div');\n        const opts = infoWindowOptions;\n        if (pixelOffset) {\n            opts.pixelOffset = new google.maps.Size(pixelOffset[0], pixelOffset[1]);\n        }\n        if (headerContent) {\n            // if headerContent is specified as string we can directly forward it,\n            // otherwise we'll pass the element the portal will render into\n            opts.headerContent =\n                typeof headerContent === 'string'\n                    ? headerContent\n                    : headerContainerRef.current;\n        }\n        // intentionally shadowing the state variables here\n        const infoWindow = new google.maps.InfoWindow(infoWindowOptions);\n        infoWindow.setContent(contentContainerRef.current);\n        setInfoWindow(infoWindow);\n        // unmount: remove infoWindow and content elements (note: close is called in a different effect-cleanup)\n        return () => {\n            var _a, _b;\n            infoWindow.setContent(null);\n            (_a = contentContainerRef.current) === null || _a === void 0 ? void 0 : _a.remove();\n            (_b = headerContainerRef.current) === null || _b === void 0 ? void 0 : _b.remove();\n            contentContainerRef.current = null;\n            headerContainerRef.current = null;\n            setInfoWindow(null);\n        };\n    }, \n    // `infoWindowOptions` and other props are missing from dependencies:\n    //\n    // We don't want to re-create the infowindow instance\n    // when the options change.\n    // Updating the options is handled in the useEffect below.\n    //\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [mapsLibrary]);\n    // ---- update className and styles for `contentContainer`\n    // prevStyleRef stores previously applied style properties, so they can be\n    // removed when unset\n    const prevStyleRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!infoWindow || !contentContainerRef.current)\n            return;\n        setValueForStyles(contentContainerRef.current, style || null, prevStyleRef.current);\n        prevStyleRef.current = style || null;\n        if (className !== contentContainerRef.current.className)\n            contentContainerRef.current.className = className || '';\n    }, [infoWindow, className, style]);\n    // ---- update options\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!infoWindow)\n            return;\n        const opts = infoWindowOptions;\n        if (!pixelOffset) {\n            opts.pixelOffset = null;\n        }\n        else {\n            opts.pixelOffset = new google.maps.Size(pixelOffset[0], pixelOffset[1]);\n        }\n        if (!headerContent) {\n            opts.headerContent = null;\n        }\n        else {\n            opts.headerContent =\n                typeof headerContent === 'string'\n                    ? headerContent\n                    : headerContainerRef.current;\n        }\n        infoWindow.setOptions(infoWindowOptions);\n    }, \n    // dependency `infoWindow` isn't needed since options are also passed\n    // to the constructor when a new infoWindow is created.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [infoWindowOptions, pixelOffset, headerContent]);\n    // ## bind event handlers\n    useMapsEventListener(infoWindow, 'close', onClose);\n    useMapsEventListener(infoWindow, 'closeclick', onCloseClick);\n    // ---- open info window when content and map are available\n    const map = useMap();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        var _a;\n        // `anchor === null` means an anchor is defined but not ready yet.\n        if (!map || !infoWindow || anchor === null)\n            return;\n        const isOpenedWithAnchor = !!anchor;\n        const openOptions = { map };\n        if (anchor) {\n            openOptions.anchor = anchor;\n            // Only do the infowindow adjusting when dealing with an AdvancedMarker\n            if (isAdvancedMarker(anchor) && anchor.content instanceof Element) {\n                const anchorBcr = anchor === null || anchor === void 0 ? void 0 : anchor.getBoundingClientRect();\n                // This checks whether or not the anchor has custom content with our own\n                // div wrapper. If not, that means we have a regular AdvancedMarker without\n                // children, or an AdvancedMarker that uses the anchorLeft/anchorTop props.\n                // In that case we do not want to adjust the infowindow since it is all handled correctly\n                // by the Google Maps API.\n                if (anchorBcr && anchor.dataset.origin === 'rgm') {\n                    // We can safely typecast here since we control that element and we know that\n                    // it is a div\n                    const anchorDomContent = (_a = anchor.content.firstElementChild) === null || _a === void 0 ? void 0 : _a.firstElementChild;\n                    const contentBcr = anchorDomContent === null || anchorDomContent === void 0 ? void 0 : anchorDomContent.getBoundingClientRect();\n                    // center infowindow above marker\n                    const anchorOffsetX = contentBcr.x -\n                        anchorBcr.x +\n                        (contentBcr.width - anchorBcr.width) / 2;\n                    const anchorOffsetY = contentBcr.y - anchorBcr.y;\n                    const opts = infoWindowOptions;\n                    opts.pixelOffset = new google.maps.Size(pixelOffset ? pixelOffset[0] + anchorOffsetX : anchorOffsetX, pixelOffset ? pixelOffset[1] + anchorOffsetY : anchorOffsetY);\n                    infoWindow.setOptions(opts);\n                }\n            }\n        }\n        if (shouldFocus !== undefined) {\n            openOptions.shouldFocus = shouldFocus;\n        }\n        infoWindow.open(openOptions);\n        return () => {\n            // Note: when the infowindow has an anchor, it will automatically show up again when the\n            // anchor was removed from the map before infoWindow.close() is called but the it gets\n            // added back to the map after that.\n            // More information here: https://issuetracker.google.com/issues/343750849\n            if (isOpenedWithAnchor)\n                infoWindow.set('anchor', null);\n            infoWindow.close();\n        };\n    }, [infoWindow, anchor, map, shouldFocus, infoWindowOptions, pixelOffset]);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        contentContainerRef.current &&\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, contentContainerRef.current),\n        headerContainerRef.current !== null &&\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(headerContent, headerContainerRef.current)));\n};\n\n/**\n * Formats a location into a string representation suitable for Google Static Maps API.\n *\n * @param location - The location to format, can be either a string or an object with lat/lng properties\n * @returns A string representation of the location in the format \"lat,lng\" or the original string\n *\n * @example\n * // Returns \"40.714728,-73.998672\"\n * formatLocation({ lat: 40.714728, lng: -73.998672 })\n *\n * @example\n * // Returns \"New York, NY\"\n * formatLocation(\"New York, NY\")\n */\nfunction formatLocation(location) {\n    return typeof location === 'string'\n        ? location\n        : `${location.lat},${location.lng}`;\n}\n// Used for removing the leading pipe from the param string\nfunction formatParam(string) {\n    return string.slice(1);\n}\n\n/**\n * Assembles marker parameters for static maps.\n *\n * This function takes an array of markers and groups them by their style properties.\n * It then creates a string representation of these markers, including their styles and locations,\n * which can be used as parameters for static map APIs.\n *\n * @param {StaticMapsMarker[]} [markers=[]] - An array of markers to be processed. Each marker can have properties such as color, label, size, scale, icon, anchor, and location.\n * @returns {string[]} An array of strings, each representing a group of markers with their styles and locations.\n *\n * @example\n * const markers = [\n *   { color: 'blue', label: 'A', size: 'mid', location: '40.714728,-73.998672' },\n *   { color: 'blue', label: 'B', size: 'mid', location: '40.714728,-73.998672' },\n *   { icon: 'http://example.com/icon.png', location: { lat: 40.714728, lng: -73.998672 } }\n * ];\n * const params = assembleMarkerParams(markers);\n * // Params will be an array of strings representing the marker parameters\n * Example output: [\n *   \"color:blue|label:A|size:mid|40.714728,-73.998672|40.714728,-73.998672\",\n *   \"color:blue|label:B|size:mid|40.714728,-73.998672|40.714728,-73.998672\",\n *   \"icon:http://example.com/icon.png|40.714728,-73.998672\"\n * ]\n */\nfunction assembleMarkerParams(markers = []) {\n    const markerParams = [];\n    // Group markers by style\n    const markersByStyle = markers === null || markers === void 0 ? void 0 : markers.reduce((styles, marker) => {\n        const { color = 'red', label, size, scale, icon, anchor } = marker;\n        // Create a unique style key based on either icon properties or standard marker properties\n        const relevantProps = icon ? [icon, anchor, scale] : [color, label, size];\n        const key = relevantProps.filter(Boolean).join('-');\n        styles[key] = styles[key] || [];\n        styles[key].push(marker);\n        return styles;\n    }, {});\n    Object.values(markersByStyle !== null && markersByStyle !== void 0 ? markersByStyle : {}).forEach(markers => {\n        let markerParam = '';\n        const { icon } = markers[0];\n        // Create marker style from first marker in group since all markers share the same style.\n        Object.entries(markers[0]).forEach(([key, value]) => {\n            // Determine which properties to include based on whether marker uses custom icon\n            const relevantKeys = icon\n                ? ['icon', 'anchor', 'scale']\n                : ['color', 'label', 'size'];\n            if (relevantKeys.includes(key)) {\n                markerParam += `|${key}:${value}`;\n            }\n        });\n        // Add location coordinates for each marker in the style group\n        // Handles both string locations and lat/lng object formats.\n        for (const marker of markers) {\n            const location = typeof marker.location === 'string'\n                ? marker.location\n                : `${marker.location.lat},${marker.location.lng}`;\n            markerParam += `|${location}`;\n        }\n        markerParams.push(markerParam);\n    });\n    return markerParams.map(formatParam);\n}\n\n// Style properties that can be applied to paths in the Static Maps API\nconst PATH_STYLE_KEYS = ['color', 'weight', 'fillcolor', 'geodesic'];\n/**\n * Builds the style portion of a path parameter string.\n * @param path - The path object containing style properties\n * @returns A string with style parameters in the format \"|key:value\"\n */\nfunction buildStyleParams(path) {\n    let styleParams = '';\n    PATH_STYLE_KEYS.forEach(key => {\n        if (path[key] !== undefined) {\n            styleParams += `|${key}:${path[key]}`;\n        }\n    });\n    return styleParams;\n}\n/**\n * Builds the coordinates portion of a path parameter string.\n * @param coordinates - Either a string or array of location objects\n * @returns A string with coordinates in the format \"|lat,lng|lat,lng\"\n */\nfunction buildCoordinateParams(coordinates) {\n    if (typeof coordinates === 'string') {\n        return `|${decodeURIComponent(coordinates)}`;\n    }\n    return coordinates.map(location => `|${formatLocation(location)}`).join('');\n}\n/**\n * Assembles path parameters for the Static Maps API from an array of paths.\n *\n * This function constructs a string of path parameters for each path. Each path parameter string\n * includes the style properties and the coordinates of the paths.\n *\n * @param {Array<StaticMapsPath>} [paths=[]] - An array of paths to be assembled into path parameters.\n * @returns {Array<string>} An array of path parameter strings.\n *\n * @example\n * ```typescript\n * const paths = [\n *   {\n *     color: 'red',\n *     weight: 5,\n *     coordinates: [\n *       { lat: 40.714728, lng: -73.998672 },\n *       { lat: 40.718217, lng: -73.998284 }\n *     ]\n *   }\n * ];\n *\n * const pathParams = assemblePathParams(paths);\n * // Output: ['color:red|weight:5|40.714728,-73.998672|40.718217,-73.998284']\n * ```\n */\nfunction assemblePathParams(paths = []) {\n    return paths.map(path => {\n        const styleParams = buildStyleParams(path);\n        const coordinateParams = buildCoordinateParams(path.coordinates);\n        const pathParam = styleParams + coordinateParams;\n        return formatParam(pathParam);\n    });\n}\n\n/**\n * Converts an array of Google Maps style objects into an array of style strings\n * compatible with the Google Static Maps API.\n *\n * @param styles - An array of Google Maps MapTypeStyle objects that define the styling rules\n * @returns An array of formatted style strings ready to be used with the Static Maps API\n *\n * @example\n * const styles = [{\n *   featureType: \"road\",\n *   elementType: \"geometry\",\n *   stylers: [{color: \"#ff0000\"}, {weight: 1}]\n * }];\n *\n * const styleStrings = assembleMapTypeStyles(styles);\n * // Returns: [\"|feature:road|element:geometry|color:0xff0000|weight:1\"]\n *\n * Each style string follows the format:\n * \"feature:{featureType}|element:{elementType}|{stylerName}:{stylerValue}\"\n *\n * Note: Color values with hexadecimal notation (#) are automatically converted\n * to the required 0x format for the Static Maps API.\n */\nfunction assembleMapTypeStyles(styles) {\n    return styles\n        .map((mapTypeStyle) => {\n        const { featureType, elementType, stylers = [] } = mapTypeStyle;\n        let styleString = '';\n        if (featureType) {\n            styleString += `|feature:${featureType}`;\n        }\n        if (elementType) {\n            styleString += `|element:${elementType}`;\n        }\n        for (const styler of stylers) {\n            Object.entries(styler).forEach(([name, value]) => {\n                styleString += `|${name}:${String(value).replace('#', '0x')}`;\n            });\n        }\n        return styleString;\n    })\n        .map(formatParam);\n}\n\nconst STATIC_MAPS_BASE = 'https://maps.googleapis.com/maps/api/staticmap';\n/**\n * Creates a URL for the Google Static Maps API with the specified parameters.\n *\n * @param {Object} options - The configuration options for the static map\n * @param {string} options.apiKey - Your Google Maps API key (required)\n * @param {number} options.width - The width of the map image in pixels (required)\n * @param {number} options.height - The height of the map image in pixels (required)\n * @param {StaticMapsLocation} [options.center] - The center point of the map (lat/lng or address).\n *  Required if no markers or paths or \"visible locations\" are provided.\n * @param {number} [options.zoom] - The zoom level of the map. Required if no markers or paths or \"visible locations\" are provided.\n * @param {1|2|4} [options.scale] - The resolution of the map (1, 2, or 4)\n * @param {string} [options.format] - The image format (png, png8, png32, gif, jpg, jpg-baseline)\n * @param {string} [options.mapType] - The type of map (roadmap, satellite, terrain, hybrid)\n * @param {string} [options.language] - The language of the map labels\n * @param {string} [options.region] - The region code for the map\n * @param {string} [options.map_id] - The Cloud-based map style ID\n * @param {StaticMapsMarker[]} [options.markers=[]] - Array of markers to display on the map\n * @param {StaticMapsPath[]} [options.paths=[]] - Array of paths to display on the map\n * @param {StaticMapsLocation[]} [options.visible=[]] - Array of locations that should be visible on the map\n * @param {MapTypeStyle[]} [options.style=[]] - Array of style objects to customize the map appearance\n *\n * @returns {string} The complete Google Static Maps API URL\n *\n * @throws {Error} If API key is not provided\n * @throws {Error} If width or height is not provided\n *\n * @example\n * const url = createStaticMapsUrl({\n *   apiKey: 'YOUR_API_KEY',\n *   width: 600,\n *   height: 400,\n *   center: { lat: 40.714728, lng: -73.998672 },\n *   zoom: 12,\n *   markers: [\n *     {\n *       location: { lat: 40.714728, lng: -73.998672 },\n *       color: 'red',\n *       label: 'A'\n *     }\n *   ],\n *   paths: [\n *     {\n *       coordinates: [\n *         { lat: 40.714728, lng: -73.998672 },\n *         { lat: 40.719728, lng: -73.991672 }\n *       ],\n *       color: '0x0000ff',\n *       weight: 5\n *     }\n *   ],\n *   style: [\n *     {\n *       featureType: 'road',\n *       elementType: 'geometry',\n *       stylers: [{color: '#00ff00'}]\n *     }\n *   ]\n * });\n *\n * // Results in URL similar to:\n * // https://maps.googleapis.com/maps/api/staticmap?key=YOUR_API_KEY\n * // &size=600x400\n * // &center=40.714728,-73.998672&zoom=12\n * // &markers=color:red|label:A|40.714728,-73.998672\n * // &path=color:0x0000ff|weight:5|40.714728,-73.998672|40.719728,-73.991672\n * // &style=feature:road|element:geometry|color:0x00ff00\n */\nfunction createStaticMapsUrl({ apiKey, width, height, center, zoom, scale, format, mapType, language, region, mapId, markers = [], paths = [], visible = [], style = [] }) {\n    if (!apiKey) {\n        console.warn('API key is required');\n    }\n    if (!width || !height) {\n        console.warn('Width and height are required');\n    }\n    const params = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ key: apiKey, size: `${width}x${height}` }, (center && { center: formatLocation(center) })), (zoom && { zoom })), (scale && { scale })), (format && { format })), (mapType && { maptype: mapType })), (language && { language })), (region && { region })), (mapId && { map_id: mapId }));\n    const url = new URL(STATIC_MAPS_BASE);\n    // Params that don't need special handling\n    Object.entries(params).forEach(([key, value]) => {\n        url.searchParams.append(key, String(value));\n    });\n    // Assemble Markers\n    for (const markerParam of assembleMarkerParams(markers)) {\n        url.searchParams.append('markers', markerParam);\n    }\n    // Assemble Paths\n    for (const pathParam of assemblePathParams(paths)) {\n        url.searchParams.append('path', pathParam);\n    }\n    // Assemble visible locations\n    if (visible.length) {\n        url.searchParams.append('visible', visible.map(location => formatLocation(location)).join('|'));\n    }\n    // Assemble Map Type Styles\n    for (const styleString of assembleMapTypeStyles(style)) {\n        url.searchParams.append('style', styleString);\n    }\n    return url.toString();\n}\n\nconst StaticMap = (props) => {\n    const { url, className } = props;\n    if (!url)\n        throw new Error('URL is required');\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", { className: className, src: url, width: \"100%\" });\n};\n\n/**\n * Copy of the `google.maps.ControlPosition` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */\nconst ControlPosition = {\n    TOP_LEFT: 1,\n    TOP_CENTER: 2,\n    TOP: 2,\n    TOP_RIGHT: 3,\n    LEFT_CENTER: 4,\n    LEFT_TOP: 5,\n    LEFT: 5,\n    LEFT_BOTTOM: 6,\n    RIGHT_TOP: 7,\n    RIGHT: 7,\n    RIGHT_CENTER: 8,\n    RIGHT_BOTTOM: 9,\n    BOTTOM_LEFT: 10,\n    BOTTOM_CENTER: 11,\n    BOTTOM: 11,\n    BOTTOM_RIGHT: 12,\n    CENTER: 13,\n    BLOCK_START_INLINE_START: 14,\n    BLOCK_START_INLINE_CENTER: 15,\n    BLOCK_START_INLINE_END: 16,\n    INLINE_START_BLOCK_CENTER: 17,\n    INLINE_START_BLOCK_START: 18,\n    INLINE_START_BLOCK_END: 19,\n    INLINE_END_BLOCK_START: 20,\n    INLINE_END_BLOCK_CENTER: 21,\n    INLINE_END_BLOCK_END: 22,\n    BLOCK_END_INLINE_START: 23,\n    BLOCK_END_INLINE_CENTER: 24,\n    BLOCK_END_INLINE_END: 25\n};\nconst MapControl = ({ children, position }) => {\n    const controlContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => document.createElement('div'), []);\n    const map = useMap();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!map)\n            return;\n        const controls = map.controls[position];\n        controls.push(controlContainer);\n        return () => {\n            const controlsArray = controls.getArray();\n            // controlsArray could be undefined if the map is in an undefined state (e.g. invalid API-key, see #276\n            if (!controlsArray)\n                return;\n            const index = controlsArray.indexOf(controlContainer);\n            controls.removeAt(index);\n        };\n    }, [controlContainer, map, position]);\n    return (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, controlContainer);\n};\n\nfunction useMarker(props) {\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const map = useMap();\n    const { onClick, onDrag, onDragStart, onDragEnd, onMouseOver, onMouseOut } = props, markerOptions = __rest(props, [\"onClick\", \"onDrag\", \"onDragStart\", \"onDragEnd\", \"onMouseOver\", \"onMouseOut\"]);\n    const { position, draggable } = markerOptions;\n    // create marker instance and add to the map once the map is available\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!map) {\n            if (map === undefined)\n                console.error('<Marker> has to be inside a Map component.');\n            return;\n        }\n        const newMarker = new google.maps.Marker(markerOptions);\n        newMarker.setMap(map);\n        setMarker(newMarker);\n        return () => {\n            newMarker.setMap(null);\n            setMarker(null);\n        };\n        // We do not want to re-render the whole marker when the options change.\n        // Marker options update is handled in a useEffect below.\n        // Excluding markerOptions from dependency array on purpose here.\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [map]);\n    // attach and re-attach event-handlers when any of the properties change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!marker)\n            return;\n        const m = marker;\n        // Add event listeners\n        const gme = google.maps.event;\n        if (onClick)\n            gme.addListener(m, 'click', onClick);\n        if (onDrag)\n            gme.addListener(m, 'drag', onDrag);\n        if (onDragStart)\n            gme.addListener(m, 'dragstart', onDragStart);\n        if (onDragEnd)\n            gme.addListener(m, 'dragend', onDragEnd);\n        if (onMouseOver)\n            gme.addListener(m, 'mouseover', onMouseOver);\n        if (onMouseOut)\n            gme.addListener(m, 'mouseout', onMouseOut);\n        marker.setDraggable(Boolean(draggable));\n        return () => {\n            gme.clearInstanceListeners(m);\n        };\n    }, [\n        marker,\n        draggable,\n        onClick,\n        onDrag,\n        onDragStart,\n        onDragEnd,\n        onMouseOver,\n        onMouseOut\n    ]);\n    // update markerOptions (note the dependencies aren't properly checked\n    // here, we just assume that setOptions is smart enough to not waste a\n    // lot of time updating values that didn't change)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!marker)\n            return;\n        if (markerOptions)\n            marker.setOptions(markerOptions);\n    }, [marker, markerOptions]);\n    // update position when changed\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        // Should not update position when draggable\n        if (draggable || !position || !marker)\n            return;\n        marker.setPosition(position);\n    }, [draggable, position, marker]);\n    return marker;\n}\n/**\n * Component to render a marker on a map\n */\nconst Marker = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\n    const marker = useMarker(props);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => marker, [marker]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n});\nMarker.displayName = 'Marker';\nfunction useMarkerRef() {\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((m) => {\n        setMarker(m);\n    }, []);\n    return [refCallback, marker];\n}\n\n/**\n * Component to configure the appearance of an AdvancedMarker\n */\nconst Pin = props => {\n    var _a;\n    const advancedMarker = (_a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AdvancedMarkerContext)) === null || _a === void 0 ? void 0 : _a.marker;\n    const glyphContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => document.createElement('div'), []);\n    // Create Pin View instance\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        var _a;\n        if (!advancedMarker) {\n            if (advancedMarker === undefined) {\n                console.error('The <Pin> component can only be used inside <AdvancedMarker>.');\n            }\n            return;\n        }\n        if (props.glyph && props.children) {\n            logErrorOnce('The <Pin> component only uses children to render the glyph if both the glyph property and children are present.');\n        }\n        if (react__WEBPACK_IMPORTED_MODULE_0__.Children.count(props.children) > 1) {\n            logErrorOnce('Passing multiple children to the <Pin> component might lead to unexpected results.');\n        }\n        const pinViewOptions = Object.assign({}, props);\n        const pinElement = new google.maps.marker.PinElement(pinViewOptions);\n        // Set glyph to glyph container if children are present (rendered via portal).\n        // If both props.glyph and props.children are present, props.children takes priority.\n        if (props.children) {\n            pinElement.glyph = glyphContainer;\n        }\n        // Set content of Advanced Marker View to the Pin View element\n        // Here we are selecting the anchor container.\n        // The hierarchy is as follows:\n        // \"advancedMarker.content\" (from google) -> \"anchor container\"\n        const markerContent = (_a = advancedMarker.content) === null || _a === void 0 ? void 0 : _a.firstChild;\n        while (markerContent === null || markerContent === void 0 ? void 0 : markerContent.firstChild) {\n            markerContent.removeChild(markerContent.firstChild);\n        }\n        if (markerContent) {\n            markerContent.appendChild(pinElement.element);\n        }\n    }, [advancedMarker, glyphContainer, props]);\n    return (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(props.children, glyphContainer);\n};\n\nconst mapLinear = (x, a1, a2, b1, b2) => b1 + ((x - a1) * (b2 - b1)) / (a2 - a1);\nconst getMapMaxTilt = (zoom) => {\n    if (zoom <= 10) {\n        return 30;\n    }\n    if (zoom >= 15.5) {\n        return 67.5;\n    }\n    // range [10...14]\n    if (zoom <= 14) {\n        return mapLinear(zoom, 10, 14, 30, 45);\n    }\n    // range [14...15.5]\n    return mapLinear(zoom, 14, 15.5, 45, 67.5);\n};\n/**\n * Function to limit the tilt range of the Google map when updating the view state\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst limitTiltRange = ({ viewState }) => {\n    const pitch = viewState.pitch;\n    const gmZoom = viewState.zoom + 1;\n    const maxTilt = getMapMaxTilt(gmZoom);\n    return Object.assign(Object.assign({}, viewState), { fovy: 25, pitch: Math.min(maxTilt, pitch) });\n};\n\n\n//# sourceMappingURL=index.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdmlzLmdsL3JlYWN0LWdvb2dsZS1tYXBzL2Rpc3QvaW5kZXgubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUs7QUFDNUg7QUFDQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2Q0FBTTtBQUN0QixJQUFJLGdEQUFTO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLDhDQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7O0FBRUE7QUFDQSxpREFBaUQsNENBQVc7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixpREFBVTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBVTtBQUN6QjtBQUNBLElBQUksMERBQW1CO0FBQ3ZCLFdBQVcsZ0RBQW1CLENBQUMsMkNBQWM7QUFDN0MsQ0FBQztBQUNEO0FBQ0E7QUFDQSxnQ0FBZ0MsK0NBQVE7QUFDeEMsd0JBQXdCLGtEQUFXO0FBQ25DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpREFBVTtBQUMzQywyQkFBMkIsOENBQU87QUFDbEM7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJDQUFRO0FBQ3BCO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLHVEQUFZO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQiwyQ0FBMkM7QUFDcEc7O0FBRXdkO0FBQ3hkIiwic291cmNlcyI6WyIvVm9sdW1lcy9QZWRyb1NTRC9Qcm9qZXRvcy9nZW5lcmljLWxhbmRpbmctcGFnZS9ub2RlX21vZHVsZXMvQHZpcy5nbC9yZWFjdC1nb29nbGUtbWFwcy9kaXN0L2luZGV4Lm1vZGVybi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8sIHVzZVN0YXRlLCB1c2VSZWR1Y2VyLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNvbnRleHQsIHVzZUxheW91dEVmZmVjdCwgZm9yd2FyZFJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IGlzRGVlcEVxdWFsIGZyb20gJ2Zhc3QtZGVlcC1lcXVhbCc7XG5cbi8vIFRoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgYnkgdGhlIGJ1aWxkIHByb2Nlc3MuXG5jb25zdCBWRVJTSU9OID0gJzEuNy4xJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG5jb25zdCBBUElMb2FkaW5nU3RhdHVzID0ge1xuICAgIE5PVF9MT0FERUQ6ICdOT1RfTE9BREVEJyxcbiAgICBMT0FESU5HOiAnTE9BRElORycsXG4gICAgTE9BREVEOiAnTE9BREVEJyxcbiAgICBGQUlMRUQ6ICdGQUlMRUQnLFxuICAgIEFVVEhfRkFJTFVSRTogJ0FVVEhfRkFJTFVSRSdcbn07XG5cbmNvbnN0IE1BUFNfQVBJX0JBU0VfVVJMID0gJ2h0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qcyc7XG4vKipcbiAqIEEgR29vZ2xlTWFwc0FwaUxvYWRlciB0byByZWxpYWJseSBsb2FkIGFuZCB1bmxvYWQgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJLlxuICpcbiAqIFRoZSBhY3R1YWwgbG9hZGluZyBhbmQgdW5sb2FkaW5nIGlzIGRlbGF5ZWQgaW50byB0aGUgbWljcm90YXNrIHF1ZXVlLCB0b1xuICogYWxsb3cgdXNpbmcgdGhlIEFQSSBpbiBhbiB1c2VFZmZlY3QgaG9vaywgd2l0aG91dCB3b3JyeWluZyBhYm91dCBtdWx0aXBsZSBBUEkgbG9hZHMuXG4gKi9cbmNsYXNzIEdvb2dsZU1hcHNBcGlMb2FkZXIge1xuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBNYXBzIEphdmFTY3JpcHQgQVBJIHdpdGggdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLlxuICAgICAqIFNpbmNlIHRoZSBNYXBzIGxpYnJhcnkgY2FuIG9ubHkgYmUgbG9hZGVkIG9uY2UgcGVyIHBhZ2UsIHRoaXMgd2lsbFxuICAgICAqIHByb2R1Y2UgYSB3YXJuaW5nIHdoZW4gY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50XG4gICAgICogcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIHdoZW4gbG9hZGluZyBjb21wbGV0ZXNcbiAgICAgKiBhbmQgcmVqZWN0cyBpbiBjYXNlIG9mIGFuIGVycm9yIG9yIHdoZW4gdGhlIGxvYWRpbmcgd2FzIGFib3J0ZWQuXG4gICAgICovXG4gICAgc3RhdGljIGxvYWQocGFyYW1zLCBvbkxvYWRpbmdTdGF0dXNDaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCBsaWJyYXJpZXMgPSBwYXJhbXMubGlicmFyaWVzID8gcGFyYW1zLmxpYnJhcmllcy5zcGxpdCgnLCcpIDogW107XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkUGFyYW1zID0gdGhpcy5zZXJpYWxpemVQYXJhbXMocGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2gob25Mb2FkaW5nU3RhdHVzQ2hhbmdlKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IGlmIGBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5YCBoYXMgYmVlbiBkZWZpbmVkIGV4dGVybmFsbHksIHdlXG4gICAgICAgICAgICAvLyAgIGFzc3VtZSB0aGF0IGxvYWRpbmcgaXMgY29tcGxldGUgYW5kIHN1Y2Nlc3NmdWwuXG4gICAgICAgICAgICAvLyAgIElmIGl0IHdhcyBkZWZpbmVkIGJ5IGEgcHJldmlvdXMgY2FsbCB0byB0aGlzIG1ldGhvZCwgYSB3YXJuaW5nXG4gICAgICAgICAgICAvLyAgIG1lc3NhZ2UgaXMgbG9nZ2VkIGlmIHRoZXJlIGFyZSBkaWZmZXJlbmNlcyBpbiBhcGktcGFyYW1ldGVycyB1c2VkXG4gICAgICAgICAgICAvLyAgIGZvciBib3RoIGNhbGxzLlxuICAgICAgICAgICAgaWYgKChfYiA9IChfYSA9IHdpbmRvdy5nb29nbGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXBzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW1wb3J0TGlicmFyeSkge1xuICAgICAgICAgICAgICAgIC8vIG5vIHNlcmlhbGl6ZWQgcGFyYW1ldGVycyBtZWFucyBpdCB3YXMgbG9hZGVkIGV4dGVybmFsbHlcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2VyaWFsaXplZEFwaVBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkxPQURFRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMb2FkaW5nU3RhdHVzTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZWRBcGlQYXJhbXMgPSBzZXJpYWxpemVkUGFyYW1zO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdEltcG9ydExpYnJhcnkocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNlcmlhbGl6ZWRBcGlQYXJhbXMgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZWRBcGlQYXJhbXMgIT09IHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtnb29nbGUtbWFwcy1hcGktbG9hZGVyXSBUaGUgbWFwcyBBUEkgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQgYCArXG4gICAgICAgICAgICAgICAgICAgIGB3aXRoIGRpZmZlcmVudCBwYXJhbWV0ZXJzIGFuZCB3aWxsIG5vdCBiZSBsb2FkZWQgYWdhaW4uIFJlZnJlc2ggdGhlIGAgK1xuICAgICAgICAgICAgICAgICAgICBgcGFnZSBmb3IgbmV3IHZhbHVlcyB0byBoYXZlIGVmZmVjdC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpYnJhcmllc1RvTG9hZCA9IFsnbWFwcycsIC4uLmxpYnJhcmllc107XG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChsaWJyYXJpZXNUb0xvYWQubWFwKG5hbWUgPT4gZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeShuYW1lKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBwYXJhbWV0ZXJzIHVzZWQgdG8gbG9hZCB0aGUgbGlicmFyeSBmb3IgZWFzaWVyIGNvbXBhcmlzb24uXG4gICAgICovXG4gICAgc3RhdGljIHNlcmlhbGl6ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHBhcmFtcy52LFxuICAgICAgICAgICAgcGFyYW1zLmtleSxcbiAgICAgICAgICAgIHBhcmFtcy5sYW5ndWFnZSxcbiAgICAgICAgICAgIHBhcmFtcy5yZWdpb24sXG4gICAgICAgICAgICBwYXJhbXMuYXV0aFJlZmVycmVyUG9saWN5LFxuICAgICAgICAgICAgcGFyYW1zLnNvbHV0aW9uQ2hhbm5lbFxuICAgICAgICBdLmpvaW4oJy8nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgZ2xvYmFsIGBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5YCBmdW5jdGlvbiBmb3IgYm9vdHN0cmFwcGluZy5cbiAgICAgKiBUaGlzIGlzIGVzc2VudGlhbGx5IGEgZm9ybWF0dGVkIHZlcnNpb24gb2YgdGhlIGR5bmFtaWMgbG9hZGluZyBzY3JpcHRcbiAgICAgKiBmcm9tIHRoZSBvZmZpY2lhbCBkb2N1bWVudGF0aW9uIHdpdGggc29tZSBtaW5vciBhZGp1c3RtZW50cy5cbiAgICAgKlxuICAgICAqIFRoZSBjcmVhdGVkIGltcG9ydExpYnJhcnkgZnVuY3Rpb24gd2lsbCBsb2FkIHRoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSSxcbiAgICAgKiB3aGljaCB3aWxsIHRoZW4gcmVwbGFjZSB0aGUgYGdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnlgIGZ1bmN0aW9uIHdpdGggdGhlIGZ1bGxcbiAgICAgKiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvbG9hZC1tYXBzLWpzLWFwaSNkeW5hbWljLWxpYnJhcnktaW1wb3J0XG4gICAgICovXG4gICAgc3RhdGljIGluaXRJbXBvcnRMaWJyYXJ5KHBhcmFtcykge1xuICAgICAgICBpZiAoIXdpbmRvdy5nb29nbGUpXG4gICAgICAgICAgICB3aW5kb3cuZ29vZ2xlID0ge307XG4gICAgICAgIGlmICghd2luZG93Lmdvb2dsZS5tYXBzKVxuICAgICAgICAgICAgd2luZG93Lmdvb2dsZS5tYXBzID0ge307XG4gICAgICAgIGlmICh3aW5kb3cuZ29vZ2xlLm1hcHNbJ2ltcG9ydExpYnJhcnknXSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW2dvb2dsZS1tYXBzLWFwaS1sb2FkZXItaW50ZXJuYWxdOiBpbml0SW1wb3J0TGlicmFyeSBtdXN0IG9ubHkgYmUgY2FsbGVkIG9uY2UnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXBpUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGxvYWRBcGkgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXBpUHJvbWlzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpUHJvbWlzZTtcbiAgICAgICAgICAgIGFwaVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmlwdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmxQYXJhbU5hbWUgPSBrZXkucmVwbGFjZSgvW0EtWl0vZywgdCA9PiAnXycgKyB0WzBdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICB1cmxQYXJhbXMuc2V0KHVybFBhcmFtTmFtZSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVybFBhcmFtcy5zZXQoJ2xvYWRpbmcnLCAnYXN5bmMnKTtcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXMuc2V0KCdjYWxsYmFjaycsICdfX2dvb2dsZU1hcHNDYWxsYmFja19fJyk7XG4gICAgICAgICAgICAgICAgc2NyaXB0RWxlbWVudC5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2NyaXB0RWxlbWVudC5zcmMgPSBNQVBTX0FQSV9CQVNFX1VSTCArIGA/YCArIHVybFBhcmFtcy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHNjcmlwdEVsZW1lbnQubm9uY2UgPVxuICAgICAgICAgICAgICAgICAgICAoKF9hID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W25vbmNlXScpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9uY2UpIHx8ICcnO1xuICAgICAgICAgICAgICAgIHNjcmlwdEVsZW1lbnQub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gQVBJTG9hZGluZ1N0YXR1cy5GQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5TG9hZGluZ1N0YXR1c0xpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEkgY291bGQgbm90IGxvYWQuJykpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd2luZG93Ll9fZ29vZ2xlTWFwc0NhbGxiYWNrX18gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuTE9BREVEO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd2luZG93LmdtX2F1dGhGYWlsdXJlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkFVVEhfRkFJTFVSRTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMb2FkaW5nU3RhdHVzTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkxPQURJTkc7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMb2FkaW5nU3RhdHVzTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmQoc2NyaXB0RWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhcGlQcm9taXNlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBmb3IgdGhlIGZpcnN0IGxvYWQsIHdlIGRlY2xhcmUgYW4gaW1wb3J0TGlicmFyeSBmdW5jdGlvbiB0aGF0IHdpbGxcbiAgICAgICAgLy8gYmUgb3ZlcndyaXR0ZW4gb25jZSB0aGUgYXBpIGlzIGxvYWRlZC5cbiAgICAgICAgZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeSA9IGxpYnJhcnlOYW1lID0+IGxvYWRBcGkoKS50aGVuKCgpID0+IGdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnkobGlicmFyeU5hbWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgYWxsIHJlZ2lzdGVyZWQgbG9hZGluZ1N0YXR1c0xpc3RlbmVycyBhZnRlciBhIHN0YXR1cyB1cGRhdGUuXG4gICAgICovXG4gICAgc3RhdGljIG5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZm4gb2YgdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGZuKHRoaXMubG9hZGluZ1N0YXR1cyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFRoZSBjdXJyZW50IGxvYWRpbmdTdGF0dXMgb2YgdGhlIEFQSS5cbiAqL1xuR29vZ2xlTWFwc0FwaUxvYWRlci5sb2FkaW5nU3RhdHVzID0gQVBJTG9hZGluZ1N0YXR1cy5OT1RfTE9BREVEO1xuLyoqXG4gKiBBIGxpc3Qgb2YgZnVuY3Rpb25zIHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIGxvYWRpbmcgc3RhdHVzIGNoYW5nZXMuXG4gKi9cbkdvb2dsZU1hcHNBcGlMb2FkZXIubGlzdGVuZXJzID0gW107XG5cbmNvbnN0IERFRkFVTFRfU09MVVRJT05fQ0hBTk5FTCA9ICdHTVBfdmlzZ2xfcmdtbGlicmFyeV92MV9kZWZhdWx0JztcbmNvbnN0IERFRkFVTFRfSU5URVJOQUxfVVNBR0VfQVRUUklCVVRJT05fSURTID0gW1xuICAgIGBnbXBfdmlzZ2xfcmVhY3Rnb29nbGVtYXBzX3Yke1ZFUlNJT059YFxuXTtcbmNvbnN0IEFQSVByb3ZpZGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcbiAqIGxvY2FsIGhvb2sgdG8gc2V0IHVwIHRoZSBtYXAtaW5zdGFuY2UgbWFuYWdlbWVudCBjb250ZXh0LlxuICovXG5mdW5jdGlvbiB1c2VNYXBJbnN0YW5jZXMoKSB7XG4gICAgY29uc3QgW21hcEluc3RhbmNlcywgc2V0TWFwSW5zdGFuY2VzXSA9IHVzZVN0YXRlKHt9KTtcbiAgICBjb25zdCBhZGRNYXBJbnN0YW5jZSA9IChtYXBJbnN0YW5jZSwgaWQgPSAnZGVmYXVsdCcpID0+IHtcbiAgICAgICAgc2V0TWFwSW5zdGFuY2VzKGluc3RhbmNlcyA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnN0YW5jZXMpLCB7IFtpZF06IG1hcEluc3RhbmNlIH0pKSk7XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVNYXBJbnN0YW5jZSA9IChpZCA9ICdkZWZhdWx0JykgPT4ge1xuICAgICAgICBzZXRNYXBJbnN0YW5jZXMoKF9hKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2IgPSBpZDsgX2FbX2JdOyB2YXIgcmVtYWluaW5nID0gX19yZXN0KF9hLCBbdHlwZW9mIF9iID09PSBcInN5bWJvbFwiID8gX2IgOiBfYiArIFwiXCJdKTtcbiAgICAgICAgICAgIHJldHVybiByZW1haW5pbmc7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgY2xlYXJNYXBJbnN0YW5jZXMgPSAoKSA9PiB7XG4gICAgICAgIHNldE1hcEluc3RhbmNlcyh7fSk7XG4gICAgfTtcbiAgICByZXR1cm4geyBtYXBJbnN0YW5jZXMsIGFkZE1hcEluc3RhbmNlLCByZW1vdmVNYXBJbnN0YW5jZSwgY2xlYXJNYXBJbnN0YW5jZXMgfTtcbn1cbi8qKlxuICogbG9jYWwgaG9vayB0byBoYW5kbGUgdGhlIGxvYWRpbmcgb2YgdGhlIG1hcHMgQVBJLCByZXR1cm5zIHRoZSBjdXJyZW50IGxvYWRpbmcgc3RhdHVzXG4gKiBAcGFyYW0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gdXNlR29vZ2xlTWFwc0FwaUxvYWRlcihwcm9wcykge1xuICAgIGNvbnN0IHsgb25Mb2FkLCBvbkVycm9yLCBhcGlLZXksIHZlcnNpb24sIGxpYnJhcmllcyA9IFtdIH0gPSBwcm9wcywgb3RoZXJBcGlQYXJhbXMgPSBfX3Jlc3QocHJvcHMsIFtcIm9uTG9hZFwiLCBcIm9uRXJyb3JcIiwgXCJhcGlLZXlcIiwgXCJ2ZXJzaW9uXCIsIFwibGlicmFyaWVzXCJdKTtcbiAgICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gdXNlU3RhdGUoR29vZ2xlTWFwc0FwaUxvYWRlci5sb2FkaW5nU3RhdHVzKTtcbiAgICBjb25zdCBbbG9hZGVkTGlicmFyaWVzLCBhZGRMb2FkZWRMaWJyYXJ5XSA9IHVzZVJlZHVjZXIoKGxvYWRlZExpYnJhcmllcywgYWN0aW9uKSA9PiB7XG4gICAgICAgIHJldHVybiBsb2FkZWRMaWJyYXJpZXNbYWN0aW9uLm5hbWVdXG4gICAgICAgICAgICA/IGxvYWRlZExpYnJhcmllc1xuICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvYWRlZExpYnJhcmllcyksIHsgW2FjdGlvbi5uYW1lXTogYWN0aW9uLnZhbHVlIH0pO1xuICAgIH0sIHt9KTtcbiAgICBjb25zdCBsaWJyYXJpZXNTdHJpbmcgPSB1c2VNZW1vKCgpID0+IGxpYnJhcmllcyA9PT0gbnVsbCB8fCBsaWJyYXJpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpYnJhcmllcy5qb2luKCcsJyksIFtsaWJyYXJpZXNdKTtcbiAgICBjb25zdCBzZXJpYWxpemVkUGFyYW1zID0gdXNlTWVtbygoKSA9PiBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKHsgYXBpS2V5LCB2ZXJzaW9uIH0sIG90aGVyQXBpUGFyYW1zKSksIFthcGlLZXksIHZlcnNpb24sIG90aGVyQXBpUGFyYW1zXSk7XG4gICAgY29uc3QgaW1wb3J0TGlicmFyeSA9IHVzZUNhbGxiYWNrKChuYW1lKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGxvYWRlZExpYnJhcmllc1tuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlZExpYnJhcmllc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgoX2EgPSBnb29nbGUgPT09IG51bGwgfHwgZ29vZ2xlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnb29nbGUubWFwcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmltcG9ydExpYnJhcnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1thcGktcHJvdmlkZXItaW50ZXJuYWxdIGltcG9ydExpYnJhcnkgd2FzIGNhbGxlZCBiZWZvcmUgJyArXG4gICAgICAgICAgICAgICAgJ2dvb2dsZS5tYXBzLmltcG9ydExpYnJhcnkgd2FzIGRlZmluZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0geWllbGQgd2luZG93Lmdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnkobmFtZSk7XG4gICAgICAgIGFkZExvYWRlZExpYnJhcnkoeyBuYW1lLCB2YWx1ZTogcmVzIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0pLCBbbG9hZGVkTGlicmFyaWVzXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7IGtleTogYXBpS2V5IH0sIG90aGVyQXBpUGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbilcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnYgPSB2ZXJzaW9uO1xuICAgICAgICAgICAgICAgIGlmICgobGlicmFyaWVzU3RyaW5nID09PSBudWxsIHx8IGxpYnJhcmllc1N0cmluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlicmFyaWVzU3RyaW5nLmxlbmd0aCkgPiAwKVxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMubGlicmFyaWVzID0gbGlicmFyaWVzU3RyaW5nO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuY2hhbm5lbCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jaGFubmVsIDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY2hhbm5lbCA+IDk5OSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy5jaGFubmVsO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuc29sdXRpb25DaGFubmVsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zb2x1dGlvbkNoYW5uZWwgPSBERUZBVUxUX1NPTFVUSU9OX0NIQU5ORUw7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1zLnNvbHV0aW9uQ2hhbm5lbCA9PT0gJycpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMuc29sdXRpb25DaGFubmVsO1xuICAgICAgICAgICAgICAgIHlpZWxkIEdvb2dsZU1hcHNBcGlMb2FkZXIubG9hZChwYXJhbXMsIHN0YXR1cyA9PiBzZXRTdGF0dXMoc3RhdHVzKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIFsnY29yZScsICdtYXBzJywgLi4ubGlicmFyaWVzXSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBpbXBvcnRMaWJyYXJ5KG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uTG9hZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignPEFwaVByb3ZpZGVyPiBmYWlsZWQgdG8gbG9hZCB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEknLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSkoKTtcbiAgICB9LCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW2FwaUtleSwgbGlicmFyaWVzU3RyaW5nLCBzZXJpYWxpemVkUGFyYW1zXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBsb2FkZWRMaWJyYXJpZXMsXG4gICAgICAgIGltcG9ydExpYnJhcnlcbiAgICB9O1xufVxuZnVuY3Rpb24gdXNlSW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzKHByb3BzKSB7XG4gICAgY29uc3QgaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzID0gdXNlTWVtbygoKSA9PiBwcm9wcy5kaXNhYmxlVXNhZ2VBdHRyaWJ1dGlvblxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBERUZBVUxUX0lOVEVSTkFMX1VTQUdFX0FUVFJJQlVUSU9OX0lEUywgW3Byb3BzLmRpc2FibGVVc2FnZUF0dHJpYnV0aW9uXSk7XG4gICAgcmV0dXJuIGludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcztcbn1cbi8qKlxuICogQ29tcG9uZW50IHRvIHdyYXAgdGhlIGNvbXBvbmVudHMgZnJvbSB0aGlzIGxpYnJhcnkgYW5kIGxvYWQgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJXG4gKi9cbmNvbnN0IEFQSVByb3ZpZGVyID0gcHJvcHMgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHByb3BzLCBsb2FkZXJQcm9wcyA9IF9fcmVzdChwcm9wcywgW1wiY2hpbGRyZW5cIl0pO1xuICAgIGNvbnN0IHsgbWFwSW5zdGFuY2VzLCBhZGRNYXBJbnN0YW5jZSwgcmVtb3ZlTWFwSW5zdGFuY2UsIGNsZWFyTWFwSW5zdGFuY2VzIH0gPSB1c2VNYXBJbnN0YW5jZXMoKTtcbiAgICBjb25zdCB7IHN0YXR1cywgbG9hZGVkTGlicmFyaWVzLCBpbXBvcnRMaWJyYXJ5IH0gPSB1c2VHb29nbGVNYXBzQXBpTG9hZGVyKGxvYWRlclByb3BzKTtcbiAgICBjb25zdCBpbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHMgPSB1c2VJbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHMobG9hZGVyUHJvcHMpO1xuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgbWFwSW5zdGFuY2VzLFxuICAgICAgICBhZGRNYXBJbnN0YW5jZSxcbiAgICAgICAgcmVtb3ZlTWFwSW5zdGFuY2UsXG4gICAgICAgIGNsZWFyTWFwSW5zdGFuY2VzLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGxvYWRlZExpYnJhcmllcyxcbiAgICAgICAgaW1wb3J0TGlicmFyeSxcbiAgICAgICAgaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzXG4gICAgfSksIFtcbiAgICAgICAgbWFwSW5zdGFuY2VzLFxuICAgICAgICBhZGRNYXBJbnN0YW5jZSxcbiAgICAgICAgcmVtb3ZlTWFwSW5zdGFuY2UsXG4gICAgICAgIGNsZWFyTWFwSW5zdGFuY2VzLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGxvYWRlZExpYnJhcmllcyxcbiAgICAgICAgaW1wb3J0TGlicmFyeSxcbiAgICAgICAgaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzXG4gICAgXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEFQSVByb3ZpZGVyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dFZhbHVlIH0sIGNoaWxkcmVuKSk7XG59O1xuXG4vKipcbiAqIFNldHMgdXAgZWZmZWN0cyB0byBiaW5kIGV2ZW50LWhhbmRsZXJzIGZvciBhbGwgZXZlbnQtcHJvcHMgaW4gTWFwRXZlbnRQcm9wcy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VNYXBFdmVudHMobWFwLCBwcm9wcykge1xuICAgIC8vIG5vdGU6IGNhbGxpbmcgYSB1c2VFZmZlY3QgaG9vayBmcm9tIHdpdGhpbiBhIGxvb3AgaXMgcHJvaGliaXRlZCBieSB0aGVcbiAgICAvLyBydWxlcyBvZiBob29rcywgYnV0IGl0J3Mgb2sgaGVyZSBzaW5jZSBpdCdzIHVuY29uZGl0aW9uYWwgYW5kIHRoZSBudW1iZXJcbiAgICAvLyBhbmQgb3JkZXIgb2YgaXRlcmF0aW9ucyBpcyBhbHdheXMgc3RyaWN0bHkgdGhlIHNhbWUuXG4gICAgLy8gKHNlZSBodHRwczovL2xlZ2FjeS5yZWFjdGpzLm9yZy9kb2NzL2hvb2tzLXJ1bGVzLmh0bWwpXG4gICAgZm9yIChjb25zdCBwcm9wTmFtZSBvZiBldmVudFByb3BOYW1lcykge1xuICAgICAgICAvLyBmaXhtZTogdGhpcyBjYXN0IGlzIGVzc2VudGlhbGx5IGEgJ3RydXN0IG1lLCBicm8nIGZvciB0eXBlc2NyaXB0LCBidXRcbiAgICAgICAgLy8gICBhIHByb3BlciBzb2x1dGlvbiBzZWVtcyB3YXkgdG9vIGNvbXBsaWNhdGVkIHJpZ2h0IG5vd1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICBjb25zdCBldmVudFR5cGUgPSBwcm9wTmFtZVRvRXZlbnRUeXBlW3Byb3BOYW1lXTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1hcClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsIGV2ZW50VHlwZSwgKGV2KSA9PiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcihjcmVhdGVNYXBFdmVudChldmVudFR5cGUsIG1hcCwgZXYpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IGxpc3RlbmVyLnJlbW92ZSgpO1xuICAgICAgICB9LCBbbWFwLCBldmVudFR5cGUsIGhhbmRsZXJdKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgd3JhcHBlZCBtYXAtZXZlbnRzIHVzZWQgZm9yIHRoZSBldmVudC1wcm9wcy5cbiAqIEBwYXJhbSB0eXBlIHRoZSBldmVudCB0eXBlIGFzIGl0IGlzIHNwZWNpZmllZCB0byB0aGUgbWFwcyBhcGlcbiAqIEBwYXJhbSBtYXAgdGhlIG1hcCBpbnN0YW5jZSB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tXG4gKiBAcGFyYW0gc3JjRXZlbnQgdGhlIHNvdXJjZS1ldmVudCBpZiB0aGVyZSBpcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1hcEV2ZW50KHR5cGUsIG1hcCwgc3JjRXZlbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZXYgPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIG1hcCxcbiAgICAgICAgZGV0YWlsOiB7fSxcbiAgICAgICAgc3RvcHBhYmxlOiBmYWxzZSxcbiAgICAgICAgc3RvcDogKCkgPT4geyB9XG4gICAgfTtcbiAgICBpZiAoY2FtZXJhRXZlbnRUeXBlcy5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgICBjb25zdCBjYW1FdmVudCA9IGV2O1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7XG4gICAgICAgIGNvbnN0IHpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuICAgICAgICBjb25zdCBoZWFkaW5nID0gbWFwLmdldEhlYWRpbmcoKSB8fCAwO1xuICAgICAgICBjb25zdCB0aWx0ID0gbWFwLmdldFRpbHQoKSB8fCAwO1xuICAgICAgICBjb25zdCBib3VuZHMgPSBtYXAuZ2V0Qm91bmRzKCk7XG4gICAgICAgIGlmICghY2VudGVyIHx8ICFib3VuZHMgfHwgIU51bWJlci5pc0Zpbml0ZSh6b29tKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbY3JlYXRlRXZlbnRdIGF0IGxlYXN0IG9uZSBvZiB0aGUgdmFsdWVzIGZyb20gdGhlIG1hcCAnICtcbiAgICAgICAgICAgICAgICAncmV0dXJuZWQgdW5kZWZpbmVkLiBUaGlzIGlzIG5vdCBleHBlY3RlZCB0byBoYXBwZW4uIFBsZWFzZSAnICtcbiAgICAgICAgICAgICAgICAncmVwb3J0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS92aXNnbC9yZWFjdC1nb29nbGUtbWFwcy9pc3N1ZXMvbmV3Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FtRXZlbnQuZGV0YWlsID0ge1xuICAgICAgICAgICAgY2VudGVyOiAoY2VudGVyID09PSBudWxsIHx8IGNlbnRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VudGVyLnRvSlNPTigpKSB8fCB7IGxhdDogMCwgbG5nOiAwIH0sXG4gICAgICAgICAgICB6b29tOiB6b29tIHx8IDAsXG4gICAgICAgICAgICBoZWFkaW5nOiBoZWFkaW5nLFxuICAgICAgICAgICAgdGlsdDogdGlsdCxcbiAgICAgICAgICAgIGJvdW5kczogKGJvdW5kcyA9PT0gbnVsbCB8fCBib3VuZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvdW5kcy50b0pTT04oKSkgfHwge1xuICAgICAgICAgICAgICAgIG5vcnRoOiA5MCxcbiAgICAgICAgICAgICAgICBlYXN0OiAxODAsXG4gICAgICAgICAgICAgICAgc291dGg6IC05MCxcbiAgICAgICAgICAgICAgICB3ZXN0OiAtMTgwXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYW1FdmVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAobW91c2VFdmVudFR5cGVzLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgIGlmICghc3JjRXZlbnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tjcmVhdGVFdmVudF0gbW91c2UgZXZlbnRzIG11c3QgcHJvdmlkZSBhIHNyY0V2ZW50Jyk7XG4gICAgICAgIGNvbnN0IG1vdXNlRXZlbnQgPSBldjtcbiAgICAgICAgbW91c2VFdmVudC5kb21FdmVudCA9IHNyY0V2ZW50LmRvbUV2ZW50O1xuICAgICAgICBtb3VzZUV2ZW50LnN0b3BwYWJsZSA9IHRydWU7XG4gICAgICAgIG1vdXNlRXZlbnQuc3RvcCA9ICgpID0+IHNyY0V2ZW50LnN0b3AoKTtcbiAgICAgICAgbW91c2VFdmVudC5kZXRhaWwgPSB7XG4gICAgICAgICAgICBsYXRMbmc6ICgoX2EgPSBzcmNFdmVudC5sYXRMbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0pTT04oKSkgfHwgbnVsbCxcbiAgICAgICAgICAgIHBsYWNlSWQ6IHNyY0V2ZW50LnBsYWNlSWRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1vdXNlRXZlbnQ7XG4gICAgfVxuICAgIHJldHVybiBldjtcbn1cbi8qKlxuICogbWFwcyB0aGUgY2FtZWxDYXNlZCBuYW1lcyBvZiBldmVudC1wcm9wcyB0byB0aGUgY29ycmVzcG9uZGluZyBldmVudC10eXBlc1xuICogdXNlZCBpbiB0aGUgbWFwcyBBUEkuXG4gKi9cbmNvbnN0IHByb3BOYW1lVG9FdmVudFR5cGUgPSB7XG4gICAgb25Cb3VuZHNDaGFuZ2VkOiAnYm91bmRzX2NoYW5nZWQnLFxuICAgIG9uQ2VudGVyQ2hhbmdlZDogJ2NlbnRlcl9jaGFuZ2VkJyxcbiAgICBvbkNsaWNrOiAnY2xpY2snLFxuICAgIG9uQ29udGV4dG1lbnU6ICdjb250ZXh0bWVudScsXG4gICAgb25EYmxjbGljazogJ2RibGNsaWNrJyxcbiAgICBvbkRyYWc6ICdkcmFnJyxcbiAgICBvbkRyYWdlbmQ6ICdkcmFnZW5kJyxcbiAgICBvbkRyYWdzdGFydDogJ2RyYWdzdGFydCcsXG4gICAgb25IZWFkaW5nQ2hhbmdlZDogJ2hlYWRpbmdfY2hhbmdlZCcsXG4gICAgb25JZGxlOiAnaWRsZScsXG4gICAgb25Jc0ZyYWN0aW9uYWxab29tRW5hYmxlZENoYW5nZWQ6ICdpc2ZyYWN0aW9uYWx6b29tZW5hYmxlZF9jaGFuZ2VkJyxcbiAgICBvbk1hcENhcGFiaWxpdGllc0NoYW5nZWQ6ICdtYXBjYXBhYmlsaXRpZXNfY2hhbmdlZCcsXG4gICAgb25NYXBUeXBlSWRDaGFuZ2VkOiAnbWFwdHlwZWlkX2NoYW5nZWQnLFxuICAgIG9uTW91c2Vtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgICBvbk1vdXNlb3V0OiAnbW91c2VvdXQnLFxuICAgIG9uTW91c2VvdmVyOiAnbW91c2VvdmVyJyxcbiAgICBvblByb2plY3Rpb25DaGFuZ2VkOiAncHJvamVjdGlvbl9jaGFuZ2VkJyxcbiAgICBvblJlbmRlcmluZ1R5cGVDaGFuZ2VkOiAncmVuZGVyaW5ndHlwZV9jaGFuZ2VkJyxcbiAgICBvblRpbGVzTG9hZGVkOiAndGlsZXNsb2FkZWQnLFxuICAgIG9uVGlsdENoYW5nZWQ6ICd0aWx0X2NoYW5nZWQnLFxuICAgIG9uWm9vbUNoYW5nZWQ6ICd6b29tX2NoYW5nZWQnLFxuICAgIC8vIG5vdGU6IG9uQ2FtZXJhQ2hhbmdlZCBpcyBhbiBhbGlhcyBmb3IgdGhlIGJvdW5kc19jaGFuZ2VkIGV2ZW50LFxuICAgIC8vIHNpbmNlIHRoYXQgaXMgZ29pbmcgdG8gYmUgZmlyZWQgaW4gZXZlcnkgc2l0dWF0aW9uIHdoZXJlIHRoZSBjYW1lcmEgaXNcbiAgICAvLyB1cGRhdGVkLlxuICAgIG9uQ2FtZXJhQ2hhbmdlZDogJ2JvdW5kc19jaGFuZ2VkJ1xufTtcbmNvbnN0IGNhbWVyYUV2ZW50VHlwZXMgPSBbXG4gICAgJ2JvdW5kc19jaGFuZ2VkJyxcbiAgICAnY2VudGVyX2NoYW5nZWQnLFxuICAgICdoZWFkaW5nX2NoYW5nZWQnLFxuICAgICd0aWx0X2NoYW5nZWQnLFxuICAgICd6b29tX2NoYW5nZWQnXG5dO1xuY29uc3QgbW91c2VFdmVudFR5cGVzID0gW1xuICAgICdjbGljaycsXG4gICAgJ2NvbnRleHRtZW51JyxcbiAgICAnZGJsY2xpY2snLFxuICAgICdtb3VzZW1vdmUnLFxuICAgICdtb3VzZW91dCcsXG4gICAgJ21vdXNlb3Zlcidcbl07XG5jb25zdCBldmVudFByb3BOYW1lcyA9IE9iamVjdC5rZXlzKHByb3BOYW1lVG9FdmVudFR5cGUpO1xuXG4vKipcbiAqIEEgaG9vayB0byBzdG9yZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgYSB2YXJpYWJsZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc3RvcmVcbiAqIEByZXR1cm5zIFRoZSBwcmV2aW91cyB2YWx1ZVxuICovXG5mdW5jdGlvbiB1c2VQcmV2aW91cyh2YWx1ZSkge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZih1bmRlZmluZWQpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgfSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3JlZnNcbiAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW9pemVkKHZhbHVlLCBpc0VxdWFsKSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSB1c2VQcmV2aW91cyh2YWx1ZSk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAocHJldmlvdXMgJiYgaXNFcXVhbChwcmV2aW91cywgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIFt2YWx1ZSwgcHJldmlvdXMsIGlzRXF1YWxdKTtcbn1cblxuZnVuY3Rpb24gdXNlQ3VzdG9tQ29tcGFyZUVmZmVjdChlZmZlY3QsIGRlcGVuZGVuY2llcywgaXNFcXVhbCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB1c2VFZmZlY3QoZWZmZWN0LCBbdXNlTWVtb2l6ZWQoZGVwZW5kZW5jaWVzLCBpc0VxdWFsKV0pO1xufVxuXG5mdW5jdGlvbiB1c2VEZWVwQ29tcGFyZUVmZmVjdChlZmZlY3QsIGRlcGVuZGVuY2llcykge1xuICAgIHVzZUN1c3RvbUNvbXBhcmVFZmZlY3QoZWZmZWN0LCBkZXBlbmRlbmNpZXMsIGlzRGVlcEVxdWFsKTtcbn1cblxuY29uc3QgbWFwT3B0aW9uS2V5cyA9IG5ldyBTZXQoW1xuICAgICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgICdjbGlja2FibGVJY29ucycsXG4gICAgJ2NvbnRyb2xTaXplJyxcbiAgICAnZGlzYWJsZURlZmF1bHRVSScsXG4gICAgJ2Rpc2FibGVEb3VibGVDbGlja1pvb20nLFxuICAgICdkcmFnZ2FibGUnLFxuICAgICdkcmFnZ2FibGVDdXJzb3InLFxuICAgICdkcmFnZ2luZ0N1cnNvcicsXG4gICAgJ2Z1bGxzY3JlZW5Db250cm9sJyxcbiAgICAnZnVsbHNjcmVlbkNvbnRyb2xPcHRpb25zJyxcbiAgICAnZ2VzdHVyZUhhbmRsaW5nJyxcbiAgICAnaGVhZGluZ0ludGVyYWN0aW9uRW5hYmxlZCcsXG4gICAgJ2lzRnJhY3Rpb25hbFpvb21FbmFibGVkJyxcbiAgICAna2V5Ym9hcmRTaG9ydGN1dHMnLFxuICAgICdtYXBUeXBlQ29udHJvbCcsXG4gICAgJ21hcFR5cGVDb250cm9sT3B0aW9ucycsXG4gICAgJ21hcFR5cGVJZCcsXG4gICAgJ21heFpvb20nLFxuICAgICdtaW5ab29tJyxcbiAgICAnbm9DbGVhcicsXG4gICAgJ3BhbkNvbnRyb2wnLFxuICAgICdwYW5Db250cm9sT3B0aW9ucycsXG4gICAgJ3Jlc3RyaWN0aW9uJyxcbiAgICAncm90YXRlQ29udHJvbCcsXG4gICAgJ3JvdGF0ZUNvbnRyb2xPcHRpb25zJyxcbiAgICAnc2NhbGVDb250cm9sJyxcbiAgICAnc2NhbGVDb250cm9sT3B0aW9ucycsXG4gICAgJ3Njcm9sbHdoZWVsJyxcbiAgICAnc3RyZWV0VmlldycsXG4gICAgJ3N0cmVldFZpZXdDb250cm9sJyxcbiAgICAnc3RyZWV0Vmlld0NvbnRyb2xPcHRpb25zJyxcbiAgICAnc3R5bGVzJyxcbiAgICAndGlsdEludGVyYWN0aW9uRW5hYmxlZCcsXG4gICAgJ3pvb21Db250cm9sJyxcbiAgICAnem9vbUNvbnRyb2xPcHRpb25zJ1xuXSk7XG4vKipcbiAqIEludGVybmFsIGhvb2sgdG8gdXBkYXRlIHRoZSBtYXAtb3B0aW9ucyB3aGVuIHByb3BzIGFyZSBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSBtYXAgdGhlIG1hcCBpbnN0YW5jZVxuICogQHBhcmFtIG1hcFByb3BzIHRoZSBwcm9wcyB0byB1cGRhdGUgdGhlIG1hcC1pbnN0YW5jZSB3aXRoXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlTWFwT3B0aW9ucyhtYXAsIG1hcFByb3BzKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzIC0tXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIGVmZmVjdHMgYXJlbid0IHRyaWdnZXJlZCB3aGVuIHRoZSBtYXAgaXMgY2hhbmdlZC5cbiAgICAgKiBJbiB0aGF0IGNhc2UsIHRoZSB2YWx1ZXMgd2lsbCBiZSBvciBoYXZlIGJlZW4gcGFzc2VkIHRvIHRoZSBtYXBcbiAgICAgKiBjb25zdHJ1Y3RvciB2aWEgbWFwT3B0aW9ucy5cbiAgICAgKi9cbiAgICBjb25zdCBtYXBPcHRpb25zID0ge307XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG1hcFByb3BzKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGlmICghbWFwT3B0aW9uS2V5cy5oYXMoa2V5KSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBtYXBPcHRpb25zW2tleV0gPSBtYXBQcm9wc1trZXldO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgdGhlIG1hcCBvcHRpb25zIHdoZW4gbWFwT3B0aW9ucyBpcyBjaGFuZ2VkXG4gICAgLy8gTm90ZTogZHVlIHRvIHRoZSBkZXN0cnVjdHVyaW5nIGFib3ZlLCBtYXBPcHRpb25zIHdpbGwgYmUgc2VlbiBhcyBjaGFuZ2VkXG4gICAgLy8gICB3aXRoIGV2ZXJ5IHJlLXJlbmRlciwgc28gd2UncmUgYXNzdW1pbmcgdGhlIG1hcHMtYXBpIHdpbGwgcHJvcGVybHlcbiAgICAvLyAgIGRlYWwgd2l0aCB1bmNoYW5nZWQgb3B0aW9uLXZhbHVlcyBwYXNzZWQgaW50byBzZXRPcHRpb25zLlxuICAgIHVzZURlZXBDb21wYXJlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG1hcC5zZXRPcHRpb25zKG1hcE9wdGlvbnMpO1xuICAgIH0sIFttYXBPcHRpb25zXSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgKi9cbn1cblxuZnVuY3Rpb24gdXNlQXBpTG9hZGluZ1N0YXR1cygpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB1c2VDb250ZXh0KEFQSVByb3ZpZGVyQ29udGV4dCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0dXMpIHx8IEFQSUxvYWRpbmdTdGF0dXMuTk9UX0xPQURFRDtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBob29rIHRoYXQgdXBkYXRlcyB0aGUgY2FtZXJhIHdoZW4gZGVjay5nbCB2aWV3U3RhdGUgY2hhbmdlcy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VEZWNrR0xDYW1lcmFVcGRhdGUobWFwLCBwcm9wcykge1xuICAgIGNvbnN0IHsgdmlld3BvcnQsIHZpZXdTdGF0ZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgaXNEZWNrR2xDb250cm9sbGVkID0gISF2aWV3cG9ydDtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcCB8fCAhdmlld1N0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGxhdGl0dWRlLCBsb25naXR1ZGUsIGJlYXJpbmc6IGhlYWRpbmcsIHBpdGNoOiB0aWx0LCB6b29tIH0gPSB2aWV3U3RhdGU7XG4gICAgICAgIG1hcC5tb3ZlQ2FtZXJhKHtcbiAgICAgICAgICAgIGNlbnRlcjogeyBsYXQ6IGxhdGl0dWRlLCBsbmc6IGxvbmdpdHVkZSB9LFxuICAgICAgICAgICAgaGVhZGluZyxcbiAgICAgICAgICAgIHRpbHQsXG4gICAgICAgICAgICB6b29tOiB6b29tICsgMVxuICAgICAgICB9KTtcbiAgICB9LCBbbWFwLCB2aWV3U3RhdGVdKTtcbiAgICByZXR1cm4gaXNEZWNrR2xDb250cm9sbGVkO1xufVxuXG5mdW5jdGlvbiBpc0xhdExuZ0xpdGVyYWwob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoISgnbGF0JyBpbiBvYmogJiYgJ2xuZycgaW4gb2JqKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUob2JqLmxhdCkgJiYgTnVtYmVyLmlzRmluaXRlKG9iai5sbmcpO1xufVxuZnVuY3Rpb24gbGF0TG5nRXF1YWxzKGEsIGIpIHtcbiAgICBpZiAoIWEgfHwgIWIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBBID0gdG9MYXRMbmdMaXRlcmFsKGEpO1xuICAgIGNvbnN0IEIgPSB0b0xhdExuZ0xpdGVyYWwoYik7XG4gICAgaWYgKEEubGF0ICE9PSBCLmxhdCB8fCBBLmxuZyAhPT0gQi5sbmcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRvTGF0TG5nTGl0ZXJhbChvYmopIHtcbiAgICBpZiAoaXNMYXRMbmdMaXRlcmFsKG9iaikpXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIG9iai50b0pTT04oKTtcbn1cblxuZnVuY3Rpb24gdXNlTWFwQ2FtZXJhUGFyYW1zKG1hcCwgY2FtZXJhU3RhdGVSZWYsIG1hcFByb3BzKSB7XG4gICAgY29uc3QgY2VudGVyID0gbWFwUHJvcHMuY2VudGVyID8gdG9MYXRMbmdMaXRlcmFsKG1hcFByb3BzLmNlbnRlcikgOiBudWxsO1xuICAgIGxldCBsYXQgPSBudWxsO1xuICAgIGxldCBsbmcgPSBudWxsO1xuICAgIGlmIChjZW50ZXIgJiYgTnVtYmVyLmlzRmluaXRlKGNlbnRlci5sYXQpICYmIE51bWJlci5pc0Zpbml0ZShjZW50ZXIubG5nKSkge1xuICAgICAgICBsYXQgPSBjZW50ZXIubGF0O1xuICAgICAgICBsbmcgPSBjZW50ZXIubG5nO1xuICAgIH1cbiAgICBjb25zdCB6b29tID0gTnVtYmVyLmlzRmluaXRlKG1hcFByb3BzLnpvb20pXG4gICAgICAgID8gbWFwUHJvcHMuem9vbVxuICAgICAgICA6IG51bGw7XG4gICAgY29uc3QgaGVhZGluZyA9IE51bWJlci5pc0Zpbml0ZShtYXBQcm9wcy5oZWFkaW5nKVxuICAgICAgICA/IG1hcFByb3BzLmhlYWRpbmdcbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IHRpbHQgPSBOdW1iZXIuaXNGaW5pdGUobWFwUHJvcHMudGlsdClcbiAgICAgICAgPyBtYXBQcm9wcy50aWx0XG4gICAgICAgIDogbnVsbDtcbiAgICAvLyB0aGUgZm9sbG93aW5nIGVmZmVjdCBydW5zIGZvciBldmVyeSByZW5kZXIgb2YgdGhlIG1hcCBjb21wb25lbnQgYW5kIGNoZWNrc1xuICAgIC8vIGlmIHRoZXJlIGFyZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSBrbm93biBzdGF0ZSBvZiB0aGUgbWFwIGluc3RhbmNlXG4gICAgLy8gKGNhbWVyYVN0YXRlUmVmLCB3aGljaCBpcyB1cGRhdGVkIGJ5IGFsbCBib3VuZHNfY2hhbmdlZCBldmVudHMpIGFuZCB0aGVcbiAgICAvLyBkZXNpcmVkIHN0YXRlIGluIHRoZSBwcm9wcy5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbmV4dENhbWVyYSA9IHt9O1xuICAgICAgICBsZXQgbmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGxhdCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgbG5nICE9PSBudWxsICYmXG4gICAgICAgICAgICAoY2FtZXJhU3RhdGVSZWYuY3VycmVudC5jZW50ZXIubGF0ICE9PSBsYXQgfHxcbiAgICAgICAgICAgICAgICBjYW1lcmFTdGF0ZVJlZi5jdXJyZW50LmNlbnRlci5sbmcgIT09IGxuZykpIHtcbiAgICAgICAgICAgIG5leHRDYW1lcmEuY2VudGVyID0geyBsYXQsIGxuZyB9O1xuICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6b29tICE9PSBudWxsICYmIGNhbWVyYVN0YXRlUmVmLmN1cnJlbnQuem9vbSAhPT0gem9vbSkge1xuICAgICAgICAgICAgbmV4dENhbWVyYS56b29tID0gem9vbTtcbiAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGluZyAhPT0gbnVsbCAmJiBjYW1lcmFTdGF0ZVJlZi5jdXJyZW50LmhlYWRpbmcgIT09IGhlYWRpbmcpIHtcbiAgICAgICAgICAgIG5leHRDYW1lcmEuaGVhZGluZyA9IGhlYWRpbmc7XG4gICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbHQgIT09IG51bGwgJiYgY2FtZXJhU3RhdGVSZWYuY3VycmVudC50aWx0ICE9PSB0aWx0KSB7XG4gICAgICAgICAgICBuZXh0Q2FtZXJhLnRpbHQgPSB0aWx0O1xuICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc1VwZGF0ZSkge1xuICAgICAgICAgICAgbWFwLm1vdmVDYW1lcmEobmV4dENhbWVyYSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuY29uc3QgQXV0aEZhaWx1cmVNZXNzYWdlID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB6SW5kZXg6IDk5OSxcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICBmbGV4RmxvdzogJ2NvbHVtbiBub3dyYXAnLFxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgIGZvbnRTaXplOiAnLjhyZW0nLFxuICAgICAgICBjb2xvcjogJ3JnYmEoMCwwLDAsMC42KScsXG4gICAgICAgIGJhY2tncm91bmQ6ICcjZGRkZGRkJyxcbiAgICAgICAgcGFkZGluZzogJzFyZW0gMS41cmVtJ1xuICAgIH07XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHN0eWxlIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCBudWxsLCBcIkVycm9yOiBBdXRoRmFpbHVyZVwiKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCxcbiAgICAgICAgICAgIFwiQSBwcm9ibGVtIHdpdGggeW91ciBBUEkga2V5IHByZXZlbnRzIHRoZSBtYXAgZnJvbSByZW5kZXJpbmcgY29ycmVjdGx5LiBQbGVhc2UgbWFrZSBzdXJlIHRoZSB2YWx1ZSBvZiB0aGUgXCIsXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCBudWxsLCBcIkFQSVByb3ZpZGVyLmFwaUtleVwiKSxcbiAgICAgICAgICAgIFwiIHByb3AgaXMgY29ycmVjdC4gQ2hlY2sgdGhlIGVycm9yLW1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUgZm9yIGZ1cnRoZXIgZGV0YWlscy5cIikpKTtcbn07XG5cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrUmVmKCkge1xuICAgIGNvbnN0IFtlbCwgc2V0RWxdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgcmVmID0gdXNlQ2FsbGJhY2soKHZhbHVlKSA9PiBzZXRFbCh2YWx1ZSksIFtzZXRFbF0pO1xuICAgIHJldHVybiBbZWwsIHJlZl07XG59XG5cbi8qKlxuICogSG9vayB0byBjaGVjayBpZiB0aGUgTWFwcyBKYXZhU2NyaXB0IEFQSSBpcyBsb2FkZWRcbiAqL1xuZnVuY3Rpb24gdXNlQXBpSXNMb2FkZWQoKSB7XG4gICAgY29uc3Qgc3RhdHVzID0gdXNlQXBpTG9hZGluZ1N0YXR1cygpO1xuICAgIHJldHVybiBzdGF0dXMgPT09IEFQSUxvYWRpbmdTdGF0dXMuTE9BREVEO1xufVxuXG5mdW5jdGlvbiB1c2VGb3JjZVVwZGF0ZSgpIHtcbiAgICBjb25zdCBbLCBmb3JjZVVwZGF0ZV0gPSB1c2VSZWR1Y2VyKHggPT4geCArIDEsIDApO1xuICAgIHJldHVybiBmb3JjZVVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQm91bmRzQ2hhbmdlKG1hcCwgcmVmKSB7XG4gICAgY29uc3QgY2VudGVyID0gbWFwLmdldENlbnRlcigpO1xuICAgIGNvbnN0IHpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuICAgIGNvbnN0IGhlYWRpbmcgPSBtYXAuZ2V0SGVhZGluZygpIHx8IDA7XG4gICAgY29uc3QgdGlsdCA9IG1hcC5nZXRUaWx0KCkgfHwgMDtcbiAgICBjb25zdCBib3VuZHMgPSBtYXAuZ2V0Qm91bmRzKCk7XG4gICAgaWYgKCFjZW50ZXIgfHwgIWJvdW5kcyB8fCAhTnVtYmVyLmlzRmluaXRlKHpvb20pKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW3VzZVRyYWNrZWRDYW1lcmFTdGF0ZV0gYXQgbGVhc3Qgb25lIG9mIHRoZSB2YWx1ZXMgZnJvbSB0aGUgbWFwICcgK1xuICAgICAgICAgICAgJ3JldHVybmVkIHVuZGVmaW5lZC4gVGhpcyBpcyBub3QgZXhwZWN0ZWQgdG8gaGFwcGVuLiBQbGVhc2UgJyArXG4gICAgICAgICAgICAncmVwb3J0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS92aXNnbC9yZWFjdC1nb29nbGUtbWFwcy9pc3N1ZXMvbmV3Jyk7XG4gICAgfVxuICAgIC8vIGZpeG1lOiBkbyB3ZSBuZWVkIHRoZSBgdW5kZWZpbmVkYCBjYXNlcyBmb3IgdGhlIGNhbWVyYS1wYXJhbXM/IFdoZW4gYXJlIHRoZXkgdXNlZCBpbiB0aGUgbWFwcyBBUEk/XG4gICAgT2JqZWN0LmFzc2lnbihyZWYuY3VycmVudCwge1xuICAgICAgICBjZW50ZXI6IChjZW50ZXIgPT09IG51bGwgfHwgY2VudGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZW50ZXIudG9KU09OKCkpIHx8IHsgbGF0OiAwLCBsbmc6IDAgfSxcbiAgICAgICAgem9vbTogem9vbSB8fCAwLFxuICAgICAgICBoZWFkaW5nOiBoZWFkaW5nLFxuICAgICAgICB0aWx0OiB0aWx0XG4gICAgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtdXRhYmxlIHJlZiBvYmplY3QgdG8gdHJhY2sgdGhlIGxhc3Qga25vd24gc3RhdGUgb2YgdGhlIG1hcCBjYW1lcmEuXG4gKiBUaGlzIGlzIHVzZWQgaW4gYHVzZU1hcENhbWVyYVBhcmFtc2AgdG8gcmVkdWNlIHN0dXR0ZXJpbmcgaW4gbm9ybWFsIG9wZXJhdGlvblxuICogYnkgYXZvaWRpbmcgdXBkYXRlcyBvZiB0aGUgbWFwIGNhbWVyYSB3aXRoIHZhbHVlcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZC5cbiAqL1xuZnVuY3Rpb24gdXNlVHJhY2tlZENhbWVyYVN0YXRlUmVmKG1hcCkge1xuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoe1xuICAgICAgICBjZW50ZXI6IHsgbGF0OiAwLCBsbmc6IDAgfSxcbiAgICAgICAgaGVhZGluZzogMCxcbiAgICAgICAgdGlsdDogMCxcbiAgICAgICAgem9vbTogMFxuICAgIH0pO1xuICAgIC8vIFJlY29yZCBjYW1lcmEgc3RhdGUgd2l0aCBldmVyeSBib3VuZHNfY2hhbmdlZCBldmVudCBkaXNwYXRjaGVkIGJ5IHRoZSBtYXAuXG4gICAgLy8gVGhpcyBkYXRhIGlzIHVzZWQgdG8gcHJldmVudCBmZWVkaW5nIHRoZXNlIHZhbHVlcyBiYWNrIHRvIHRoZVxuICAgIC8vIG1hcC1pbnN0YW5jZSB3aGVuIGEgdHlwaWNhbCBcImNvbnRyb2xsZWQgY29tcG9uZW50XCIgc2V0dXAgKHN0YXRlIHZhcmlhYmxlIGlzXG4gICAgLy8gZmVkIGludG8gYW5kIHVwZGF0ZWQgYnkgdGhlIG1hcCkuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnYm91bmRzX2NoYW5nZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVCb3VuZHNDaGFuZ2UobWFwLCByZWYpO1xuICAgICAgICAgICAgLy8gV2hlbiBhbiBldmVudCBpcyBvY2N1cmVkLCB3ZSBoYXZlIHRvIHVwZGF0ZSBkdXJpbmcgdGhlIG5leHQgY3ljbGUuXG4gICAgICAgICAgICAvLyBUaGUgYXBwbGljYXRpb24gY291bGQgZGVjaWRlIHRvIGlnbm9yZSB0aGUgZXZlbnQgYW5kIG5vdCB1cGRhdGUgYW55XG4gICAgICAgICAgICAvLyBjYW1lcmEgcHJvcHMgb2YgdGhlIG1hcCwgbWVhbmluZyB0aGF0IGluIHRoYXQgY2FzZSB3ZSB3aWxsIGhhdmUgdG9cbiAgICAgICAgICAgIC8vICd1bmRvJyB0aGUgY2hhbmdlIHRvIHRoZSBjYW1lcmEuXG4gICAgICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IGxpc3RlbmVyLnJlbW92ZSgpO1xuICAgIH0sIFttYXAsIGZvcmNlVXBkYXRlXSk7XG4gICAgcmV0dXJuIHJlZjtcbn1cblxuLyoqXG4gKiBTdG9yZXMgYSBzdGFjayBvZiBtYXAtaW5zdGFuY2VzIGZvciBlYWNoIG1hcElkLiBXaGVuZXZlciBhblxuICogaW5zdGFuY2UgaXMgdXNlZCwgaXQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzdGFjayB3aGlsZSBpbiB1c2UsXG4gKiBhbmQgcmV0dXJuZWQgdG8gdGhlIHN0YWNrIHdoZW4gdGhlIGNvbXBvbmVudCB1bm1vdW50cy5cbiAqIFRoaXMgYWxsb3dzIHVzIHRvIGNvcnJlY3RseSBpbXBsZW1lbnQgY2FjaGluZyBmb3IgbXVsdGlwbGVcbiAqIG1hcHMgb20gdGhlIHNhbWUgcGFnZSwgd2hpbGUgcmV1c2luZyBhcyBtdWNoIGFzIHBvc3NpYmxlLlxuICpcbiAqIEZJWE1FOiB3aGlsZSBpdCBzaG91bGQgaW4gdGhlb3J5IGJlIHBvc3NpYmxlIHRvIHJldXNlIG1hcHMgc29sZWx5XG4gKiAgIGJhc2VkIG9uIHRoZSBtYXBJZCAoYXMgYWxsIG90aGVyIHBhcmFtZXRlcnMgY2FuIGJlIGNoYW5nZWQgYXRcbiAqICAgcnVudGltZSksIHdlIGRvbid0IHlldCBoYXZlIGdvb2QgZW5vdWdoIHRyYWNraW5nIG9mIG9wdGlvbnMgdG9cbiAqICAgcmVsaWFibHkgdW5zZXQgYWxsIHRoZSBvcHRpb25zIHRoYXQgaGF2ZSBiZWVuIHNldC5cbiAqL1xuY2xhc3MgQ2FjaGVkTWFwU3RhY2sge1xuICAgIHN0YXRpYyBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXNba2V5XSAmJiB0aGlzLmVudHJpZXNba2V5XS5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBzdGF0aWMgcG9wKGtleSkge1xuICAgICAgICBpZiAoIXRoaXMuZW50cmllc1trZXldKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXNba2V5XS5wb3AoKSB8fCBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgcHVzaChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5lbnRyaWVzW2tleV0pXG4gICAgICAgICAgICB0aGlzLmVudHJpZXNba2V5XSA9IFtdO1xuICAgICAgICB0aGlzLmVudHJpZXNba2V5XS5wdXNoKHZhbHVlKTtcbiAgICB9XG59XG5DYWNoZWRNYXBTdGFjay5lbnRyaWVzID0ge307XG4vKipcbiAqIFRoZSBtYWluIGhvb2sgdGFrZXMgY2FyZSBvZiBjcmVhdGluZyBtYXAtaW5zdGFuY2VzIGFuZCByZWdpc3RlcmluZyB0aGVtIGluXG4gKiB0aGUgYXBpLXByb3ZpZGVyIGNvbnRleHQuXG4gKiBAcmV0dXJuIGEgdHVwbGUgb2YgdGhlIG1hcC1pbnN0YW5jZSBjcmVhdGVkIChvciBudWxsKSBhbmQgdGhlIGNhbGxiYWNrXG4gKiAgIHJlZiB0aGF0IHdpbGwgYmUgdXNlZCB0byBwYXNzIHRoZSBtYXAtY29udGFpbmVyIGludG8gdGhpcyBob29rLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZU1hcEluc3RhbmNlKHByb3BzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgYXBpSXNMb2FkZWQgPSB1c2VBcGlJc0xvYWRlZCgpO1xuICAgIGNvbnN0IFttYXAsIHNldE1hcF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbY29udGFpbmVyLCBjb250YWluZXJSZWZdID0gdXNlQ2FsbGJhY2tSZWYoKTtcbiAgICBjb25zdCBjYW1lcmFTdGF0ZVJlZiA9IHVzZVRyYWNrZWRDYW1lcmFTdGF0ZVJlZihtYXApO1xuICAgIGNvbnN0IHsgaWQsIGRlZmF1bHRCb3VuZHMsIGRlZmF1bHRDZW50ZXIsIGRlZmF1bHRab29tLCBkZWZhdWx0SGVhZGluZywgZGVmYXVsdFRpbHQsIHJldXNlTWFwcywgcmVuZGVyaW5nVHlwZSwgY29sb3JTY2hlbWUgfSA9IHByb3BzLCBtYXBPcHRpb25zID0gX19yZXN0KHByb3BzLCBbXCJpZFwiLCBcImRlZmF1bHRCb3VuZHNcIiwgXCJkZWZhdWx0Q2VudGVyXCIsIFwiZGVmYXVsdFpvb21cIiwgXCJkZWZhdWx0SGVhZGluZ1wiLCBcImRlZmF1bHRUaWx0XCIsIFwicmV1c2VNYXBzXCIsIFwicmVuZGVyaW5nVHlwZVwiLCBcImNvbG9yU2NoZW1lXCJdKTtcbiAgICBjb25zdCBoYXNab29tID0gcHJvcHMuem9vbSAhPT0gdW5kZWZpbmVkIHx8IHByb3BzLmRlZmF1bHRab29tICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgaGFzQ2VudGVyID0gcHJvcHMuY2VudGVyICE9PSB1bmRlZmluZWQgfHwgcHJvcHMuZGVmYXVsdENlbnRlciAhPT0gdW5kZWZpbmVkO1xuICAgIGlmICghZGVmYXVsdEJvdW5kcyAmJiAoIWhhc1pvb20gfHwgIWhhc0NlbnRlcikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCc8TWFwPiBjb21wb25lbnQgaXMgbWlzc2luZyBjb25maWd1cmF0aW9uLiAnICtcbiAgICAgICAgICAgICdZb3UgaGF2ZSB0byBwcm92aWRlIHpvb20gYW5kIGNlbnRlciAodmlhIHRoZSBgem9vbWAvYGRlZmF1bHRab29tYCBhbmQgJyArXG4gICAgICAgICAgICAnYGNlbnRlcmAvYGRlZmF1bHRDZW50ZXJgIHByb3BzKSBvciBzcGVjaWZ5IHRoZSByZWdpb24gdG8gc2hvdyB1c2luZyAnICtcbiAgICAgICAgICAgICdgZGVmYXVsdEJvdW5kc2AuIFNlZSAnICtcbiAgICAgICAgICAgICdodHRwczovL3Zpc2dsLmdpdGh1Yi5pby9yZWFjdC1nb29nbGUtbWFwcy9kb2NzL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9tYXAjcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgLy8gYXBwbHkgZGVmYXVsdCBjYW1lcmEgcHJvcHMgaWYgYXZhaWxhYmxlIGFuZCBub3Qgb3ZlcndyaXR0ZW4gYnkgY29udHJvbGxlZCBwcm9wc1xuICAgIGlmICghbWFwT3B0aW9ucy5jZW50ZXIgJiYgZGVmYXVsdENlbnRlcilcbiAgICAgICAgbWFwT3B0aW9ucy5jZW50ZXIgPSBkZWZhdWx0Q2VudGVyO1xuICAgIGlmICghbWFwT3B0aW9ucy56b29tICYmIE51bWJlci5pc0Zpbml0ZShkZWZhdWx0Wm9vbSkpXG4gICAgICAgIG1hcE9wdGlvbnMuem9vbSA9IGRlZmF1bHRab29tO1xuICAgIGlmICghbWFwT3B0aW9ucy5oZWFkaW5nICYmIE51bWJlci5pc0Zpbml0ZShkZWZhdWx0SGVhZGluZykpXG4gICAgICAgIG1hcE9wdGlvbnMuaGVhZGluZyA9IGRlZmF1bHRIZWFkaW5nO1xuICAgIGlmICghbWFwT3B0aW9ucy50aWx0ICYmIE51bWJlci5pc0Zpbml0ZShkZWZhdWx0VGlsdCkpXG4gICAgICAgIG1hcE9wdGlvbnMudGlsdCA9IGRlZmF1bHRUaWx0O1xuICAgIC8vIEhhbmRsZSBpbnRlcm5hbFVzYWdlQXR0cmlidXRpb25JZHNcbiAgICBjb25zdCBjdXN0b21JZHMgPSBtYXBPcHRpb25zLmludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcztcbiAgICBpZiAoY3VzdG9tSWRzID09IG51bGwpIHtcbiAgICAgICAgLy8gTm90IHNwZWNpZmllZCAtIHVzZSBjb250ZXh0IGRlZmF1bHQgKHdoaWNoIG1heSBiZSBudWxsIGlmIGRpc2FibGVkKVxuICAgICAgICBtYXBPcHRpb25zLmludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcyA9XG4gICAgICAgICAgICBjb250ZXh0LmludGVybmFsVXNhZ2VBdHRyaWJ1dGlvbklkcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE1lcmdlIGNvbnRleHQgZGVmYXVsdHMgd2l0aCBjdXN0b20gSURzXG4gICAgICAgIG1hcE9wdGlvbnMuaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzID0gW1xuICAgICAgICAgICAgLi4uKGNvbnRleHQuaW50ZXJuYWxVc2FnZUF0dHJpYnV0aW9uSWRzIHx8IFtdKSxcbiAgICAgICAgICAgIC4uLmN1c3RvbUlkc1xuICAgICAgICBdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtYXBPcHRpb25zKSlcbiAgICAgICAgaWYgKG1hcE9wdGlvbnNba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZGVsZXRlIG1hcE9wdGlvbnNba2V5XTtcbiAgICBjb25zdCBzYXZlZE1hcFN0YXRlUmVmID0gdXNlUmVmKHVuZGVmaW5lZCk7XG4gICAgLy8gY3JlYXRlIHRoZSBtYXAgaW5zdGFuY2UgYW5kIHJlZ2lzdGVyIGl0IGluIHRoZSBjb250ZXh0XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWFwaUlzTG9hZGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGFkZE1hcEluc3RhbmNlLCByZW1vdmVNYXBJbnN0YW5jZSB9ID0gY29udGV4dDtcbiAgICAgICAgLy8gbm90ZTogY29sb3JTY2hlbWUgKHVwY29taW5nIGZlYXR1cmUpIGlzbid0IHlldCBpbiB0aGUgdHlwaW5ncywgcmVtb3ZlIG9uY2UgdGhhdCBpcyBmaXhlZDpcbiAgICAgICAgY29uc3QgeyBtYXBJZCB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7bWFwSWQgfHwgJ2RlZmF1bHQnfToke3JlbmRlcmluZ1R5cGUgfHwgJ2RlZmF1bHQnfToke2NvbG9yU2NoZW1lIHx8ICdMSUdIVCd9YDtcbiAgICAgICAgbGV0IG1hcERpdjtcbiAgICAgICAgbGV0IG1hcDtcbiAgICAgICAgaWYgKHJldXNlTWFwcyAmJiBDYWNoZWRNYXBTdGFjay5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICAgICAgICBtYXAgPSBDYWNoZWRNYXBTdGFjay5wb3AoY2FjaGVLZXkpO1xuICAgICAgICAgICAgbWFwRGl2ID0gbWFwLmdldERpdigpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG1hcERpdik7XG4gICAgICAgICAgICBtYXAuc2V0T3B0aW9ucyhtYXBPcHRpb25zKTtcbiAgICAgICAgICAgIC8vIGRldGFjaGluZyB0aGUgZWxlbWVudCBmcm9tIHRoZSBET00gbGV0cyB0aGUgbWFwIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdFxuICAgICAgICAgICAgLy8gc2l6ZSwgc2V0dGluZyB0aGUgY2VudGVyIHdpbGwgdHJpZ2dlciByZWxvYWRpbmcgdGhlIG1hcC5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gbWFwLnNldENlbnRlcihtYXAuZ2V0Q2VudGVyKCkpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbWFwRGl2LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChtYXBEaXYpO1xuICAgICAgICAgICAgbWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcChtYXBEaXYsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtYXBPcHRpb25zKSwgKHJlbmRlcmluZ1R5cGVcbiAgICAgICAgICAgICAgICA/IHsgcmVuZGVyaW5nVHlwZTogcmVuZGVyaW5nVHlwZSB9XG4gICAgICAgICAgICAgICAgOiB7fSkpLCAoY29sb3JTY2hlbWVcbiAgICAgICAgICAgICAgICA/IHsgY29sb3JTY2hlbWU6IGNvbG9yU2NoZW1lIH1cbiAgICAgICAgICAgICAgICA6IHt9KSkpO1xuICAgICAgICB9XG4gICAgICAgIHNldE1hcChtYXApO1xuICAgICAgICBhZGRNYXBJbnN0YW5jZShtYXAsIGlkKTtcbiAgICAgICAgaWYgKGRlZmF1bHRCb3VuZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFkZGluZyB9ID0gZGVmYXVsdEJvdW5kcywgZGVmQm91bmRzID0gX19yZXN0KGRlZmF1bHRCb3VuZHMsIFtcInBhZGRpbmdcIl0pO1xuICAgICAgICAgICAgbWFwLmZpdEJvdW5kcyhkZWZCb3VuZHMsIHBhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByZXZlbnQgbWFwIG5vdCByZW5kZXJpbmcgZHVlIHRvIG1pc3NpbmcgY29uZmlndXJhdGlvblxuICAgICAgICBlbHNlIGlmICghaGFzWm9vbSB8fCAhaGFzQ2VudGVyKSB7XG4gICAgICAgICAgICBtYXAuZml0Qm91bmRzKHsgZWFzdDogMTgwLCB3ZXN0OiAtMTgwLCBzb3V0aDogLTkwLCBub3J0aDogOTAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIHNhdmVkTWFwU3RhdGUgaXMgdXNlZCB0byByZXN0b3JlIHRoZSBjYW1lcmEgcGFyYW1ldGVycyB3aGVuIHRoZSBtYXBJZCBpcyBjaGFuZ2VkXG4gICAgICAgIGlmIChzYXZlZE1hcFN0YXRlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbWFwSWQ6IHNhdmVkTWFwSWQsIGNhbWVyYVN0YXRlOiBzYXZlZENhbWVyYVN0YXRlIH0gPSBzYXZlZE1hcFN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoc2F2ZWRNYXBJZCAhPT0gbWFwSWQpIHtcbiAgICAgICAgICAgICAgICBtYXAuc2V0T3B0aW9ucyhzYXZlZENhbWVyYVN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgc2F2ZWRNYXBTdGF0ZVJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIG1hcElkLFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgICAgICAgICAgICBjYW1lcmFTdGF0ZTogY2FtZXJhU3RhdGVSZWYuY3VycmVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGRldGFjaCB0aGUgbWFwLWRpdiBmcm9tIHRoZSBkb21cbiAgICAgICAgICAgIG1hcERpdi5yZW1vdmUoKTtcbiAgICAgICAgICAgIGlmIChyZXVzZU1hcHMpIHtcbiAgICAgICAgICAgICAgICAvLyBwdXNoIGJhY2sgb24gdGhlIHN0YWNrXG4gICAgICAgICAgICAgICAgQ2FjaGVkTWFwU3RhY2sucHVzaChjYWNoZUtleSwgbWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgZXZlbnQtbGlzdGVuZXJzIHRvIG1pbmltaXplIHRoZSBwb3NzaWJpbGl0eSBvZiBtZW1vcnktbGVha3NcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5jbGVhckluc3RhbmNlTGlzdGVuZXJzKG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNYXAobnVsbCk7XG4gICAgICAgICAgICByZW1vdmVNYXBJbnN0YW5jZShpZCk7XG4gICAgICAgIH07XG4gICAgfSwgXG4gICAgLy8gc29tZSBkZXBlbmRlbmNpZXMgYXJlIGlnbm9yZWQgaW4gdGhlIGxpc3QgYmVsb3c6XG4gICAgLy8gIC0gZGVmYXVsdEJvdW5kcyBhbmQgdGhlIGRlZmF1bHQqIGNhbWVyYSBwcm9wcyB3aWxsIG9ubHkgYmUgdXNlZCBvbmNlLCBhbmRcbiAgICAvLyAgICBjaGFuZ2VzIHNob3VsZCBiZSBpZ25vcmVkXG4gICAgLy8gIC0gbWFwT3B0aW9ucyBoYXMgc3BlY2lhbCBob29rcyB0aGF0IHRha2UgY2FyZSBvZiB1cGRhdGluZyB0aGUgb3B0aW9uc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYXBpSXNMb2FkZWQsXG4gICAgICAgIGlkLFxuICAgICAgICAvLyB0aGVzZSBwcm9wcyBjYW4ndCBiZSBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uIGFuZCByZXF1aXJlIGEgbmV3XG4gICAgICAgIC8vIGluc3RhbmNlIHRvIGJlIGNyZWF0ZWRcbiAgICAgICAgcHJvcHMubWFwSWQsXG4gICAgICAgIHByb3BzLnJlbmRlcmluZ1R5cGUsXG4gICAgICAgIHByb3BzLmNvbG9yU2NoZW1lXG4gICAgXSk7XG4gICAgcmV0dXJuIFttYXAsIGNvbnRhaW5lclJlZiwgY2FtZXJhU3RhdGVSZWZdO1xufVxuXG5jb25zdCBHb29nbGVNYXBzQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG4vLyBDb2xvclNjaGVtZSBhbmQgUmVuZGVyaW5nVHlwZSBhcmUgcmVkZWZpbmVkIGhlcmUgdG8gbWFrZSB0aGVtIHVzYWJsZSBiZWZvcmUgdGhlXG4vLyBtYXBzIEFQSSBoYXMgYmVlbiBmdWxseSBsb2FkZWQuXG5jb25zdCBDb2xvclNjaGVtZSA9IHtcbiAgICBEQVJLOiAnREFSSycsXG4gICAgTElHSFQ6ICdMSUdIVCcsXG4gICAgRk9MTE9XX1NZU1RFTTogJ0ZPTExPV19TWVNURU0nXG59O1xuY29uc3QgUmVuZGVyaW5nVHlwZSA9IHtcbiAgICBWRUNUT1I6ICdWRUNUT1InLFxuICAgIFJBU1RFUjogJ1JBU1RFUicsXG4gICAgVU5JTklUSUFMSVpFRDogJ1VOSU5JVElBTElaRUQnXG59O1xuY29uc3QgTWFwID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgaWQsIGNsYXNzTmFtZSwgc3R5bGUgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEFQSVByb3ZpZGVyQ29udGV4dCk7XG4gICAgY29uc3QgbG9hZGluZ1N0YXR1cyA9IHVzZUFwaUxvYWRpbmdTdGF0dXMoKTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc8TWFwPiBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhbiA8QXBpUHJvdmlkZXI+IGNvbXBvbmVudC4nKTtcbiAgICB9XG4gICAgY29uc3QgW21hcCwgbWFwUmVmLCBjYW1lcmFTdGF0ZVJlZl0gPSB1c2VNYXBJbnN0YW5jZShwcm9wcywgY29udGV4dCk7XG4gICAgdXNlTWFwQ2FtZXJhUGFyYW1zKG1hcCwgY2FtZXJhU3RhdGVSZWYsIHByb3BzKTtcbiAgICB1c2VNYXBFdmVudHMobWFwLCBwcm9wcyk7XG4gICAgdXNlTWFwT3B0aW9ucyhtYXAsIHByb3BzKTtcbiAgICBjb25zdCBpc0RlY2tHbENvbnRyb2xsZWQgPSB1c2VEZWNrR0xDYW1lcmFVcGRhdGUobWFwLCBwcm9wcyk7XG4gICAgY29uc3QgaXNDb250cm9sbGVkRXh0ZXJuYWxseSA9ICEhcHJvcHMuY29udHJvbGxlZDtcbiAgICAvLyBkaXNhYmxlIGludGVyYWN0aW9ucyB3aXRoIHRoZSBtYXAgZm9yIGV4dGVybmFsbHkgY29udHJvbGxlZCBtYXBzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGZpeG1lOiB0aGlzIGRvZXNuJ3Qgc2VlbSB0byBiZWxvbmcgaGVyZSAoYW5kIGl0J3MgbW9zdGx5IHRoZXJlIGZvciBjb252ZW5pZW5jZSBhbnl3YXkpLlxuICAgICAgICAvLyAgIFRoZSByZWFzb25pbmcgaXMgdGhhdCBhIGRlY2suZ2wgY2FudmFzIHdpbGwgYmUgcHV0IG9uIHRvcCBvZiB0aGUgbWFwLCByZW5kZXJpbmdcbiAgICAgICAgLy8gICBhbnkgZGVmYXVsdCBtYXAgY29udHJvbHMgcHJldHR5IG11Y2ggdXNlbGVzc1xuICAgICAgICBpZiAoaXNEZWNrR2xDb250cm9sbGVkKSB7XG4gICAgICAgICAgICBtYXAuc2V0T3B0aW9ucyh7IGRpc2FibGVEZWZhdWx0VUk6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlzYWJsZSBhbGwgY29udHJvbC1pbnB1dHMgd2hlbiB0aGUgbWFwIGlzIGNvbnRyb2xsZWQgZXh0ZXJuYWxseVxuICAgICAgICBpZiAoaXNEZWNrR2xDb250cm9sbGVkIHx8IGlzQ29udHJvbGxlZEV4dGVybmFsbHkpIHtcbiAgICAgICAgICAgIG1hcC5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBnZXN0dXJlSGFuZGxpbmc6ICdub25lJyxcbiAgICAgICAgICAgICAgICBrZXlib2FyZFNob3J0Y3V0czogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBtYXAuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZUhhbmRsaW5nOiBwcm9wcy5nZXN0dXJlSGFuZGxpbmcsXG4gICAgICAgICAgICAgICAga2V5Ym9hcmRTaG9ydGN1dHM6IHByb3BzLmtleWJvYXJkU2hvcnRjdXRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIG1hcCxcbiAgICAgICAgaXNEZWNrR2xDb250cm9sbGVkLFxuICAgICAgICBpc0NvbnRyb2xsZWRFeHRlcm5hbGx5LFxuICAgICAgICBwcm9wcy5nZXN0dXJlSGFuZGxpbmcsXG4gICAgICAgIHByb3BzLmtleWJvYXJkU2hvcnRjdXRzXG4gICAgXSk7XG4gICAgLy8gc2V0dXAgYSBzdGFibGUgY2FtZXJhT3B0aW9ucyBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBkZXBlbmRlbmN5XG4gICAgY29uc3QgY2VudGVyID0gcHJvcHMuY2VudGVyID8gdG9MYXRMbmdMaXRlcmFsKHByb3BzLmNlbnRlcikgOiBudWxsO1xuICAgIGxldCBsYXQgPSBudWxsO1xuICAgIGxldCBsbmcgPSBudWxsO1xuICAgIGlmIChjZW50ZXIgJiYgTnVtYmVyLmlzRmluaXRlKGNlbnRlci5sYXQpICYmIE51bWJlci5pc0Zpbml0ZShjZW50ZXIubG5nKSkge1xuICAgICAgICBsYXQgPSBjZW50ZXIubGF0O1xuICAgICAgICBsbmcgPSBjZW50ZXIubG5nO1xuICAgIH1cbiAgICBjb25zdCBjYW1lcmFPcHRpb25zID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2VudGVyOiB7IGxhdDogbGF0ICE9PSBudWxsICYmIGxhdCAhPT0gdm9pZCAwID8gbGF0IDogMCwgbG5nOiBsbmcgIT09IG51bGwgJiYgbG5nICE9PSB2b2lkIDAgPyBsbmcgOiAwIH0sXG4gICAgICAgICAgICB6b29tOiAoX2EgPSBwcm9wcy56b29tKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLFxuICAgICAgICAgICAgaGVhZGluZzogKF9iID0gcHJvcHMuaGVhZGluZykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCxcbiAgICAgICAgICAgIHRpbHQ6IChfYyA9IHByb3BzLnRpbHQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDBcbiAgICAgICAgfTtcbiAgICB9LCBbbGF0LCBsbmcsIHByb3BzLnpvb20sIHByb3BzLmhlYWRpbmcsIHByb3BzLnRpbHRdKTtcbiAgICAvLyBleHRlcm5hbGx5IGNvbnRyb2xsZWQgbW9kZTogcmVqZWN0IGFsbCBjYW1lcmEgY2hhbmdlcyB0aGF0IGRvbid0IGNvcnJlc3BvbmQgdG8gY2hhbmdlcyBpbiBwcm9wc1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFwIHx8ICFpc0NvbnRyb2xsZWRFeHRlcm5hbGx5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBtYXAubW92ZUNhbWVyYShjYW1lcmFPcHRpb25zKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBtYXAuYWRkTGlzdGVuZXIoJ2JvdW5kc19jaGFuZ2VkJywgKCkgPT4ge1xuICAgICAgICAgICAgbWFwLm1vdmVDYW1lcmEoY2FtZXJhT3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgfSwgW21hcCwgaXNDb250cm9sbGVkRXh0ZXJuYWxseSwgY2FtZXJhT3B0aW9uc10pO1xuICAgIGNvbnN0IGNvbWJpbmVkU3R5bGUgPSB1c2VNZW1vKCgpID0+IChPYmplY3QuYXNzaWduKHsgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScsIHBvc2l0aW9uOiAncmVsYXRpdmUnLCBcbiAgICAgICAgLy8gd2hlbiB1c2luZyBkZWNrZ2wsIHRoZSBtYXAgc2hvdWxkIGJlIHNlbnQgdG8gdGhlIGJhY2tcbiAgICAgICAgekluZGV4OiBpc0RlY2tHbENvbnRyb2xsZWQgPyAtMSA6IDAgfSwgc3R5bGUpKSwgW3N0eWxlLCBpc0RlY2tHbENvbnRyb2xsZWRdKTtcbiAgICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+ICh7IG1hcCB9KSwgW21hcF0pO1xuICAgIGlmIChsb2FkaW5nU3RhdHVzID09PSBBUElMb2FkaW5nU3RhdHVzLkFVVEhfRkFJTFVSRSkge1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogT2JqZWN0LmFzc2lnbih7IHBvc2l0aW9uOiAncmVsYXRpdmUnIH0sIChjbGFzc05hbWUgPyB7fSA6IGNvbWJpbmVkU3R5bGUpKSwgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXV0aEZhaWx1cmVNZXNzYWdlLCBudWxsKSkpO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IHJlZjogbWFwUmVmLCBcImRhdGEtdGVzdGlkXCI6ICdtYXAnLCBzdHlsZTogY2xhc3NOYW1lID8gdW5kZWZpbmVkIDogY29tYmluZWRTdHlsZSwgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSwgKGlkID8geyBpZCB9IDoge30pKSwgbWFwID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoR29vZ2xlTWFwc0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHRWYWx1ZSB9LCBjaGlsZHJlbikpIDogbnVsbCkpO1xufTtcbi8vIFRoZSBkZWNrR0xWaWV3UHJvcHMgZmxhZyBoZXJlIGluZGljYXRlcyB0byBkZWNrLmdsIHRoYXQgdGhlIE1hcCBjb21wb25lbnQgaXNcbi8vIGFibGUgdG8gaGFuZGxlIHZpZXdQcm9wcyBmcm9tIGRlY2suZ2wgd2hlbiBkZWNrLmdsIGlzIHVzZWQgdG8gY29udHJvbCB0aGUgbWFwLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbk1hcC5kZWNrR0xWaWV3UHJvcHMgPSB0cnVlO1xuXG5jb25zdCBzaG93bk1lc3NhZ2VzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gbG9nRXJyb3JPbmNlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcbiAgICBpZiAoIXNob3duTWVzc2FnZXMuaGFzKGtleSkpIHtcbiAgICAgICAgc2hvd25NZXNzYWdlcy5hZGQoa2V5KTtcbiAgICAgICAgY29uc29sZS5lcnJvciguLi5hcmdzKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV0cmlldmVzIGEgbWFwLWluc3RhbmNlIGZyb20gdGhlIGNvbnRleHQuIFRoaXMgaXMgZWl0aGVyIGFuIGluc3RhbmNlXG4gKiBpZGVudGlmaWVkIGJ5IGlkIG9yIHRoZSBwYXJlbnQgbWFwIGluc3RhbmNlIGlmIG5vIGlkIGlzIHNwZWNpZmllZC5cbiAqIFJldHVybnMgbnVsbCBpZiBuZWl0aGVyIGNhbiBiZSBmb3VuZC5cbiAqL1xuY29uc3QgdXNlTWFwID0gKGlkID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IGN0eCA9IHVzZUNvbnRleHQoQVBJUHJvdmlkZXJDb250ZXh0KTtcbiAgICBjb25zdCB7IG1hcCB9ID0gdXNlQ29udGV4dChHb29nbGVNYXBzQ29udGV4dCkgfHwge307XG4gICAgaWYgKGN0eCA9PT0gbnVsbCkge1xuICAgICAgICBsb2dFcnJvck9uY2UoJ3VzZU1hcCgpOiBmYWlsZWQgdG8gcmV0cmlldmUgQVBJUHJvdmlkZXJDb250ZXh0LiAnICtcbiAgICAgICAgICAgICdNYWtlIHN1cmUgdGhhdCB0aGUgPEFQSVByb3ZpZGVyPiBjb21wb25lbnQgZXhpc3RzIGFuZCB0aGF0IHRoZSAnICtcbiAgICAgICAgICAgICdjb21wb25lbnQgeW91IGFyZSBjYWxsaW5nIGB1c2VNYXAoKWAgZnJvbSBpcyBhIHNpYmxpbmcgb2YgdGhlICcgK1xuICAgICAgICAgICAgJzxBUElQcm92aWRlcj4uJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IG1hcEluc3RhbmNlcyB9ID0gY3R4O1xuICAgIC8vIGlmIGFuIGlkIGlzIHNwZWNpZmllZCwgdGhlIGNvcnJlc3BvbmRpbmcgbWFwIG9yIG51bGwgaXMgcmV0dXJuZWRcbiAgICBpZiAoaWQgIT09IG51bGwpXG4gICAgICAgIHJldHVybiBtYXBJbnN0YW5jZXNbaWRdIHx8IG51bGw7XG4gICAgLy8gb3RoZXJ3aXNlLCByZXR1cm4gdGhlIGNsb3Nlc3QgYW5jZXN0b3JcbiAgICBpZiAobWFwKVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIC8vIGZpbmFsbHksIHJldHVybiB0aGUgZGVmYXVsdCBtYXAgaW5zdGFuY2VcbiAgICByZXR1cm4gbWFwSW5zdGFuY2VzWydkZWZhdWx0J10gfHwgbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHVzZU1hcHNMaWJyYXJ5KG5hbWUpIHtcbiAgICBjb25zdCBhcGlJc0xvYWRlZCA9IHVzZUFwaUlzTG9hZGVkKCk7XG4gICAgY29uc3QgY3R4ID0gdXNlQ29udGV4dChBUElQcm92aWRlckNvbnRleHQpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghYXBpSXNMb2FkZWQgfHwgIWN0eClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gVHJpZ2dlciBsb2FkaW5nIHRoZSBsaWJyYXJpZXMgdmlhIG91ciBwcm94eS1tZXRob2QuXG4gICAgICAgIC8vIFRoZSByZXR1cm5lZCBwcm9taXNlIGlzIGlnbm9yZWQsIHNpbmNlIGltcG9ydExpYnJhcnkgd2lsbCB1cGRhdGUgbG9hZGVkTGlicmFyaWVzXG4gICAgICAgIC8vIGxpc3QgaW4gdGhlIGNvbnRleHQsIHRyaWdnZXJpbmcgYSByZS1yZW5kZXIuXG4gICAgICAgIHZvaWQgY3R4LmltcG9ydExpYnJhcnkobmFtZSk7XG4gICAgfSwgW2FwaUlzTG9hZGVkLCBjdHgsIG5hbWVdKTtcbiAgICByZXR1cm4gKGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5sb2FkZWRMaWJyYXJpZXNbbmFtZV0pIHx8IG51bGw7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogSW50ZXJuYWxseSB1c2VkIHRvIGJpbmQgZXZlbnRzIHRvIE1hcHMgSmF2YVNjcmlwdCBBUEkgb2JqZWN0cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VNYXBzRXZlbnRMaXN0ZW5lcih0YXJnZXQsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgIW5hbWUgfHwgIWNhbGxiYWNrKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHRhcmdldCwgbmFtZSwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgfSwgW3RhcmdldCwgbmFtZSwgY2FsbGJhY2tdKTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbGx5IHVzZWQgdG8gY29weSB2YWx1ZXMgZnJvbSBwcm9wcyBpbnRvIEFQSS1PYmplY3RzXG4gKiB3aGVuZXZlciB0aGV5IGNoYW5nZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogICB1c2VQcm9wQmluZGluZyhtYXJrZXIsICdwb3NpdGlvbicsIHBvc2l0aW9uKTtcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlUHJvcEJpbmRpbmcob2JqZWN0LCBwcm9wLCB2YWx1ZSkge1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghb2JqZWN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvaW1tdXRhYmlsaXR5XG4gICAgICAgIG9iamVjdFtwcm9wXSA9IHZhbHVlO1xuICAgIH0sIFtvYmplY3QsIHByb3AsIHZhbHVlXSk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogSW50ZXJuYWxseSB1c2VkIHRvIGJpbmQgZXZlbnRzIHRvIERPTSBub2Rlcy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VEb21FdmVudExpc3RlbmVyKHRhcmdldCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXRhcmdldCB8fCAhbmFtZSB8fCAhY2FsbGJhY2spXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9LCBbdGFyZ2V0LCBuYW1lLCBjYWxsYmFja10pO1xufVxuXG4vLyBHbG9iYWwgc3R5bGUgbWFuYWdlciB0byB0cmFjayByZW5kZXJlZCBzdHlsZXMgYW5kIGF2b2lkIGR1cGxpY2F0ZXNcbmNsYXNzIEdsb2JhbFN0eWxlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZWRTdHlsZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0U3R5bGVFbGVtZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcmdtLWFuY2hvci1zdHlsZXMnLCAnJyk7XG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRoaXMuc3R5bGVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZUVsZW1lbnQ7XG4gICAgfVxuICAgIGFkZEFkdmFuY2VkTWFya2VyUG9pbnRlckV2ZW50c092ZXJ3cml0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRTdHlsZXMuaGFzKCdtYXJrZXItcG9pbnRlci1ldmVudHMnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0eWxlRWxlbWVudCA9IHRoaXMuZ2V0U3R5bGVFbGVtZW50KCk7XG4gICAgICAgIHN0eWxlRWxlbWVudC50ZXh0Q29udGVudCArPSBgXG4gICAgICBnbXAtYWR2YW5jZWQtbWFya2VyW2RhdGEtb3JpZ2luPSdyZ20nXSB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgYDtcbiAgICAgICAgdGhpcy5yZW5kZXJlZFN0eWxlcy5hZGQoJ21hcmtlci1wb2ludGVyLWV2ZW50cycpO1xuICAgIH1cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZFN0eWxlcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgZ2xvYmFsU3R5bGVNYW5hZ2VyID0gbmV3IEdsb2JhbFN0eWxlTWFuYWdlcigpO1xuXG5mdW5jdGlvbiBpc1ZlcnNpb25HcmVhdGVyRXF1YWwobWFqb3IsIG1pbm9yKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghKChfYSA9IGdvb2dsZSA9PT0gbnVsbCB8fCBnb29nbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdvb2dsZS5tYXBzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmVyc2lvbikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgdmVyc2lvbiA9IGdvb2dsZS5tYXBzLnZlcnNpb24uc3BsaXQoJy4nKTtcbiAgICBjb25zdCBjdXJyZW50TWFqb3IgPSBwYXJzZUludCh2ZXJzaW9uWzBdLCAxMCk7XG4gICAgY29uc3QgY3VycmVudE1pbm9yID0gcGFyc2VJbnQodmVyc2lvblsxXSwgMTApO1xuICAgIHJldHVybiAoY3VycmVudE1ham9yID4gbWFqb3IgfHwgKGN1cnJlbnRNYWpvciA9PT0gbWFqb3IgJiYgY3VycmVudE1pbm9yID49IG1pbm9yKSk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWhvb2tzL2ltbXV0YWJpbGl0eSAqL1xuLy8gVGhlIGByZWFjdC1ob29rcy9pbW11dGFiaWxpdHlgIHJ1bGUgaXMgZGlzYWJsZWQgaW4gdGhpcyBmaWxlIGJlY2F1c2UgdGhlXG4vLyBnb29nbGUubWFwcy5tYXJrZXIuQWR2YW5jZWRNYXJrZXJFbGVtZW50IG9iamVjdCBpcyBkZXNpZ25lZCB0byBiZSBtdXRhdGVkXG4vLyBkaXJlY3RseS4gVGhpcyBpcyBhIGNvbW1vbiBwYXR0ZXJuIHdoZW4gd29ya2luZyB3aXRoIGltcGVyYXRpdmUgQVBJcyBsaWtlXG4vLyB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEkuIFdoaWxlIHRoaXMgZ29lcyBhZ2FpbnN0IHRoZSBwcmluY2lwbGVzIG9mXG4vLyBpbW11dGFibGUgc3RhdGUgaW4gUmVhY3QsIGl0IGlzIGEgbmVjZXNzYXJ5IGV2aWwgdG8gaW50ZWdyYXRlIHdpdGggdGhlXG4vLyBHb29nbGUgTWFwcyBBUEkuIFRoZSBtdXRhdGlvbnMgYXJlIGNhcmVmdWxseSBtYW5hZ2VkIHdpdGhpbiB0aGUgYHVzZUVmZmVjdGBcbi8vIGhvb2tzIHRvIGVuc3VyZSB0aGF0IHRoZXkgb25seSBoYXBwZW4gd2hlbiB0aGUgcHJvcHMgY2hhbmdlLlxuLyoqXG4gKiBDb3B5IG9mIHRoZSBgZ29vZ2xlLm1hcHMuQ29sbGlzaW9uQmVoYXZpb3JgIGNvbnN0YW50cy5cbiAqIFRoZXkgaGF2ZSB0byBiZSBkdXBsaWNhdGVkIGhlcmUgc2luY2Ugd2UgY2FuJ3Qgd2FpdCBmb3IgdGhlIG1hcHMgQVBJIHRvIGxvYWQgdG8gYmUgYWJsZSB0byB1c2UgdGhlbS5cbiAqL1xuY29uc3QgQ29sbGlzaW9uQmVoYXZpb3IgPSB7XG4gICAgUkVRVUlSRUQ6ICdSRVFVSVJFRCcsXG4gICAgUkVRVUlSRURfQU5EX0hJREVTX09QVElPTkFMOiAnUkVRVUlSRURfQU5EX0hJREVTX09QVElPTkFMJyxcbiAgICBPUFRJT05BTF9BTkRfSElERVNfTE9XRVJfUFJJT1JJVFk6ICdPUFRJT05BTF9BTkRfSElERVNfTE9XRVJfUFJJT1JJVFknXG59O1xuY29uc3QgQWR2YW5jZWRNYXJrZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbi8vIFt4UG9zaXRpb24sIHlQb3NpdGlvbl0gd2hlbiB0aGUgdG9wIGxlZnQgY29ybmVyIGlzIFswLCAwXVxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2luZyBgYW5jaG9yUG9zaXRpb25gIGlzIGRlcHJlY2F0ZWQuXG4gKiAgIFVzZSBgYW5jaG9yTGVmdGAgYW5kIGBhbmNob3JUb3BgIGluc3RlYWQuXG4gKi9cbmNvbnN0IEFkdmFuY2VkTWFya2VyQW5jaG9yUG9pbnQgPSB7XG4gICAgVE9QX0xFRlQ6IFsnMCUnLCAnMCUnXSxcbiAgICBUT1BfQ0VOVEVSOiBbJzUwJScsICcwJSddLFxuICAgIFRPUDogWyc1MCUnLCAnMCUnXSxcbiAgICBUT1BfUklHSFQ6IFsnMTAwJScsICcwJSddLFxuICAgIExFRlRfQ0VOVEVSOiBbJzAlJywgJzUwJSddLFxuICAgIExFRlRfVE9QOiBbJzAlJywgJzAlJ10sXG4gICAgTEVGVDogWycwJScsICc1MCUnXSxcbiAgICBMRUZUX0JPVFRPTTogWycwJScsICcxMDAlJ10sXG4gICAgUklHSFRfVE9QOiBbJzEwMCUnLCAnMCUnXSxcbiAgICBSSUdIVDogWycxMDAlJywgJzUwJSddLFxuICAgIFJJR0hUX0NFTlRFUjogWycxMDAlJywgJzUwJSddLFxuICAgIFJJR0hUX0JPVFRPTTogWycxMDAlJywgJzEwMCUnXSxcbiAgICBCT1RUT01fTEVGVDogWycwJScsICcxMDAlJ10sXG4gICAgQk9UVE9NX0NFTlRFUjogWyc1MCUnLCAnMTAwJSddLFxuICAgIEJPVFRPTTogWyc1MCUnLCAnMTAwJSddLFxuICAgIEJPVFRPTV9SSUdIVDogWycxMDAlJywgJzEwMCUnXSxcbiAgICBDRU5URVI6IFsnNTAlJywgJzUwJSddXG59O1xuY29uc3QgQWR2YW5jZWRNYXJrZXIgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgc3R5bGUsIGNsYXNzTmFtZSwgYW5jaG9yUG9pbnQgfSA9IHByb3BzO1xuICAgIGNvbnN0IFttYXJrZXIsIGNvbnRlbnRDb250YWluZXJdID0gdXNlQWR2YW5jZWRNYXJrZXIocHJvcHMpO1xuICAgIGNvbnN0IGFkdmFuY2VkTWFya2VyQ29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiAobWFya2VyID8geyBtYXJrZXIgfSA6IG51bGwpLCBbbWFya2VyXSk7XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IG1hcmtlciwgW21hcmtlcl0pO1xuICAgIGlmICghY29udGVudENvbnRhaW5lcilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEFkdmFuY2VkTWFya2VyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogYWR2YW5jZWRNYXJrZXJDb250ZXh0VmFsdWUgfSwgY3JlYXRlUG9ydGFsKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya2VyQ29udGVudCwgeyBhbmNob3JQb2ludDogYW5jaG9yUG9pbnQsIHN0eWxlczogc3R5bGUsIGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sIGNoaWxkcmVuKSwgY29udGVudENvbnRhaW5lcikpKTtcbn0pO1xuQWR2YW5jZWRNYXJrZXIuZGlzcGxheU5hbWUgPSAnQWR2YW5jZWRNYXJrZXInO1xuZnVuY3Rpb24gdXNlQWR2YW5jZWRNYXJrZXJSZWYoKSB7XG4gICAgY29uc3QgW21hcmtlciwgc2V0TWFya2VyXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IHJlZkNhbGxiYWNrID0gdXNlQ2FsbGJhY2soKG0pID0+IHtcbiAgICAgICAgc2V0TWFya2VyKG0pO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gW3JlZkNhbGxiYWNrLCBtYXJrZXJdO1xufVxuZnVuY3Rpb24gaXNBZHZhbmNlZE1hcmtlcihtYXJrZXIpIHtcbiAgICByZXR1cm4gKG1hcmtlci5jb250ZW50ICE9PSB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xufVxuY29uc3QgTWFya2VyQ29udGVudCA9ICh7IGNoaWxkcmVuLCBzdHlsZXMsIGNsYXNzTmFtZSB9KSA9PiB7XG4gICAgLyogQWR2YW5jZWRNYXJrZXIgZGl2IHRoYXQgdXNlciBjYW4gZ2l2ZSBzdHlsZXMgYW5kIGNsYXNzZXMgKi9cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgc3R5bGU6IHN0eWxlcyB9LCBjaGlsZHJlbikpO1xufTtcbmZ1bmN0aW9uIHVzZUFkdmFuY2VkTWFya2VyKHByb3BzKSB7XG4gICAgY29uc3QgW21hcmtlciwgc2V0TWFya2VyXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtjb250ZW50Q29udGFpbmVyLCBzZXRDb250ZW50Q29udGFpbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IG1hcCA9IHVzZU1hcCgpO1xuICAgIGNvbnN0IG1hcmtlckxpYnJhcnkgPSB1c2VNYXBzTGlicmFyeSgnbWFya2VyJyk7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgb25DbGljaywgY2xhc3NOYW1lLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSwgb25EcmFnLCBvbkRyYWdTdGFydCwgb25EcmFnRW5kLCBjb2xsaXNpb25CZWhhdmlvciwgY2xpY2thYmxlLCBkcmFnZ2FibGUsIHBvc2l0aW9uLCB0aXRsZSwgekluZGV4LCBhbmNob3JQb2ludCwgYW5jaG9yTGVmdCwgYW5jaG9yVG9wIH0gPSBwcm9wcztcbiAgICBjb25zdCBudW1DaGlsZHJlbiA9IENoaWxkcmVuLmNvdW50KGNoaWxkcmVuKTtcbiAgICAvLyBjcmVhdGUgYW4gQWR2YW5jZWRNYXJrZXJFbGVtZW50IGluc3RhbmNlIGFuZCBhZGQgaXQgdG8gdGhlIG1hcCBvbmNlIGF2YWlsYWJsZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFwIHx8ICFtYXJrZXJMaWJyYXJ5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBuZXdNYXJrZXIgPSBuZXcgbWFya2VyTGlicmFyeS5BZHZhbmNlZE1hcmtlckVsZW1lbnQoKTtcbiAgICAgICAgbmV3TWFya2VyLm1hcCA9IG1hcDtcbiAgICAgICAgc2V0TWFya2VyKG5ld01hcmtlcik7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgY29udGFpbmVyIGZvciBtYXJrZXIgY29udGVudCBpZiB0aGVyZSBhcmUgY2hpbGRyZW5cbiAgICAgICAgbGV0IGNvbnRlbnRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKG51bUNoaWxkcmVuID4gMCkge1xuICAgICAgICAgICAgY29udGVudEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIG5ld01hcmtlci5jb250ZW50ID0gY29udGVudEVsZW1lbnQ7XG4gICAgICAgICAgICBzZXRDb250ZW50Q29udGFpbmVyKGNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbmV3TWFya2VyLm1hcCA9IG51bGw7XG4gICAgICAgICAgICBjb250ZW50RWxlbWVudCA9PT0gbnVsbCB8fCBjb250ZW50RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGVudEVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICBzZXRNYXJrZXIobnVsbCk7XG4gICAgICAgICAgICBzZXRDb250ZW50Q29udGFpbmVyKG51bGwpO1xuICAgICAgICB9O1xuICAgIH0sIFttYXAsIG1hcmtlckxpYnJhcnksIG51bUNoaWxkcmVuXSk7XG4gICAgLy8gV2hlbiBubyBjaGlsZHJlbiBhcmUgcHJlc2VudCB3ZSBkb24ndCBoYXZlIG91ciBvd24gd3JhcHBlciBkaXZcbiAgICAvLyB3aGljaCB1c3VhbGx5IGdldHMgdGhlIHVzZXIgcHJvdmlkZWQgY2xhc3NOYW1lLiBJbiB0aGlzIGNhc2VcbiAgICAvLyB3ZSBzZXQgdGhlIGNsYXNzTmFtZSBkaXJlY3RseSBvbiB0aGUgbWFya2VyLmNvbnRlbnQgZWxlbWVudCB0aGF0IGNvbWVzXG4gICAgLy8gd2l0aCB0aGUgQWR2YW5jZWRNYXJrZXIuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCEobWFya2VyID09PSBudWxsIHx8IG1hcmtlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyLmNvbnRlbnQpIHx8ICFpc0VsZW1lbnROb2RlKG1hcmtlci5jb250ZW50KSB8fCBudW1DaGlsZHJlbiA+IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG1hcmtlci5jb250ZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZSAhPT0gbnVsbCAmJiBjbGFzc05hbWUgIT09IHZvaWQgMCA/IGNsYXNzTmFtZSA6ICcnO1xuICAgIH0sIFttYXJrZXIsIGNsYXNzTmFtZSwgbnVtQ2hpbGRyZW5dKTtcbiAgICB1c2VBZHZhbmNlZE1hcmtlckFuY2hvcmluZyhtYXJrZXIsIGFuY2hvclBvaW50LCBhbmNob3JMZWZ0LCBhbmNob3JUb3AsIG51bUNoaWxkcmVuID4gMCk7XG4gICAgLy8gY29weSBvdGhlciBwcm9wc1xuICAgIHVzZVByb3BCaW5kaW5nKG1hcmtlciwgJ3Bvc2l0aW9uJywgcG9zaXRpb24pO1xuICAgIHVzZVByb3BCaW5kaW5nKG1hcmtlciwgJ3RpdGxlJywgdGl0bGUgIT09IG51bGwgJiYgdGl0bGUgIT09IHZvaWQgMCA/IHRpdGxlIDogJycpO1xuICAgIHVzZVByb3BCaW5kaW5nKG1hcmtlciwgJ3pJbmRleCcsIHpJbmRleCk7XG4gICAgdXNlUHJvcEJpbmRpbmcobWFya2VyLCAnY29sbGlzaW9uQmVoYXZpb3InLCBjb2xsaXNpb25CZWhhdmlvcik7XG4gICAgLy8gc2V0IGdtcERyYWdnYWJsZSBmcm9tIHByb3BzICh3aGVuIHVuc3BlY2lmaWVkLCBpdCdzIHRydWUgaWYgYW55IGRyYWctZXZlbnRcbiAgICAvLyBjYWxsYmFja3MgYXJlIHNwZWNpZmllZClcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcmtlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGRyYWdnYWJsZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgbWFya2VyLmdtcERyYWdnYWJsZSA9IGRyYWdnYWJsZTtcbiAgICAgICAgZWxzZSBpZiAob25EcmFnIHx8IG9uRHJhZ1N0YXJ0IHx8IG9uRHJhZ0VuZClcbiAgICAgICAgICAgIG1hcmtlci5nbXBEcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXJrZXIuZ21wRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgfSwgW21hcmtlciwgZHJhZ2dhYmxlLCBvbkRyYWcsIG9uRHJhZ0VuZCwgb25EcmFnU3RhcnRdKTtcbiAgICAvLyBzZXQgZ21wQ2xpY2thYmxlIGZyb20gcHJvcHMgKHdoZW4gdW5zcGVjaWZpZWQsIGl0J3MgdHJ1ZSBpZiB0aGUgb25DbGljayBvciBvbmUgb2ZcbiAgICAvLyB0aGUgaG92ZXIgZXZlbnRzIGNhbGxiYWNrcyBhcmUgc3BlY2lmaWVkKVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFya2VyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBnbXBDbGlja2FibGUgPSBjbGlja2FibGUgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgQm9vbGVhbihvbkNsaWNrKSB8fFxuICAgICAgICAgICAgQm9vbGVhbihvbk1vdXNlRW50ZXIpIHx8XG4gICAgICAgICAgICBCb29sZWFuKG9uTW91c2VMZWF2ZSk7XG4gICAgICAgIC8vIGdtcENsaWNrYWJsZSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBiZXRhIHZlcnNpb24gb2YgdGhlXG4gICAgICAgIC8vIG1hcHMgYXBpIChhcyBvZiAyMDI0LTEwLTEwKVxuICAgICAgICBtYXJrZXIuZ21wQ2xpY2thYmxlID0gZ21wQ2xpY2thYmxlO1xuICAgICAgICAvLyBlbmFibGUgcG9pbnRlciBldmVudHMgZm9yIHRoZSBtYXJrZXJzIHdpdGggY3VzdG9tIGNvbnRlbnRcbiAgICAgICAgaWYgKGdtcENsaWNrYWJsZSAmJiAobWFya2VyID09PSBudWxsIHx8IG1hcmtlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyLmNvbnRlbnQpICYmIGlzRWxlbWVudE5vZGUobWFya2VyLmNvbnRlbnQpKSB7XG4gICAgICAgICAgICBtYXJrZXIuY29udGVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2FsbCc7XG4gICAgICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgICAgICAgIG1hcmtlci5jb250ZW50LnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFttYXJrZXIsIGNsaWNrYWJsZSwgb25DbGljaywgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmVdKTtcbiAgICB1c2VNYXBzRXZlbnRMaXN0ZW5lcihtYXJrZXIsICdjbGljaycsIG9uQ2xpY2spO1xuICAgIHVzZU1hcHNFdmVudExpc3RlbmVyKG1hcmtlciwgJ2RyYWcnLCBvbkRyYWcpO1xuICAgIHVzZU1hcHNFdmVudExpc3RlbmVyKG1hcmtlciwgJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KTtcbiAgICB1c2VNYXBzRXZlbnRMaXN0ZW5lcihtYXJrZXIsICdkcmFnZW5kJywgb25EcmFnRW5kKTtcbiAgICB1c2VEb21FdmVudExpc3RlbmVyKG1hcmtlciA9PT0gbnVsbCB8fCBtYXJrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlci5lbGVtZW50LCAnbW91c2VlbnRlcicsIG9uTW91c2VFbnRlcik7XG4gICAgdXNlRG9tRXZlbnRMaXN0ZW5lcihtYXJrZXIgPT09IG51bGwgfHwgbWFya2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXIuZWxlbWVudCwgJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICAgIHJldHVybiBbbWFya2VyLCBjb250ZW50Q29udGFpbmVyXTtcbn1cbmZ1bmN0aW9uIHVzZUFkdmFuY2VkTWFya2VyQW5jaG9yaW5nKG1hcmtlciwgYW5jaG9yUG9pbnQsIGFuY2hvckxlZnQsIGFuY2hvclRvcCwgaGFzQ2hpbGRyZW4pIHtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcmtlciB8fCAhaGFzQ2hpbGRyZW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFRoZSBhbmNob3JMZWZ0IGFuZCBhbmNob3JUb3Agb3B0aW9ucyBhcmUgYXZhaWxhYmxlIHNpbmNlIHZlcnNpb24gMy42Mi45Y1xuICAgICAgICAvLyBXaXRoIHRoZSByZWxlYXNlIG9mIDMuNjUgKH5NYXkgMjAyNikgdGhlcmUgd2lsbCBubyBsb25nZXIgYmUgYSB2ZXJzaW9uXG4gICAgICAgIC8vIHRoYXQgZG9lc24ndCBzdXBwb3J0IGl0LlxuICAgICAgICBjb25zdCBhbmNob3JPcHRpb25zU3VwcG9ydGVkID0gaXNWZXJzaW9uR3JlYXRlckVxdWFsKDMsIDYyKTtcbiAgICAgICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBtYXJrZXIuY29udGVudDtcbiAgICAgICAgaWYgKCFjb250ZW50RWxlbWVudCB8fCAhaXNFbGVtZW50Tm9kZShjb250ZW50RWxlbWVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChhbmNob3JMZWZ0ICE9PSB1bmRlZmluZWQgfHwgYW5jaG9yVG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghYW5jaG9yT3B0aW9uc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQWR2YW5jZWRNYXJrZXI6IFRoZSBhbmNob3JMZWZ0IGFuZCBhbmNob3JUb3AgcHJvcHMgYXJlIG9ubHkgc3VwcG9ydGVkICcgK1xuICAgICAgICAgICAgICAgICAgICAnaW4gR29vZ2xlIE1hcHMgQVBJIHZlcnNpb24gMy42MiBhbmQgYWJvdmUuICcgK1xuICAgICAgICAgICAgICAgICAgICBgVGhlIGN1cnJlbnQgdmVyc2lvbiBpcyAke2dvb2dsZS5tYXBzLnZlcnNpb259LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFya2VyLmFuY2hvckxlZnQgPSBhbmNob3JMZWZ0O1xuICAgICAgICAgICAgbWFya2VyLmFuY2hvclRvcCA9IGFuY2hvclRvcDtcbiAgICAgICAgICAgIC8vIHdoZW4gYW5jaG9yTGVmdCBhbmQvb3IgYW5jaG9yVG9wIGFyZSBzZXQsIHdlJ2xsIGlnbm9yZSB0aGUgYW5jaG9yUG9pbnRcbiAgICAgICAgICAgIGlmIChhbmNob3JQb2ludCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdBZHZhbmNlZE1hcmtlcjogdGhlIGFuY2hvclBvaW50IHByb3AgaXMgaWdub3JlZCB3aGVuIGFuY2hvckxlZnQgJyArXG4gICAgICAgICAgICAgICAgICAgICdhbmQvb3IgYW5jaG9yVG9wIGFyZSBzZXQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuY2hvclBvaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGFkZCBjb25zb2xlLndhcm4gaW4gYSBmdXR1cmUgdmVyc2lvbiB0byBpbmZvcm0gYWJvdXQgZGVwcmVjYXRpb25cbiAgICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IGFuY2hvclBvaW50ICE9PSBudWxsICYmIGFuY2hvclBvaW50ICE9PSB2b2lkIDAgPyBhbmNob3JQb2ludCA6IEFkdmFuY2VkTWFya2VyQW5jaG9yUG9pbnRbJ0JPVFRPTSddO1xuICAgICAgICAgICAgLy8gTk9URTogc2luY2UgeCBhbmQgeSBjYW4gYmUgYW55IHZhbGlkIENTUyBsZW5ndGgtcGVyY2VudGFnZVxuICAgICAgICAgICAgLy8gICB2YWx1ZSwgd2UgbmVlZCB0byB1c2UgY2FsYygpIHRvIG5lZ2F0ZSB0aGVtLlxuICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlWCA9IGBjYWxjKC0xICogJHt4fSlgO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlWSA9IGBjYWxjKC0xICogJHt5fSlgO1xuICAgICAgICAgICAgaWYgKGFuY2hvck9wdGlvbnNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpbXBsZW1lbnQgYW5jaG9yUG9pbnQgdXNpbmcgdGhlIG5ldyBhbmNob3JMZWZ0IGFuZCBhbmNob3JUb3Agb3B0aW9uc1xuICAgICAgICAgICAgICAgIG1hcmtlci5hbmNob3JMZWZ0ID0gdHJhbnNsYXRlWDtcbiAgICAgICAgICAgICAgICBtYXJrZXIuYW5jaG9yVG9wID0gdHJhbnNsYXRlWTtcbiAgICAgICAgICAgICAgICAvLyByZXNldCB0cmFuc2Zvcm0gZnJvbSBsZWdhY3kgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBcInRyYW5zbGF0ZSg1MCUsIDEwMCUpXCIgY291bnRlcnMgYW5kIHJlc2V0cyB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgICAgIC8vIGFuY2hvcmluZyBvZiB0aGUgYWR2YW5jZWQgbWFya2VyIGVsZW1lbnQgZnJvbSB0aGUgYXBpXG4gICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSg1MCUsIDEwMCUpIHRyYW5zbGF0ZSgke3RyYW5zbGF0ZVh9LCAke3RyYW5zbGF0ZVl9KWA7XG4gICAgICAgICAgICAgICAgLy8gZGF0YS1vcmlnaW4gaXMgbmVlZGVkIHRvIGlkZW50aWZ5IHRoZSBjdXN0b20gbWFya2VyIGNvbnRlbnQgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gSW5mb1dpbmRvdyBjb21wb25lbnQgYXMgd2VsbCBhcyBpbiB0aGUgZ2xvYmFsIENTUyB1c2VkIHRvIGRpc2FibGVcbiAgICAgICAgICAgICAgICAvLyB0aGUgcG9pbnRlciBldmVudCB3aGVuIGFuY2hvciBwb2ludHMgYXJlIHVzZWQgaW4gb2xkZXIgR29vZ2xlIE1hcHNcbiAgICAgICAgICAgICAgICAvLyB2ZXJzaW9ucy5cbiAgICAgICAgICAgICAgICBtYXJrZXIuZGF0YXNldC5vcmlnaW4gPSAncmdtJztcbiAgICAgICAgICAgICAgICBnbG9iYWxTdHlsZU1hbmFnZXIuYWRkQWR2YW5jZWRNYXJrZXJQb2ludGVyRXZlbnRzT3ZlcndyaXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbbWFya2VyLCBhbmNob3JQb2ludCwgYW5jaG9yTGVmdCwgYW5jaG9yVG9wLCBoYXNDaGlsZHJlbl0pO1xufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZUZvclN0eWxlcyhlbGVtZW50LCBzdHlsZXMsIHByZXZTdHlsZXMpIHtcbiAgICBpZiAoc3R5bGVzICE9IG51bGwgJiYgdHlwZW9mIHN0eWxlcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsICcgK1xuICAgICAgICAgICAgXCJub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgJ2VtJ319IHdoZW4gXCIgK1xuICAgICAgICAgICAgJ3VzaW5nIEpTWC4nKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudFN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICAvLyB3aXRob3V0IGBwcmV2U3R5bGVzYCwganVzdCBzZXQgYWxsIHZhbHVlc1xuICAgIGlmIChwcmV2U3R5bGVzID09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0eWxlcyA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGNvbnN0IHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBzZXRWYWx1ZUZvclN0eWxlKGVsZW1lbnRTdHlsZSwgc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB1bnNldCBhbGwgc3R5bGVzIGluIGBwcmV2U3R5bGVzYCB0aGF0IGFyZW4ndCBpbiBgc3R5bGVzYFxuICAgIGZvciAoY29uc3Qgc3R5bGVOYW1lIGluIHByZXZTdHlsZXMpIHtcbiAgICAgICAgaWYgKHByZXZTdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJlxuICAgICAgICAgICAgKHN0eWxlcyA9PSBudWxsIHx8ICFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHN0eWxlXG4gICAgICAgICAgICBjb25zdCBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgICAgICAgICBpZiAoaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRTdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRTdHlsZS5jc3NGbG9hdCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBvbmx5IGFzc2lnbiB2YWx1ZXMgZnJvbSBgc3R5bGVzYCB0aGF0IGFyZSBkaWZmZXJlbnQgZnJvbSBgcHJldlN0eWxlc2BcbiAgICBpZiAoc3R5bGVzID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmXG4gICAgICAgICAgICBwcmV2U3R5bGVzW3N0eWxlTmFtZV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUZvclN0eWxlKGVsZW1lbnRTdHlsZSwgc3R5bGVOYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzZXRWYWx1ZUZvclN0eWxlKGVsZW1lbnRTdHlsZSwgc3R5bGVOYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICAvLyBmYWxzeSB2YWx1ZXMgd2lsbCB1bnNldCB0aGUgc3R5bGUgcHJvcGVydHlcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGVsZW1lbnRTdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgICAgICAgIGVsZW1lbnRTdHlsZS5jc3NGbG9hdCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudFN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjdXN0b20gcHJvcGVydGllcyBjYW4ndCBiZSBkaXJlY3RseSBhc3NpZ25lZFxuICAgIGVsc2UgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgZWxlbWVudFN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBudW1lcmljIHZhbHVlcyBhcmUgdHJlYXRlZCBhcyAncHgnIHVubGVzcyB0aGUgc3R5bGUgcHJvcGVydHkgZXhwZWN0cyB1bml0bGVzcyBudW1iZXJzXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWx1ZSAhPT0gMCAmJlxuICAgICAgICAhaXNVbml0bGVzc051bWJlcihzdHlsZU5hbWUpKSB7XG4gICAgICAgIGVsZW1lbnRTdHlsZVtzdHlsZU5hbWVdID0gdmFsdWUgKyAncHgnOyAvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xuICAgIH1cbiAgICAvLyBldmVyeXRoaW5nIGVsc2UgY2FuIGp1c3QgYmUgYXNzaWduZWRcbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICAgICAgZWxlbWVudFN0eWxlLmNzc0Zsb2F0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50U3R5bGVbc3R5bGVOYW1lXSA9ICgnJyArIHZhbHVlKS50cmltKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG5jb25zdCB1bml0bGVzc051bWJlcnMgPSBuZXcgU2V0KFtcbiAgICAnYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQnLFxuICAgICdhc3BlY3RSYXRpbycsXG4gICAgJ2JvcmRlckltYWdlT3V0c2V0JyxcbiAgICAnYm9yZGVySW1hZ2VTbGljZScsXG4gICAgJ2JvcmRlckltYWdlV2lkdGgnLFxuICAgICdib3hGbGV4JyxcbiAgICAnYm94RmxleEdyb3VwJyxcbiAgICAnYm94T3JkaW5hbEdyb3VwJyxcbiAgICAnY29sdW1uQ291bnQnLFxuICAgICdjb2x1bW5zJyxcbiAgICAnZmxleCcsXG4gICAgJ2ZsZXhHcm93JyxcbiAgICAnZmxleFBvc2l0aXZlJyxcbiAgICAnZmxleFNocmluaycsXG4gICAgJ2ZsZXhOZWdhdGl2ZScsXG4gICAgJ2ZsZXhPcmRlcicsXG4gICAgJ2dyaWRBcmVhJyxcbiAgICAnZ3JpZFJvdycsXG4gICAgJ2dyaWRSb3dFbmQnLFxuICAgICdncmlkUm93U3BhbicsXG4gICAgJ2dyaWRSb3dTdGFydCcsXG4gICAgJ2dyaWRDb2x1bW4nLFxuICAgICdncmlkQ29sdW1uRW5kJyxcbiAgICAnZ3JpZENvbHVtblNwYW4nLFxuICAgICdncmlkQ29sdW1uU3RhcnQnLFxuICAgICdmb250V2VpZ2h0JyxcbiAgICAnbGluZUNsYW1wJyxcbiAgICAnbGluZUhlaWdodCcsXG4gICAgJ29wYWNpdHknLFxuICAgICdvcmRlcicsXG4gICAgJ29ycGhhbnMnLFxuICAgICdzY2FsZScsXG4gICAgJ3RhYlNpemUnLFxuICAgICd3aWRvd3MnLFxuICAgICd6SW5kZXgnLFxuICAgICd6b29tJyxcbiAgICAnZmlsbE9wYWNpdHknLCAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gICAgJ2Zsb29kT3BhY2l0eScsXG4gICAgJ3N0b3BPcGFjaXR5JyxcbiAgICAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgICAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICAgJ3N0cm9rZU1pdGVybGltaXQnLFxuICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAnc3Ryb2tlV2lkdGgnXG5dKTtcbmZ1bmN0aW9uIGlzVW5pdGxlc3NOdW1iZXIobmFtZSkge1xuICAgIHJldHVybiB1bml0bGVzc051bWJlcnMuaGFzKG5hbWUpO1xufVxuXG4vKipcbiAqIENvbXBvbmVudCB0byByZW5kZXIgYW4gSW5mbyBXaW5kb3cgd2l0aCB0aGUgTWFwcyBKYXZhU2NyaXB0IEFQSVxuICovXG5jb25zdCBJbmZvV2luZG93ID0gcHJvcHMgPT4ge1xuICAgIGNvbnN0IHsgXG4gICAgLy8gY29udGVudCBvcHRpb25zXG4gICAgY2hpbGRyZW4sIGhlYWRlckNvbnRlbnQsIHN0eWxlLCBjbGFzc05hbWUsIHBpeGVsT2Zmc2V0LCBcbiAgICAvLyBvcGVuIG9wdGlvbnNcbiAgICBhbmNob3IsIHNob3VsZEZvY3VzLCBcbiAgICAvLyBldmVudHNcbiAgICBvbkNsb3NlLCBvbkNsb3NlQ2xpY2sgfSA9IHByb3BzLCBcbiAgICAvLyBvdGhlciBvcHRpb25zXG4gICAgdm9sYXRpbGVJbmZvV2luZG93T3B0aW9ucyA9IF9fcmVzdChwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJoZWFkZXJDb250ZW50XCIsIFwic3R5bGVcIiwgXCJjbGFzc05hbWVcIiwgXCJwaXhlbE9mZnNldFwiLCBcImFuY2hvclwiLCBcInNob3VsZEZvY3VzXCIsIFwib25DbG9zZVwiLCBcIm9uQ2xvc2VDbGlja1wiXSk7XG4gICAgLy8gIyMgY3JlYXRlIGluZm93aW5kb3cgaW5zdGFuY2Ugb25jZSB0aGUgbWFwc0xpYnJhcnkgaXMgYXZhaWxhYmxlLlxuICAgIGNvbnN0IG1hcHNMaWJyYXJ5ID0gdXNlTWFwc0xpYnJhcnkoJ21hcHMnKTtcbiAgICBjb25zdCBbaW5mb1dpbmRvdywgc2V0SW5mb1dpbmRvd10gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBjb250ZW50Q29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGhlYWRlckNvbnRhaW5lclJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBpbmZvV2luZG93T3B0aW9ucyA9IHVzZU1lbW9pemVkKHZvbGF0aWxlSW5mb1dpbmRvd09wdGlvbnMsIGlzRGVlcEVxdWFsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcHNMaWJyYXJ5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IGluZm9XaW5kb3dPcHRpb25zO1xuICAgICAgICBpZiAocGl4ZWxPZmZzZXQpIHtcbiAgICAgICAgICAgIG9wdHMucGl4ZWxPZmZzZXQgPSBuZXcgZ29vZ2xlLm1hcHMuU2l6ZShwaXhlbE9mZnNldFswXSwgcGl4ZWxPZmZzZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJDb250ZW50KSB7XG4gICAgICAgICAgICAvLyBpZiBoZWFkZXJDb250ZW50IGlzIHNwZWNpZmllZCBhcyBzdHJpbmcgd2UgY2FuIGRpcmVjdGx5IGZvcndhcmQgaXQsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UnbGwgcGFzcyB0aGUgZWxlbWVudCB0aGUgcG9ydGFsIHdpbGwgcmVuZGVyIGludG9cbiAgICAgICAgICAgIG9wdHMuaGVhZGVyQ29udGVudCA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGhlYWRlckNvbnRlbnQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gaGVhZGVyQ29udGVudFxuICAgICAgICAgICAgICAgICAgICA6IGhlYWRlckNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgc2hhZG93aW5nIHRoZSBzdGF0ZSB2YXJpYWJsZXMgaGVyZVxuICAgICAgICBjb25zdCBpbmZvV2luZG93ID0gbmV3IGdvb2dsZS5tYXBzLkluZm9XaW5kb3coaW5mb1dpbmRvd09wdGlvbnMpO1xuICAgICAgICBpbmZvV2luZG93LnNldENvbnRlbnQoY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50KTtcbiAgICAgICAgc2V0SW5mb1dpbmRvdyhpbmZvV2luZG93KTtcbiAgICAgICAgLy8gdW5tb3VudDogcmVtb3ZlIGluZm9XaW5kb3cgYW5kIGNvbnRlbnQgZWxlbWVudHMgKG5vdGU6IGNsb3NlIGlzIGNhbGxlZCBpbiBhIGRpZmZlcmVudCBlZmZlY3QtY2xlYW51cClcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpbmZvV2luZG93LnNldENvbnRlbnQobnVsbCk7XG4gICAgICAgICAgICAoX2EgPSBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmUoKTtcbiAgICAgICAgICAgIChfYiA9IGhlYWRlckNvbnRhaW5lclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVtb3ZlKCk7XG4gICAgICAgICAgICBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgc2V0SW5mb1dpbmRvdyhudWxsKTtcbiAgICAgICAgfTtcbiAgICB9LCBcbiAgICAvLyBgaW5mb1dpbmRvd09wdGlvbnNgIGFuZCBvdGhlciBwcm9wcyBhcmUgbWlzc2luZyBmcm9tIGRlcGVuZGVuY2llczpcbiAgICAvL1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gcmUtY3JlYXRlIHRoZSBpbmZvd2luZG93IGluc3RhbmNlXG4gICAgLy8gd2hlbiB0aGUgb3B0aW9ucyBjaGFuZ2UuXG4gICAgLy8gVXBkYXRpbmcgdGhlIG9wdGlvbnMgaXMgaGFuZGxlZCBpbiB0aGUgdXNlRWZmZWN0IGJlbG93LlxuICAgIC8vXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFttYXBzTGlicmFyeV0pO1xuICAgIC8vIC0tLS0gdXBkYXRlIGNsYXNzTmFtZSBhbmQgc3R5bGVzIGZvciBgY29udGVudENvbnRhaW5lcmBcbiAgICAvLyBwcmV2U3R5bGVSZWYgc3RvcmVzIHByZXZpb3VzbHkgYXBwbGllZCBzdHlsZSBwcm9wZXJ0aWVzLCBzbyB0aGV5IGNhbiBiZVxuICAgIC8vIHJlbW92ZWQgd2hlbiB1bnNldFxuICAgIGNvbnN0IHByZXZTdHlsZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWluZm9XaW5kb3cgfHwgIWNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50LCBzdHlsZSB8fCBudWxsLCBwcmV2U3R5bGVSZWYuY3VycmVudCk7XG4gICAgICAgIHByZXZTdHlsZVJlZi5jdXJyZW50ID0gc3R5bGUgfHwgbnVsbDtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSAhPT0gY29udGVudENvbnRhaW5lclJlZi5jdXJyZW50LmNsYXNzTmFtZSlcbiAgICAgICAgICAgIGNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudC5jbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XG4gICAgfSwgW2luZm9XaW5kb3csIGNsYXNzTmFtZSwgc3R5bGVdKTtcbiAgICAvLyAtLS0tIHVwZGF0ZSBvcHRpb25zXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpbmZvV2luZG93KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBvcHRzID0gaW5mb1dpbmRvd09wdGlvbnM7XG4gICAgICAgIGlmICghcGl4ZWxPZmZzZXQpIHtcbiAgICAgICAgICAgIG9wdHMucGl4ZWxPZmZzZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0cy5waXhlbE9mZnNldCA9IG5ldyBnb29nbGUubWFwcy5TaXplKHBpeGVsT2Zmc2V0WzBdLCBwaXhlbE9mZnNldFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoZWFkZXJDb250ZW50KSB7XG4gICAgICAgICAgICBvcHRzLmhlYWRlckNvbnRlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJDb250ZW50ID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgaGVhZGVyQ29udGVudCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgPyBoZWFkZXJDb250ZW50XG4gICAgICAgICAgICAgICAgICAgIDogaGVhZGVyQ29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaW5mb1dpbmRvdy5zZXRPcHRpb25zKGluZm9XaW5kb3dPcHRpb25zKTtcbiAgICB9LCBcbiAgICAvLyBkZXBlbmRlbmN5IGBpbmZvV2luZG93YCBpc24ndCBuZWVkZWQgc2luY2Ugb3B0aW9ucyBhcmUgYWxzbyBwYXNzZWRcbiAgICAvLyB0byB0aGUgY29uc3RydWN0b3Igd2hlbiBhIG5ldyBpbmZvV2luZG93IGlzIGNyZWF0ZWQuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtpbmZvV2luZG93T3B0aW9ucywgcGl4ZWxPZmZzZXQsIGhlYWRlckNvbnRlbnRdKTtcbiAgICAvLyAjIyBiaW5kIGV2ZW50IGhhbmRsZXJzXG4gICAgdXNlTWFwc0V2ZW50TGlzdGVuZXIoaW5mb1dpbmRvdywgJ2Nsb3NlJywgb25DbG9zZSk7XG4gICAgdXNlTWFwc0V2ZW50TGlzdGVuZXIoaW5mb1dpbmRvdywgJ2Nsb3NlY2xpY2snLCBvbkNsb3NlQ2xpY2spO1xuICAgIC8vIC0tLS0gb3BlbiBpbmZvIHdpbmRvdyB3aGVuIGNvbnRlbnQgYW5kIG1hcCBhcmUgYXZhaWxhYmxlXG4gICAgY29uc3QgbWFwID0gdXNlTWFwKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBgYW5jaG9yID09PSBudWxsYCBtZWFucyBhbiBhbmNob3IgaXMgZGVmaW5lZCBidXQgbm90IHJlYWR5IHlldC5cbiAgICAgICAgaWYgKCFtYXAgfHwgIWluZm9XaW5kb3cgfHwgYW5jaG9yID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBpc09wZW5lZFdpdGhBbmNob3IgPSAhIWFuY2hvcjtcbiAgICAgICAgY29uc3Qgb3Blbk9wdGlvbnMgPSB7IG1hcCB9O1xuICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICBvcGVuT3B0aW9ucy5hbmNob3IgPSBhbmNob3I7XG4gICAgICAgICAgICAvLyBPbmx5IGRvIHRoZSBpbmZvd2luZG93IGFkanVzdGluZyB3aGVuIGRlYWxpbmcgd2l0aCBhbiBBZHZhbmNlZE1hcmtlclxuICAgICAgICAgICAgaWYgKGlzQWR2YW5jZWRNYXJrZXIoYW5jaG9yKSAmJiBhbmNob3IuY29udGVudCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3JCY3IgPSBhbmNob3IgPT09IG51bGwgfHwgYW5jaG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmNob3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjaGVja3Mgd2hldGhlciBvciBub3QgdGhlIGFuY2hvciBoYXMgY3VzdG9tIGNvbnRlbnQgd2l0aCBvdXIgb3duXG4gICAgICAgICAgICAgICAgLy8gZGl2IHdyYXBwZXIuIElmIG5vdCwgdGhhdCBtZWFucyB3ZSBoYXZlIGEgcmVndWxhciBBZHZhbmNlZE1hcmtlciB3aXRob3V0XG4gICAgICAgICAgICAgICAgLy8gY2hpbGRyZW4sIG9yIGFuIEFkdmFuY2VkTWFya2VyIHRoYXQgdXNlcyB0aGUgYW5jaG9yTGVmdC9hbmNob3JUb3AgcHJvcHMuXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlIHdlIGRvIG5vdCB3YW50IHRvIGFkanVzdCB0aGUgaW5mb3dpbmRvdyBzaW5jZSBpdCBpcyBhbGwgaGFuZGxlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBieSB0aGUgR29vZ2xlIE1hcHMgQVBJLlxuICAgICAgICAgICAgICAgIGlmIChhbmNob3JCY3IgJiYgYW5jaG9yLmRhdGFzZXQub3JpZ2luID09PSAncmdtJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gc2FmZWx5IHR5cGVjYXN0IGhlcmUgc2luY2Ugd2UgY29udHJvbCB0aGF0IGVsZW1lbnQgYW5kIHdlIGtub3cgdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBpcyBhIGRpdlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbmNob3JEb21Db250ZW50ID0gKF9hID0gYW5jaG9yLmNvbnRlbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudEJjciA9IGFuY2hvckRvbUNvbnRlbnQgPT09IG51bGwgfHwgYW5jaG9yRG9tQ29udGVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5jaG9yRG9tQ29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2VudGVyIGluZm93aW5kb3cgYWJvdmUgbWFya2VyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvck9mZnNldFggPSBjb250ZW50QmNyLnggLVxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yQmNyLnggK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnRlbnRCY3Iud2lkdGggLSBhbmNob3JCY3Iud2lkdGgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yT2Zmc2V0WSA9IGNvbnRlbnRCY3IueSAtIGFuY2hvckJjci55O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRzID0gaW5mb1dpbmRvd09wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMucGl4ZWxPZmZzZXQgPSBuZXcgZ29vZ2xlLm1hcHMuU2l6ZShwaXhlbE9mZnNldCA/IHBpeGVsT2Zmc2V0WzBdICsgYW5jaG9yT2Zmc2V0WCA6IGFuY2hvck9mZnNldFgsIHBpeGVsT2Zmc2V0ID8gcGl4ZWxPZmZzZXRbMV0gKyBhbmNob3JPZmZzZXRZIDogYW5jaG9yT2Zmc2V0WSk7XG4gICAgICAgICAgICAgICAgICAgIGluZm9XaW5kb3cuc2V0T3B0aW9ucyhvcHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZEZvY3VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZW5PcHRpb25zLnNob3VsZEZvY3VzID0gc2hvdWxkRm9jdXM7XG4gICAgICAgIH1cbiAgICAgICAgaW5mb1dpbmRvdy5vcGVuKG9wZW5PcHRpb25zKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIC8vIE5vdGU6IHdoZW4gdGhlIGluZm93aW5kb3cgaGFzIGFuIGFuY2hvciwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IHNob3cgdXAgYWdhaW4gd2hlbiB0aGVcbiAgICAgICAgICAgIC8vIGFuY2hvciB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgYmVmb3JlIGluZm9XaW5kb3cuY2xvc2UoKSBpcyBjYWxsZWQgYnV0IHRoZSBpdCBnZXRzXG4gICAgICAgICAgICAvLyBhZGRlZCBiYWNrIHRvIHRoZSBtYXAgYWZ0ZXIgdGhhdC5cbiAgICAgICAgICAgIC8vIE1vcmUgaW5mb3JtYXRpb24gaGVyZTogaHR0cHM6Ly9pc3N1ZXRyYWNrZXIuZ29vZ2xlLmNvbS9pc3N1ZXMvMzQzNzUwODQ5XG4gICAgICAgICAgICBpZiAoaXNPcGVuZWRXaXRoQW5jaG9yKVxuICAgICAgICAgICAgICAgIGluZm9XaW5kb3cuc2V0KCdhbmNob3InLCBudWxsKTtcbiAgICAgICAgICAgIGluZm9XaW5kb3cuY2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbaW5mb1dpbmRvdywgYW5jaG9yLCBtYXAsIHNob3VsZEZvY3VzLCBpbmZvV2luZG93T3B0aW9ucywgcGl4ZWxPZmZzZXRdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGNvbnRlbnRDb250YWluZXJSZWYuY3VycmVudCAmJlxuICAgICAgICAgICAgY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250ZW50Q29udGFpbmVyUmVmLmN1cnJlbnQpLFxuICAgICAgICBoZWFkZXJDb250YWluZXJSZWYuY3VycmVudCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgY3JlYXRlUG9ydGFsKGhlYWRlckNvbnRlbnQsIGhlYWRlckNvbnRhaW5lclJlZi5jdXJyZW50KSkpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGEgbG9jYXRpb24gaW50byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBzdWl0YWJsZSBmb3IgR29vZ2xlIFN0YXRpYyBNYXBzIEFQSS5cbiAqXG4gKiBAcGFyYW0gbG9jYXRpb24gLSBUaGUgbG9jYXRpb24gdG8gZm9ybWF0LCBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIG9iamVjdCB3aXRoIGxhdC9sbmcgcHJvcGVydGllc1xuICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxvY2F0aW9uIGluIHRoZSBmb3JtYXQgXCJsYXQsbG5nXCIgb3IgdGhlIG9yaWdpbmFsIHN0cmluZ1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXR1cm5zIFwiNDAuNzE0NzI4LC03My45OTg2NzJcIlxuICogZm9ybWF0TG9jYXRpb24oeyBsYXQ6IDQwLjcxNDcyOCwgbG5nOiAtNzMuOTk4NjcyIH0pXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJldHVybnMgXCJOZXcgWW9yaywgTllcIlxuICogZm9ybWF0TG9jYXRpb24oXCJOZXcgWW9yaywgTllcIilcbiAqL1xuZnVuY3Rpb24gZm9ybWF0TG9jYXRpb24obG9jYXRpb24pIHtcbiAgICByZXR1cm4gdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGxvY2F0aW9uXG4gICAgICAgIDogYCR7bG9jYXRpb24ubGF0fSwke2xvY2F0aW9uLmxuZ31gO1xufVxuLy8gVXNlZCBmb3IgcmVtb3ZpbmcgdGhlIGxlYWRpbmcgcGlwZSBmcm9tIHRoZSBwYXJhbSBzdHJpbmdcbmZ1bmN0aW9uIGZvcm1hdFBhcmFtKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMSk7XG59XG5cbi8qKlxuICogQXNzZW1ibGVzIG1hcmtlciBwYXJhbWV0ZXJzIGZvciBzdGF0aWMgbWFwcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGFycmF5IG9mIG1hcmtlcnMgYW5kIGdyb3VwcyB0aGVtIGJ5IHRoZWlyIHN0eWxlIHByb3BlcnRpZXMuXG4gKiBJdCB0aGVuIGNyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlc2UgbWFya2VycywgaW5jbHVkaW5nIHRoZWlyIHN0eWxlcyBhbmQgbG9jYXRpb25zLFxuICogd2hpY2ggY2FuIGJlIHVzZWQgYXMgcGFyYW1ldGVycyBmb3Igc3RhdGljIG1hcCBBUElzLlxuICpcbiAqIEBwYXJhbSB7U3RhdGljTWFwc01hcmtlcltdfSBbbWFya2Vycz1bXV0gLSBBbiBhcnJheSBvZiBtYXJrZXJzIHRvIGJlIHByb2Nlc3NlZC4gRWFjaCBtYXJrZXIgY2FuIGhhdmUgcHJvcGVydGllcyBzdWNoIGFzIGNvbG9yLCBsYWJlbCwgc2l6ZSwgc2NhbGUsIGljb24sIGFuY2hvciwgYW5kIGxvY2F0aW9uLlxuICogQHJldHVybnMge3N0cmluZ1tdfSBBbiBhcnJheSBvZiBzdHJpbmdzLCBlYWNoIHJlcHJlc2VudGluZyBhIGdyb3VwIG9mIG1hcmtlcnMgd2l0aCB0aGVpciBzdHlsZXMgYW5kIGxvY2F0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbWFya2VycyA9IFtcbiAqICAgeyBjb2xvcjogJ2JsdWUnLCBsYWJlbDogJ0EnLCBzaXplOiAnbWlkJywgbG9jYXRpb246ICc0MC43MTQ3MjgsLTczLjk5ODY3MicgfSxcbiAqICAgeyBjb2xvcjogJ2JsdWUnLCBsYWJlbDogJ0InLCBzaXplOiAnbWlkJywgbG9jYXRpb246ICc0MC43MTQ3MjgsLTczLjk5ODY3MicgfSxcbiAqICAgeyBpY29uOiAnaHR0cDovL2V4YW1wbGUuY29tL2ljb24ucG5nJywgbG9jYXRpb246IHsgbGF0OiA0MC43MTQ3MjgsIGxuZzogLTczLjk5ODY3MiB9IH1cbiAqIF07XG4gKiBjb25zdCBwYXJhbXMgPSBhc3NlbWJsZU1hcmtlclBhcmFtcyhtYXJrZXJzKTtcbiAqIC8vIFBhcmFtcyB3aWxsIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBtYXJrZXIgcGFyYW1ldGVyc1xuICogRXhhbXBsZSBvdXRwdXQ6IFtcbiAqICAgXCJjb2xvcjpibHVlfGxhYmVsOkF8c2l6ZTptaWR8NDAuNzE0NzI4LC03My45OTg2NzJ8NDAuNzE0NzI4LC03My45OTg2NzJcIixcbiAqICAgXCJjb2xvcjpibHVlfGxhYmVsOkJ8c2l6ZTptaWR8NDAuNzE0NzI4LC03My45OTg2NzJ8NDAuNzE0NzI4LC03My45OTg2NzJcIixcbiAqICAgXCJpY29uOmh0dHA6Ly9leGFtcGxlLmNvbS9pY29uLnBuZ3w0MC43MTQ3MjgsLTczLjk5ODY3MlwiXG4gKiBdXG4gKi9cbmZ1bmN0aW9uIGFzc2VtYmxlTWFya2VyUGFyYW1zKG1hcmtlcnMgPSBbXSkge1xuICAgIGNvbnN0IG1hcmtlclBhcmFtcyA9IFtdO1xuICAgIC8vIEdyb3VwIG1hcmtlcnMgYnkgc3R5bGVcbiAgICBjb25zdCBtYXJrZXJzQnlTdHlsZSA9IG1hcmtlcnMgPT09IG51bGwgfHwgbWFya2VycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2Vycy5yZWR1Y2UoKHN0eWxlcywgbWFya2VyKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY29sb3IgPSAncmVkJywgbGFiZWwsIHNpemUsIHNjYWxlLCBpY29uLCBhbmNob3IgfSA9IG1hcmtlcjtcbiAgICAgICAgLy8gQ3JlYXRlIGEgdW5pcXVlIHN0eWxlIGtleSBiYXNlZCBvbiBlaXRoZXIgaWNvbiBwcm9wZXJ0aWVzIG9yIHN0YW5kYXJkIG1hcmtlciBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IHJlbGV2YW50UHJvcHMgPSBpY29uID8gW2ljb24sIGFuY2hvciwgc2NhbGVdIDogW2NvbG9yLCBsYWJlbCwgc2l6ZV07XG4gICAgICAgIGNvbnN0IGtleSA9IHJlbGV2YW50UHJvcHMuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJy0nKTtcbiAgICAgICAgc3R5bGVzW2tleV0gPSBzdHlsZXNba2V5XSB8fCBbXTtcbiAgICAgICAgc3R5bGVzW2tleV0ucHVzaChtYXJrZXIpO1xuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH0sIHt9KTtcbiAgICBPYmplY3QudmFsdWVzKG1hcmtlcnNCeVN0eWxlICE9PSBudWxsICYmIG1hcmtlcnNCeVN0eWxlICE9PSB2b2lkIDAgPyBtYXJrZXJzQnlTdHlsZSA6IHt9KS5mb3JFYWNoKG1hcmtlcnMgPT4ge1xuICAgICAgICBsZXQgbWFya2VyUGFyYW0gPSAnJztcbiAgICAgICAgY29uc3QgeyBpY29uIH0gPSBtYXJrZXJzWzBdO1xuICAgICAgICAvLyBDcmVhdGUgbWFya2VyIHN0eWxlIGZyb20gZmlyc3QgbWFya2VyIGluIGdyb3VwIHNpbmNlIGFsbCBtYXJrZXJzIHNoYXJlIHRoZSBzYW1lIHN0eWxlLlxuICAgICAgICBPYmplY3QuZW50cmllcyhtYXJrZXJzWzBdKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGljaCBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgYmFzZWQgb24gd2hldGhlciBtYXJrZXIgdXNlcyBjdXN0b20gaWNvblxuICAgICAgICAgICAgY29uc3QgcmVsZXZhbnRLZXlzID0gaWNvblxuICAgICAgICAgICAgICAgID8gWydpY29uJywgJ2FuY2hvcicsICdzY2FsZSddXG4gICAgICAgICAgICAgICAgOiBbJ2NvbG9yJywgJ2xhYmVsJywgJ3NpemUnXTtcbiAgICAgICAgICAgIGlmIChyZWxldmFudEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIG1hcmtlclBhcmFtICs9IGB8JHtrZXl9OiR7dmFsdWV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFkZCBsb2NhdGlvbiBjb29yZGluYXRlcyBmb3IgZWFjaCBtYXJrZXIgaW4gdGhlIHN0eWxlIGdyb3VwXG4gICAgICAgIC8vIEhhbmRsZXMgYm90aCBzdHJpbmcgbG9jYXRpb25zIGFuZCBsYXQvbG5nIG9iamVjdCBmb3JtYXRzLlxuICAgICAgICBmb3IgKGNvbnN0IG1hcmtlciBvZiBtYXJrZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHR5cGVvZiBtYXJrZXIubG9jYXRpb24gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBtYXJrZXIubG9jYXRpb25cbiAgICAgICAgICAgICAgICA6IGAke21hcmtlci5sb2NhdGlvbi5sYXR9LCR7bWFya2VyLmxvY2F0aW9uLmxuZ31gO1xuICAgICAgICAgICAgbWFya2VyUGFyYW0gKz0gYHwke2xvY2F0aW9ufWA7XG4gICAgICAgIH1cbiAgICAgICAgbWFya2VyUGFyYW1zLnB1c2gobWFya2VyUGFyYW0pO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXJrZXJQYXJhbXMubWFwKGZvcm1hdFBhcmFtKTtcbn1cblxuLy8gU3R5bGUgcHJvcGVydGllcyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIHBhdGhzIGluIHRoZSBTdGF0aWMgTWFwcyBBUElcbmNvbnN0IFBBVEhfU1RZTEVfS0VZUyA9IFsnY29sb3InLCAnd2VpZ2h0JywgJ2ZpbGxjb2xvcicsICdnZW9kZXNpYyddO1xuLyoqXG4gKiBCdWlsZHMgdGhlIHN0eWxlIHBvcnRpb24gb2YgYSBwYXRoIHBhcmFtZXRlciBzdHJpbmcuXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIG9iamVjdCBjb250YWluaW5nIHN0eWxlIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHdpdGggc3R5bGUgcGFyYW1ldGVycyBpbiB0aGUgZm9ybWF0IFwifGtleTp2YWx1ZVwiXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU3R5bGVQYXJhbXMocGF0aCkge1xuICAgIGxldCBzdHlsZVBhcmFtcyA9ICcnO1xuICAgIFBBVEhfU1RZTEVfS0VZUy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChwYXRoW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3R5bGVQYXJhbXMgKz0gYHwke2tleX06JHtwYXRoW2tleV19YDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHlsZVBhcmFtcztcbn1cbi8qKlxuICogQnVpbGRzIHRoZSBjb29yZGluYXRlcyBwb3J0aW9uIG9mIGEgcGF0aCBwYXJhbWV0ZXIgc3RyaW5nLlxuICogQHBhcmFtIGNvb3JkaW5hdGVzIC0gRWl0aGVyIGEgc3RyaW5nIG9yIGFycmF5IG9mIGxvY2F0aW9uIG9iamVjdHNcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHdpdGggY29vcmRpbmF0ZXMgaW4gdGhlIGZvcm1hdCBcInxsYXQsbG5nfGxhdCxsbmdcIlxuICovXG5mdW5jdGlvbiBidWlsZENvb3JkaW5hdGVQYXJhbXMoY29vcmRpbmF0ZXMpIHtcbiAgICBpZiAodHlwZW9mIGNvb3JkaW5hdGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYHwke2RlY29kZVVSSUNvbXBvbmVudChjb29yZGluYXRlcyl9YDtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzLm1hcChsb2NhdGlvbiA9PiBgfCR7Zm9ybWF0TG9jYXRpb24obG9jYXRpb24pfWApLmpvaW4oJycpO1xufVxuLyoqXG4gKiBBc3NlbWJsZXMgcGF0aCBwYXJhbWV0ZXJzIGZvciB0aGUgU3RhdGljIE1hcHMgQVBJIGZyb20gYW4gYXJyYXkgb2YgcGF0aHMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjb25zdHJ1Y3RzIGEgc3RyaW5nIG9mIHBhdGggcGFyYW1ldGVycyBmb3IgZWFjaCBwYXRoLiBFYWNoIHBhdGggcGFyYW1ldGVyIHN0cmluZ1xuICogaW5jbHVkZXMgdGhlIHN0eWxlIHByb3BlcnRpZXMgYW5kIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcGF0aHMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxTdGF0aWNNYXBzUGF0aD59IFtwYXRocz1bXV0gLSBBbiBhcnJheSBvZiBwYXRocyB0byBiZSBhc3NlbWJsZWQgaW50byBwYXRoIHBhcmFtZXRlcnMuXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gQW4gYXJyYXkgb2YgcGF0aCBwYXJhbWV0ZXIgc3RyaW5ncy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcGF0aHMgPSBbXG4gKiAgIHtcbiAqICAgICBjb2xvcjogJ3JlZCcsXG4gKiAgICAgd2VpZ2h0OiA1LFxuICogICAgIGNvb3JkaW5hdGVzOiBbXG4gKiAgICAgICB7IGxhdDogNDAuNzE0NzI4LCBsbmc6IC03My45OTg2NzIgfSxcbiAqICAgICAgIHsgbGF0OiA0MC43MTgyMTcsIGxuZzogLTczLjk5ODI4NCB9XG4gKiAgICAgXVxuICogICB9XG4gKiBdO1xuICpcbiAqIGNvbnN0IHBhdGhQYXJhbXMgPSBhc3NlbWJsZVBhdGhQYXJhbXMocGF0aHMpO1xuICogLy8gT3V0cHV0OiBbJ2NvbG9yOnJlZHx3ZWlnaHQ6NXw0MC43MTQ3MjgsLTczLjk5ODY3Mnw0MC43MTgyMTcsLTczLjk5ODI4NCddXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gYXNzZW1ibGVQYXRoUGFyYW1zKHBhdGhzID0gW10pIHtcbiAgICByZXR1cm4gcGF0aHMubWFwKHBhdGggPT4ge1xuICAgICAgICBjb25zdCBzdHlsZVBhcmFtcyA9IGJ1aWxkU3R5bGVQYXJhbXMocGF0aCk7XG4gICAgICAgIGNvbnN0IGNvb3JkaW5hdGVQYXJhbXMgPSBidWlsZENvb3JkaW5hdGVQYXJhbXMocGF0aC5jb29yZGluYXRlcyk7XG4gICAgICAgIGNvbnN0IHBhdGhQYXJhbSA9IHN0eWxlUGFyYW1zICsgY29vcmRpbmF0ZVBhcmFtcztcbiAgICAgICAgcmV0dXJuIGZvcm1hdFBhcmFtKHBhdGhQYXJhbSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgb2YgR29vZ2xlIE1hcHMgc3R5bGUgb2JqZWN0cyBpbnRvIGFuIGFycmF5IG9mIHN0eWxlIHN0cmluZ3NcbiAqIGNvbXBhdGlibGUgd2l0aCB0aGUgR29vZ2xlIFN0YXRpYyBNYXBzIEFQSS5cbiAqXG4gKiBAcGFyYW0gc3R5bGVzIC0gQW4gYXJyYXkgb2YgR29vZ2xlIE1hcHMgTWFwVHlwZVN0eWxlIG9iamVjdHMgdGhhdCBkZWZpbmUgdGhlIHN0eWxpbmcgcnVsZXNcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGZvcm1hdHRlZCBzdHlsZSBzdHJpbmdzIHJlYWR5IHRvIGJlIHVzZWQgd2l0aCB0aGUgU3RhdGljIE1hcHMgQVBJXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHN0eWxlcyA9IFt7XG4gKiAgIGZlYXR1cmVUeXBlOiBcInJvYWRcIixcbiAqICAgZWxlbWVudFR5cGU6IFwiZ2VvbWV0cnlcIixcbiAqICAgc3R5bGVyczogW3tjb2xvcjogXCIjZmYwMDAwXCJ9LCB7d2VpZ2h0OiAxfV1cbiAqIH1dO1xuICpcbiAqIGNvbnN0IHN0eWxlU3RyaW5ncyA9IGFzc2VtYmxlTWFwVHlwZVN0eWxlcyhzdHlsZXMpO1xuICogLy8gUmV0dXJuczogW1wifGZlYXR1cmU6cm9hZHxlbGVtZW50Omdlb21ldHJ5fGNvbG9yOjB4ZmYwMDAwfHdlaWdodDoxXCJdXG4gKlxuICogRWFjaCBzdHlsZSBzdHJpbmcgZm9sbG93cyB0aGUgZm9ybWF0OlxuICogXCJmZWF0dXJlOntmZWF0dXJlVHlwZX18ZWxlbWVudDp7ZWxlbWVudFR5cGV9fHtzdHlsZXJOYW1lfTp7c3R5bGVyVmFsdWV9XCJcbiAqXG4gKiBOb3RlOiBDb2xvciB2YWx1ZXMgd2l0aCBoZXhhZGVjaW1hbCBub3RhdGlvbiAoIykgYXJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkXG4gKiB0byB0aGUgcmVxdWlyZWQgMHggZm9ybWF0IGZvciB0aGUgU3RhdGljIE1hcHMgQVBJLlxuICovXG5mdW5jdGlvbiBhc3NlbWJsZU1hcFR5cGVTdHlsZXMoc3R5bGVzKSB7XG4gICAgcmV0dXJuIHN0eWxlc1xuICAgICAgICAubWFwKChtYXBUeXBlU3R5bGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBmZWF0dXJlVHlwZSwgZWxlbWVudFR5cGUsIHN0eWxlcnMgPSBbXSB9ID0gbWFwVHlwZVN0eWxlO1xuICAgICAgICBsZXQgc3R5bGVTdHJpbmcgPSAnJztcbiAgICAgICAgaWYgKGZlYXR1cmVUeXBlKSB7XG4gICAgICAgICAgICBzdHlsZVN0cmluZyArPSBgfGZlYXR1cmU6JHtmZWF0dXJlVHlwZX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50VHlwZSkge1xuICAgICAgICAgICAgc3R5bGVTdHJpbmcgKz0gYHxlbGVtZW50OiR7ZWxlbWVudFR5cGV9YDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHN0eWxlciBvZiBzdHlsZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhzdHlsZXIpLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBzdHlsZVN0cmluZyArPSBgfCR7bmFtZX06JHtTdHJpbmcodmFsdWUpLnJlcGxhY2UoJyMnLCAnMHgnKX1gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlU3RyaW5nO1xuICAgIH0pXG4gICAgICAgIC5tYXAoZm9ybWF0UGFyYW0pO1xufVxuXG5jb25zdCBTVEFUSUNfTUFQU19CQVNFID0gJ2h0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9zdGF0aWNtYXAnO1xuLyoqXG4gKiBDcmVhdGVzIGEgVVJMIGZvciB0aGUgR29vZ2xlIFN0YXRpYyBNYXBzIEFQSSB3aXRoIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBzdGF0aWMgbWFwXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5hcGlLZXkgLSBZb3VyIEdvb2dsZSBNYXBzIEFQSSBrZXkgKHJlcXVpcmVkKVxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMud2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIG1hcCBpbWFnZSBpbiBwaXhlbHMgKHJlcXVpcmVkKVxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgbWFwIGltYWdlIGluIHBpeGVscyAocmVxdWlyZWQpXG4gKiBAcGFyYW0ge1N0YXRpY01hcHNMb2NhdGlvbn0gW29wdGlvbnMuY2VudGVyXSAtIFRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIG1hcCAobGF0L2xuZyBvciBhZGRyZXNzKS5cbiAqICBSZXF1aXJlZCBpZiBubyBtYXJrZXJzIG9yIHBhdGhzIG9yIFwidmlzaWJsZSBsb2NhdGlvbnNcIiBhcmUgcHJvdmlkZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuem9vbV0gLSBUaGUgem9vbSBsZXZlbCBvZiB0aGUgbWFwLiBSZXF1aXJlZCBpZiBubyBtYXJrZXJzIG9yIHBhdGhzIG9yIFwidmlzaWJsZSBsb2NhdGlvbnNcIiBhcmUgcHJvdmlkZWQuXG4gKiBAcGFyYW0gezF8Mnw0fSBbb3B0aW9ucy5zY2FsZV0gLSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgbWFwICgxLCAyLCBvciA0KVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZvcm1hdF0gLSBUaGUgaW1hZ2UgZm9ybWF0IChwbmcsIHBuZzgsIHBuZzMyLCBnaWYsIGpwZywganBnLWJhc2VsaW5lKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcFR5cGVdIC0gVGhlIHR5cGUgb2YgbWFwIChyb2FkbWFwLCBzYXRlbGxpdGUsIHRlcnJhaW4sIGh5YnJpZClcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZV0gLSBUaGUgbGFuZ3VhZ2Ugb2YgdGhlIG1hcCBsYWJlbHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZWdpb25dIC0gVGhlIHJlZ2lvbiBjb2RlIGZvciB0aGUgbWFwXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWFwX2lkXSAtIFRoZSBDbG91ZC1iYXNlZCBtYXAgc3R5bGUgSURcbiAqIEBwYXJhbSB7U3RhdGljTWFwc01hcmtlcltdfSBbb3B0aW9ucy5tYXJrZXJzPVtdXSAtIEFycmF5IG9mIG1hcmtlcnMgdG8gZGlzcGxheSBvbiB0aGUgbWFwXG4gKiBAcGFyYW0ge1N0YXRpY01hcHNQYXRoW119IFtvcHRpb25zLnBhdGhzPVtdXSAtIEFycmF5IG9mIHBhdGhzIHRvIGRpc3BsYXkgb24gdGhlIG1hcFxuICogQHBhcmFtIHtTdGF0aWNNYXBzTG9jYXRpb25bXX0gW29wdGlvbnMudmlzaWJsZT1bXV0gLSBBcnJheSBvZiBsb2NhdGlvbnMgdGhhdCBzaG91bGQgYmUgdmlzaWJsZSBvbiB0aGUgbWFwXG4gKiBAcGFyYW0ge01hcFR5cGVTdHlsZVtdfSBbb3B0aW9ucy5zdHlsZT1bXV0gLSBBcnJheSBvZiBzdHlsZSBvYmplY3RzIHRvIGN1c3RvbWl6ZSB0aGUgbWFwIGFwcGVhcmFuY2VcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tcGxldGUgR29vZ2xlIFN0YXRpYyBNYXBzIEFQSSBVUkxcbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgQVBJIGtleSBpcyBub3QgcHJvdmlkZWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB3aWR0aCBvciBoZWlnaHQgaXMgbm90IHByb3ZpZGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHVybCA9IGNyZWF0ZVN0YXRpY01hcHNVcmwoe1xuICogICBhcGlLZXk6ICdZT1VSX0FQSV9LRVknLFxuICogICB3aWR0aDogNjAwLFxuICogICBoZWlnaHQ6IDQwMCxcbiAqICAgY2VudGVyOiB7IGxhdDogNDAuNzE0NzI4LCBsbmc6IC03My45OTg2NzIgfSxcbiAqICAgem9vbTogMTIsXG4gKiAgIG1hcmtlcnM6IFtcbiAqICAgICB7XG4gKiAgICAgICBsb2NhdGlvbjogeyBsYXQ6IDQwLjcxNDcyOCwgbG5nOiAtNzMuOTk4NjcyIH0sXG4gKiAgICAgICBjb2xvcjogJ3JlZCcsXG4gKiAgICAgICBsYWJlbDogJ0EnXG4gKiAgICAgfVxuICogICBdLFxuICogICBwYXRoczogW1xuICogICAgIHtcbiAqICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gKiAgICAgICAgIHsgbGF0OiA0MC43MTQ3MjgsIGxuZzogLTczLjk5ODY3MiB9LFxuICogICAgICAgICB7IGxhdDogNDAuNzE5NzI4LCBsbmc6IC03My45OTE2NzIgfVxuICogICAgICAgXSxcbiAqICAgICAgIGNvbG9yOiAnMHgwMDAwZmYnLFxuICogICAgICAgd2VpZ2h0OiA1XG4gKiAgICAgfVxuICogICBdLFxuICogICBzdHlsZTogW1xuICogICAgIHtcbiAqICAgICAgIGZlYXR1cmVUeXBlOiAncm9hZCcsXG4gKiAgICAgICBlbGVtZW50VHlwZTogJ2dlb21ldHJ5JyxcbiAqICAgICAgIHN0eWxlcnM6IFt7Y29sb3I6ICcjMDBmZjAwJ31dXG4gKiAgICAgfVxuICogICBdXG4gKiB9KTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluIFVSTCBzaW1pbGFyIHRvOlxuICogLy8gaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL3N0YXRpY21hcD9rZXk9WU9VUl9BUElfS0VZXG4gKiAvLyAmc2l6ZT02MDB4NDAwXG4gKiAvLyAmY2VudGVyPTQwLjcxNDcyOCwtNzMuOTk4NjcyJnpvb209MTJcbiAqIC8vICZtYXJrZXJzPWNvbG9yOnJlZHxsYWJlbDpBfDQwLjcxNDcyOCwtNzMuOTk4NjcyXG4gKiAvLyAmcGF0aD1jb2xvcjoweDAwMDBmZnx3ZWlnaHQ6NXw0MC43MTQ3MjgsLTczLjk5ODY3Mnw0MC43MTk3MjgsLTczLjk5MTY3MlxuICogLy8gJnN0eWxlPWZlYXR1cmU6cm9hZHxlbGVtZW50Omdlb21ldHJ5fGNvbG9yOjB4MDBmZjAwXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY01hcHNVcmwoeyBhcGlLZXksIHdpZHRoLCBoZWlnaHQsIGNlbnRlciwgem9vbSwgc2NhbGUsIGZvcm1hdCwgbWFwVHlwZSwgbGFuZ3VhZ2UsIHJlZ2lvbiwgbWFwSWQsIG1hcmtlcnMgPSBbXSwgcGF0aHMgPSBbXSwgdmlzaWJsZSA9IFtdLCBzdHlsZSA9IFtdIH0pIHtcbiAgICBpZiAoIWFwaUtleSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0FQSSBrZXkgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV2lkdGggYW5kIGhlaWdodCBhcmUgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsga2V5OiBhcGlLZXksIHNpemU6IGAke3dpZHRofXgke2hlaWdodH1gIH0sIChjZW50ZXIgJiYgeyBjZW50ZXI6IGZvcm1hdExvY2F0aW9uKGNlbnRlcikgfSkpLCAoem9vbSAmJiB7IHpvb20gfSkpLCAoc2NhbGUgJiYgeyBzY2FsZSB9KSksIChmb3JtYXQgJiYgeyBmb3JtYXQgfSkpLCAobWFwVHlwZSAmJiB7IG1hcHR5cGU6IG1hcFR5cGUgfSkpLCAobGFuZ3VhZ2UgJiYgeyBsYW5ndWFnZSB9KSksIChyZWdpb24gJiYgeyByZWdpb24gfSkpLCAobWFwSWQgJiYgeyBtYXBfaWQ6IG1hcElkIH0pKTtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKFNUQVRJQ19NQVBTX0JBU0UpO1xuICAgIC8vIFBhcmFtcyB0aGF0IGRvbid0IG5lZWQgc3BlY2lhbCBoYW5kbGluZ1xuICAgIE9iamVjdC5lbnRyaWVzKHBhcmFtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgfSk7XG4gICAgLy8gQXNzZW1ibGUgTWFya2Vyc1xuICAgIGZvciAoY29uc3QgbWFya2VyUGFyYW0gb2YgYXNzZW1ibGVNYXJrZXJQYXJhbXMobWFya2VycykpIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ21hcmtlcnMnLCBtYXJrZXJQYXJhbSk7XG4gICAgfVxuICAgIC8vIEFzc2VtYmxlIFBhdGhzXG4gICAgZm9yIChjb25zdCBwYXRoUGFyYW0gb2YgYXNzZW1ibGVQYXRoUGFyYW1zKHBhdGhzKSkge1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgncGF0aCcsIHBhdGhQYXJhbSk7XG4gICAgfVxuICAgIC8vIEFzc2VtYmxlIHZpc2libGUgbG9jYXRpb25zXG4gICAgaWYgKHZpc2libGUubGVuZ3RoKSB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCd2aXNpYmxlJywgdmlzaWJsZS5tYXAobG9jYXRpb24gPT4gZm9ybWF0TG9jYXRpb24obG9jYXRpb24pKS5qb2luKCd8JykpO1xuICAgIH1cbiAgICAvLyBBc3NlbWJsZSBNYXAgVHlwZSBTdHlsZXNcbiAgICBmb3IgKGNvbnN0IHN0eWxlU3RyaW5nIG9mIGFzc2VtYmxlTWFwVHlwZVN0eWxlcyhzdHlsZSkpIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3N0eWxlJywgc3R5bGVTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG59XG5cbmNvbnN0IFN0YXRpY01hcCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgdXJsLCBjbGFzc05hbWUgfSA9IHByb3BzO1xuICAgIGlmICghdXJsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTCBpcyByZXF1aXJlZCcpO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsIHNyYzogdXJsLCB3aWR0aDogXCIxMDAlXCIgfSk7XG59O1xuXG4vKipcbiAqIENvcHkgb2YgdGhlIGBnb29nbGUubWFwcy5Db250cm9sUG9zaXRpb25gIGNvbnN0YW50cy5cbiAqIFRoZXkgaGF2ZSB0byBiZSBkdXBsaWNhdGVkIGhlcmUgc2luY2Ugd2UgY2FuJ3Qgd2FpdCBmb3IgdGhlIG1hcHMgQVBJIHRvIGxvYWQgdG8gYmUgYWJsZSB0byB1c2UgdGhlbS5cbiAqL1xuY29uc3QgQ29udHJvbFBvc2l0aW9uID0ge1xuICAgIFRPUF9MRUZUOiAxLFxuICAgIFRPUF9DRU5URVI6IDIsXG4gICAgVE9QOiAyLFxuICAgIFRPUF9SSUdIVDogMyxcbiAgICBMRUZUX0NFTlRFUjogNCxcbiAgICBMRUZUX1RPUDogNSxcbiAgICBMRUZUOiA1LFxuICAgIExFRlRfQk9UVE9NOiA2LFxuICAgIFJJR0hUX1RPUDogNyxcbiAgICBSSUdIVDogNyxcbiAgICBSSUdIVF9DRU5URVI6IDgsXG4gICAgUklHSFRfQk9UVE9NOiA5LFxuICAgIEJPVFRPTV9MRUZUOiAxMCxcbiAgICBCT1RUT01fQ0VOVEVSOiAxMSxcbiAgICBCT1RUT006IDExLFxuICAgIEJPVFRPTV9SSUdIVDogMTIsXG4gICAgQ0VOVEVSOiAxMyxcbiAgICBCTE9DS19TVEFSVF9JTkxJTkVfU1RBUlQ6IDE0LFxuICAgIEJMT0NLX1NUQVJUX0lOTElORV9DRU5URVI6IDE1LFxuICAgIEJMT0NLX1NUQVJUX0lOTElORV9FTkQ6IDE2LFxuICAgIElOTElORV9TVEFSVF9CTE9DS19DRU5URVI6IDE3LFxuICAgIElOTElORV9TVEFSVF9CTE9DS19TVEFSVDogMTgsXG4gICAgSU5MSU5FX1NUQVJUX0JMT0NLX0VORDogMTksXG4gICAgSU5MSU5FX0VORF9CTE9DS19TVEFSVDogMjAsXG4gICAgSU5MSU5FX0VORF9CTE9DS19DRU5URVI6IDIxLFxuICAgIElOTElORV9FTkRfQkxPQ0tfRU5EOiAyMixcbiAgICBCTE9DS19FTkRfSU5MSU5FX1NUQVJUOiAyMyxcbiAgICBCTE9DS19FTkRfSU5MSU5FX0NFTlRFUjogMjQsXG4gICAgQkxPQ0tfRU5EX0lOTElORV9FTkQ6IDI1XG59O1xuY29uc3QgTWFwQ29udHJvbCA9ICh7IGNoaWxkcmVuLCBwb3NpdGlvbiB9KSA9PiB7XG4gICAgY29uc3QgY29udHJvbENvbnRhaW5lciA9IHVzZU1lbW8oKCkgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIFtdKTtcbiAgICBjb25zdCBtYXAgPSB1c2VNYXAoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW1hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY29udHJvbHMgPSBtYXAuY29udHJvbHNbcG9zaXRpb25dO1xuICAgICAgICBjb250cm9scy5wdXNoKGNvbnRyb2xDb250YWluZXIpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udHJvbHNBcnJheSA9IGNvbnRyb2xzLmdldEFycmF5KCk7XG4gICAgICAgICAgICAvLyBjb250cm9sc0FycmF5IGNvdWxkIGJlIHVuZGVmaW5lZCBpZiB0aGUgbWFwIGlzIGluIGFuIHVuZGVmaW5lZCBzdGF0ZSAoZS5nLiBpbnZhbGlkIEFQSS1rZXksIHNlZSAjMjc2XG4gICAgICAgICAgICBpZiAoIWNvbnRyb2xzQXJyYXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjb250cm9sc0FycmF5LmluZGV4T2YoY29udHJvbENvbnRhaW5lcik7XG4gICAgICAgICAgICBjb250cm9scy5yZW1vdmVBdChpbmRleCk7XG4gICAgICAgIH07XG4gICAgfSwgW2NvbnRyb2xDb250YWluZXIsIG1hcCwgcG9zaXRpb25dKTtcbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250cm9sQ29udGFpbmVyKTtcbn07XG5cbmZ1bmN0aW9uIHVzZU1hcmtlcihwcm9wcykge1xuICAgIGNvbnN0IFttYXJrZXIsIHNldE1hcmtlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBtYXAgPSB1c2VNYXAoKTtcbiAgICBjb25zdCB7IG9uQ2xpY2ssIG9uRHJhZywgb25EcmFnU3RhcnQsIG9uRHJhZ0VuZCwgb25Nb3VzZU92ZXIsIG9uTW91c2VPdXQgfSA9IHByb3BzLCBtYXJrZXJPcHRpb25zID0gX19yZXN0KHByb3BzLCBbXCJvbkNsaWNrXCIsIFwib25EcmFnXCIsIFwib25EcmFnU3RhcnRcIiwgXCJvbkRyYWdFbmRcIiwgXCJvbk1vdXNlT3ZlclwiLCBcIm9uTW91c2VPdXRcIl0pO1xuICAgIGNvbnN0IHsgcG9zaXRpb24sIGRyYWdnYWJsZSB9ID0gbWFya2VyT3B0aW9ucztcbiAgICAvLyBjcmVhdGUgbWFya2VyIGluc3RhbmNlIGFuZCBhZGQgdG8gdGhlIG1hcCBvbmNlIHRoZSBtYXAgaXMgYXZhaWxhYmxlXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgIGlmIChtYXAgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCc8TWFya2VyPiBoYXMgdG8gYmUgaW5zaWRlIGEgTWFwIGNvbXBvbmVudC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdNYXJrZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKG1hcmtlck9wdGlvbnMpO1xuICAgICAgICBuZXdNYXJrZXIuc2V0TWFwKG1hcCk7XG4gICAgICAgIHNldE1hcmtlcihuZXdNYXJrZXIpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbmV3TWFya2VyLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIHNldE1hcmtlcihudWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gcmUtcmVuZGVyIHRoZSB3aG9sZSBtYXJrZXIgd2hlbiB0aGUgb3B0aW9ucyBjaGFuZ2UuXG4gICAgICAgIC8vIE1hcmtlciBvcHRpb25zIHVwZGF0ZSBpcyBoYW5kbGVkIGluIGEgdXNlRWZmZWN0IGJlbG93LlxuICAgICAgICAvLyBFeGNsdWRpbmcgbWFya2VyT3B0aW9ucyBmcm9tIGRlcGVuZGVuY3kgYXJyYXkgb24gcHVycG9zZSBoZXJlLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW21hcF0pO1xuICAgIC8vIGF0dGFjaCBhbmQgcmUtYXR0YWNoIGV2ZW50LWhhbmRsZXJzIHdoZW4gYW55IG9mIHRoZSBwcm9wZXJ0aWVzIGNoYW5nZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFya2VyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBtID0gbWFya2VyO1xuICAgICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIGNvbnN0IGdtZSA9IGdvb2dsZS5tYXBzLmV2ZW50O1xuICAgICAgICBpZiAob25DbGljaylcbiAgICAgICAgICAgIGdtZS5hZGRMaXN0ZW5lcihtLCAnY2xpY2snLCBvbkNsaWNrKTtcbiAgICAgICAgaWYgKG9uRHJhZylcbiAgICAgICAgICAgIGdtZS5hZGRMaXN0ZW5lcihtLCAnZHJhZycsIG9uRHJhZyk7XG4gICAgICAgIGlmIChvbkRyYWdTdGFydClcbiAgICAgICAgICAgIGdtZS5hZGRMaXN0ZW5lcihtLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpO1xuICAgICAgICBpZiAob25EcmFnRW5kKVxuICAgICAgICAgICAgZ21lLmFkZExpc3RlbmVyKG0sICdkcmFnZW5kJywgb25EcmFnRW5kKTtcbiAgICAgICAgaWYgKG9uTW91c2VPdmVyKVxuICAgICAgICAgICAgZ21lLmFkZExpc3RlbmVyKG0sICdtb3VzZW92ZXInLCBvbk1vdXNlT3Zlcik7XG4gICAgICAgIGlmIChvbk1vdXNlT3V0KVxuICAgICAgICAgICAgZ21lLmFkZExpc3RlbmVyKG0sICdtb3VzZW91dCcsIG9uTW91c2VPdXQpO1xuICAgICAgICBtYXJrZXIuc2V0RHJhZ2dhYmxlKEJvb2xlYW4oZHJhZ2dhYmxlKSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBnbWUuY2xlYXJJbnN0YW5jZUxpc3RlbmVycyhtKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIG1hcmtlcixcbiAgICAgICAgZHJhZ2dhYmxlLFxuICAgICAgICBvbkNsaWNrLFxuICAgICAgICBvbkRyYWcsXG4gICAgICAgIG9uRHJhZ1N0YXJ0LFxuICAgICAgICBvbkRyYWdFbmQsXG4gICAgICAgIG9uTW91c2VPdmVyLFxuICAgICAgICBvbk1vdXNlT3V0XG4gICAgXSk7XG4gICAgLy8gdXBkYXRlIG1hcmtlck9wdGlvbnMgKG5vdGUgdGhlIGRlcGVuZGVuY2llcyBhcmVuJ3QgcHJvcGVybHkgY2hlY2tlZFxuICAgIC8vIGhlcmUsIHdlIGp1c3QgYXNzdW1lIHRoYXQgc2V0T3B0aW9ucyBpcyBzbWFydCBlbm91Z2ggdG8gbm90IHdhc3RlIGFcbiAgICAvLyBsb3Qgb2YgdGltZSB1cGRhdGluZyB2YWx1ZXMgdGhhdCBkaWRuJ3QgY2hhbmdlKVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghbWFya2VyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAobWFya2VyT3B0aW9ucylcbiAgICAgICAgICAgIG1hcmtlci5zZXRPcHRpb25zKG1hcmtlck9wdGlvbnMpO1xuICAgIH0sIFttYXJrZXIsIG1hcmtlck9wdGlvbnNdKTtcbiAgICAvLyB1cGRhdGUgcG9zaXRpb24gd2hlbiBjaGFuZ2VkXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gU2hvdWxkIG5vdCB1cGRhdGUgcG9zaXRpb24gd2hlbiBkcmFnZ2FibGVcbiAgICAgICAgaWYgKGRyYWdnYWJsZSB8fCAhcG9zaXRpb24gfHwgIW1hcmtlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbWFya2VyLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB9LCBbZHJhZ2dhYmxlLCBwb3NpdGlvbiwgbWFya2VyXSk7XG4gICAgcmV0dXJuIG1hcmtlcjtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRvIHJlbmRlciBhIG1hcmtlciBvbiBhIG1hcFxuICovXG5jb25zdCBNYXJrZXIgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gICAgY29uc3QgbWFya2VyID0gdXNlTWFya2VyKHByb3BzKTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gbWFya2VyLCBbbWFya2VyXSk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwpO1xufSk7XG5NYXJrZXIuZGlzcGxheU5hbWUgPSAnTWFya2VyJztcbmZ1bmN0aW9uIHVzZU1hcmtlclJlZigpIHtcbiAgICBjb25zdCBbbWFya2VyLCBzZXRNYXJrZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgcmVmQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaygobSkgPT4ge1xuICAgICAgICBzZXRNYXJrZXIobSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBbcmVmQ2FsbGJhY2ssIG1hcmtlcl07XG59XG5cbi8qKlxuICogQ29tcG9uZW50IHRvIGNvbmZpZ3VyZSB0aGUgYXBwZWFyYW5jZSBvZiBhbiBBZHZhbmNlZE1hcmtlclxuICovXG5jb25zdCBQaW4gPSBwcm9wcyA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFkdmFuY2VkTWFya2VyID0gKF9hID0gdXNlQ29udGV4dChBZHZhbmNlZE1hcmtlckNvbnRleHQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFya2VyO1xuICAgIGNvbnN0IGdseXBoQ29udGFpbmVyID0gdXNlTWVtbygoKSA9PiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgW10pO1xuICAgIC8vIENyZWF0ZSBQaW4gVmlldyBpbnN0YW5jZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFhZHZhbmNlZE1hcmtlcikge1xuICAgICAgICAgICAgaWYgKGFkdmFuY2VkTWFya2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgPFBpbj4gY29tcG9uZW50IGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIDxBZHZhbmNlZE1hcmtlcj4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLmdseXBoICYmIHByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsb2dFcnJvck9uY2UoJ1RoZSA8UGluPiBjb21wb25lbnQgb25seSB1c2VzIGNoaWxkcmVuIHRvIHJlbmRlciB0aGUgZ2x5cGggaWYgYm90aCB0aGUgZ2x5cGggcHJvcGVydHkgYW5kIGNoaWxkcmVuIGFyZSBwcmVzZW50LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChDaGlsZHJlbi5jb3VudChwcm9wcy5jaGlsZHJlbikgPiAxKSB7XG4gICAgICAgICAgICBsb2dFcnJvck9uY2UoJ1Bhc3NpbmcgbXVsdGlwbGUgY2hpbGRyZW4gdG8gdGhlIDxQaW4+IGNvbXBvbmVudCBtaWdodCBsZWFkIHRvIHVuZXhwZWN0ZWQgcmVzdWx0cy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaW5WaWV3T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzKTtcbiAgICAgICAgY29uc3QgcGluRWxlbWVudCA9IG5ldyBnb29nbGUubWFwcy5tYXJrZXIuUGluRWxlbWVudChwaW5WaWV3T3B0aW9ucyk7XG4gICAgICAgIC8vIFNldCBnbHlwaCB0byBnbHlwaCBjb250YWluZXIgaWYgY2hpbGRyZW4gYXJlIHByZXNlbnQgKHJlbmRlcmVkIHZpYSBwb3J0YWwpLlxuICAgICAgICAvLyBJZiBib3RoIHByb3BzLmdseXBoIGFuZCBwcm9wcy5jaGlsZHJlbiBhcmUgcHJlc2VudCwgcHJvcHMuY2hpbGRyZW4gdGFrZXMgcHJpb3JpdHkuXG4gICAgICAgIGlmIChwcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgcGluRWxlbWVudC5nbHlwaCA9IGdseXBoQ29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBjb250ZW50IG9mIEFkdmFuY2VkIE1hcmtlciBWaWV3IHRvIHRoZSBQaW4gVmlldyBlbGVtZW50XG4gICAgICAgIC8vIEhlcmUgd2UgYXJlIHNlbGVjdGluZyB0aGUgYW5jaG9yIGNvbnRhaW5lci5cbiAgICAgICAgLy8gVGhlIGhpZXJhcmNoeSBpcyBhcyBmb2xsb3dzOlxuICAgICAgICAvLyBcImFkdmFuY2VkTWFya2VyLmNvbnRlbnRcIiAoZnJvbSBnb29nbGUpIC0+IFwiYW5jaG9yIGNvbnRhaW5lclwiXG4gICAgICAgIGNvbnN0IG1hcmtlckNvbnRlbnQgPSAoX2EgPSBhZHZhbmNlZE1hcmtlci5jb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKG1hcmtlckNvbnRlbnQgPT09IG51bGwgfHwgbWFya2VyQ29udGVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyQ29udGVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBtYXJrZXJDb250ZW50LnJlbW92ZUNoaWxkKG1hcmtlckNvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlckNvbnRlbnQpIHtcbiAgICAgICAgICAgIG1hcmtlckNvbnRlbnQuYXBwZW5kQ2hpbGQocGluRWxlbWVudC5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH0sIFthZHZhbmNlZE1hcmtlciwgZ2x5cGhDb250YWluZXIsIHByb3BzXSk7XG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChwcm9wcy5jaGlsZHJlbiwgZ2x5cGhDb250YWluZXIpO1xufTtcblxuY29uc3QgbWFwTGluZWFyID0gKHgsIGExLCBhMiwgYjEsIGIyKSA9PiBiMSArICgoeCAtIGExKSAqIChiMiAtIGIxKSkgLyAoYTIgLSBhMSk7XG5jb25zdCBnZXRNYXBNYXhUaWx0ID0gKHpvb20pID0+IHtcbiAgICBpZiAoem9vbSA8PSAxMCkge1xuICAgICAgICByZXR1cm4gMzA7XG4gICAgfVxuICAgIGlmICh6b29tID49IDE1LjUpIHtcbiAgICAgICAgcmV0dXJuIDY3LjU7XG4gICAgfVxuICAgIC8vIHJhbmdlIFsxMC4uLjE0XVxuICAgIGlmICh6b29tIDw9IDE0KSB7XG4gICAgICAgIHJldHVybiBtYXBMaW5lYXIoem9vbSwgMTAsIDE0LCAzMCwgNDUpO1xuICAgIH1cbiAgICAvLyByYW5nZSBbMTQuLi4xNS41XVxuICAgIHJldHVybiBtYXBMaW5lYXIoem9vbSwgMTQsIDE1LjUsIDQ1LCA2Ny41KTtcbn07XG4vKipcbiAqIEZ1bmN0aW9uIHRvIGxpbWl0IHRoZSB0aWx0IHJhbmdlIG9mIHRoZSBHb29nbGUgbWFwIHdoZW4gdXBkYXRpbmcgdGhlIHZpZXcgc3RhdGVcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGxpbWl0VGlsdFJhbmdlID0gKHsgdmlld1N0YXRlIH0pID0+IHtcbiAgICBjb25zdCBwaXRjaCA9IHZpZXdTdGF0ZS5waXRjaDtcbiAgICBjb25zdCBnbVpvb20gPSB2aWV3U3RhdGUuem9vbSArIDE7XG4gICAgY29uc3QgbWF4VGlsdCA9IGdldE1hcE1heFRpbHQoZ21ab29tKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2aWV3U3RhdGUpLCB7IGZvdnk6IDI1LCBwaXRjaDogTWF0aC5taW4obWF4VGlsdCwgcGl0Y2gpIH0pO1xufTtcblxuZXhwb3J0IHsgQVBJTG9hZGluZ1N0YXR1cywgQVBJUHJvdmlkZXIsIEFQSVByb3ZpZGVyQ29udGV4dCwgQWR2YW5jZWRNYXJrZXIsIEFkdmFuY2VkTWFya2VyQW5jaG9yUG9pbnQsIEFkdmFuY2VkTWFya2VyQ29udGV4dCwgQ29sbGlzaW9uQmVoYXZpb3IsIENvbG9yU2NoZW1lLCBDb250cm9sUG9zaXRpb24sIEdvb2dsZU1hcHNDb250ZXh0LCBJbmZvV2luZG93LCBNYXAsIE1hcENvbnRyb2wsIE1hcmtlciwgUGluLCBSZW5kZXJpbmdUeXBlLCBTdGF0aWNNYXAsIFZFUlNJT04sIGNyZWF0ZVN0YXRpY01hcHNVcmwsIGlzQWR2YW5jZWRNYXJrZXIsIGlzTGF0TG5nTGl0ZXJhbCwgbGF0TG5nRXF1YWxzLCBsaW1pdFRpbHRSYW5nZSwgdG9MYXRMbmdMaXRlcmFsLCB1c2VBZHZhbmNlZE1hcmtlclJlZiwgdXNlQXBpSXNMb2FkZWQsIHVzZUFwaUxvYWRpbmdTdGF0dXMsIHVzZU1hcCwgdXNlTWFwc0xpYnJhcnksIHVzZU1hcmtlclJlZiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubW9kZXJuLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixVQUFVO0FBQy9COztBQUVBLHFCQUFxQixVQUFVO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL1BlZHJvU1NEL1Byb2pldG9zL2dlbmVyaWMtbGFuZGluZy1wYWdlL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cblxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXG4gIHJldHVybiBhIT09YSAmJiBiIT09Yjtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fast-deep-equal/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FVolumes%2FPedroSSD%2FProjetos%2Fgeneric-landing-page%2Fnode_modules%2F%40vercel%2Fanalytics%2Fdist%2Freact%2Findex.mjs%22%2C%22ids%22%3A%5B%22Analytics%22%5D%7D&modules=%7B%22request%22%3A%22%2FVolumes%2FPedroSSD%2FProjetos%2Fgeneric-landing-page%2Fnode_modules%2F%40vercel%2Fspeed-insights%2Fdist%2Freact%2Findex.mjs%22%2C%22ids%22%3A%5B%22SpeedInsights%22%5D%7D&modules=%7B%22request%22%3A%22%2FVolumes%2FPedroSSD%2FProjetos%2Fgeneric-landing-page%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FVolumes%2FPedroSSD%2FProjetos%2Fgeneric-landing-page%2Fsrc%2Fcomponents%2FProviders.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FVolumes%2FPedroSSD%2FProjetos%2Fgeneric-landing-page%2Fnode_modules%2F%40vercel%2Fanalytics%2Fdist%2Freact%2Findex.mjs%22%2C%22ids%22%3A%5B%22Analytics%22%5D%7D&modules=%7B%22request%22%3A%22%2FVolumes%2FPedroSSD%2FProjetos%2Fgeneric-landing-page%2Fnode_modules%2F%40vercel%2Fspeed-insights%2Fdist%2Freact%2Findex.mjs%22%2C%22ids%22%3A%5B%22SpeedInsights%22%5D%7D&modules=%7B%22request%22%3A%22%2FVolumes%2FPedroSSD%2FProjetos%2Fgeneric-landing-page%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FVolumes%2FPedroSSD%2FProjetos%2Fgeneric-landing-page%2Fsrc%2Fcomponents%2FProviders.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false! ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./node_modules/@vercel/analytics/dist/react/index.mjs */ \"(app-pages-browser)/./node_modules/@vercel/analytics/dist/react/index.mjs\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./node_modules/@vercel/speed-insights/dist/react/index.mjs */ \"(app-pages-browser)/./node_modules/@vercel/speed-insights/dist/react/index.mjs\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/globals.css */ \"(app-pages-browser)/./src/app/globals.css\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/Providers.tsx */ \"(app-pages-browser)/./src/components/Providers.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVm9sdW1lcyUyRlBlZHJvU1NEJTJGUHJvamV0b3MlMkZnZW5lcmljLWxhbmRpbmctcGFnZSUyRm5vZGVfbW9kdWxlcyUyRiU0MHZlcmNlbCUyRmFuYWx5dGljcyUyRmRpc3QlMkZyZWFjdCUyRmluZGV4Lm1qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiUyMkFuYWx5dGljcyUyMiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZWb2x1bWVzJTJGUGVkcm9TU0QlMkZQcm9qZXRvcyUyRmdlbmVyaWMtbGFuZGluZy1wYWdlJTJGbm9kZV9tb2R1bGVzJTJGJTQwdmVyY2VsJTJGc3BlZWQtaW5zaWdodHMlMkZkaXN0JTJGcmVhY3QlMkZpbmRleC5tanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJTcGVlZEluc2lnaHRzJTIyJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRlZvbHVtZXMlMkZQZWRyb1NTRCUyRlByb2pldG9zJTJGZ2VuZXJpYy1sYW5kaW5nLXBhZ2UlMkZzcmMlMkZhcHAlMkZnbG9iYWxzLmNzcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZWb2x1bWVzJTJGUGVkcm9TU0QlMkZQcm9qZXRvcyUyRmdlbmVyaWMtbGFuZGluZy1wYWdlJTJGc3JjJTJGY29tcG9uZW50cyUyRlByb3ZpZGVycy50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJkZWZhdWx0JTIyJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsb09BQXVLO0FBQ3ZLO0FBQ0EsOE9BQWdMO0FBQ2hMO0FBQ0Esb0tBQXdHO0FBQ3hHO0FBQ0Esc0xBQThJIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJBbmFseXRpY3NcIl0gKi8gXCIvVm9sdW1lcy9QZWRyb1NTRC9Qcm9qZXRvcy9nZW5lcmljLWxhbmRpbmctcGFnZS9ub2RlX21vZHVsZXMvQHZlcmNlbC9hbmFseXRpY3MvZGlzdC9yZWFjdC9pbmRleC5tanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiwgd2VicGFja0V4cG9ydHM6IFtcIlNwZWVkSW5zaWdodHNcIl0gKi8gXCIvVm9sdW1lcy9QZWRyb1NTRC9Qcm9qZXRvcy9nZW5lcmljLWxhbmRpbmctcGFnZS9ub2RlX21vZHVsZXMvQHZlcmNlbC9zcGVlZC1pbnNpZ2h0cy9kaXN0L3JlYWN0L2luZGV4Lm1qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1ZvbHVtZXMvUGVkcm9TU0QvUHJvamV0b3MvZ2VuZXJpYy1sYW5kaW5nLXBhZ2Uvc3JjL2FwcC9nbG9iYWxzLmNzc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiLCB3ZWJwYWNrRXhwb3J0czogW1wiZGVmYXVsdFwiXSAqLyBcIi9Wb2x1bWVzL1BlZHJvU1NEL1Byb2pldG9zL2dlbmVyaWMtbGFuZGluZy1wYWdlL3NyYy9jb21wb25lbnRzL1Byb3ZpZGVycy50c3hcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FVolumes%2FPedroSSD%2FProjetos%2Fgeneric-landing-page%2Fnode_modules%2F%40vercel%2Fanalytics%2Fdist%2Freact%2Findex.mjs%22%2C%22ids%22%3A%5B%22Analytics%22%5D%7D&modules=%7B%22request%22%3A%22%2FVolumes%2FPedroSSD%2FProjetos%2Fgeneric-landing-page%2Fnode_modules%2F%40vercel%2Fspeed-insights%2Fdist%2Freact%2Findex.mjs%22%2C%22ids%22%3A%5B%22SpeedInsights%22%5D%7D&modules=%7B%22request%22%3A%22%2FVolumes%2FPedroSSD%2FProjetos%2Fgeneric-landing-page%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FVolumes%2FPedroSSD%2FProjetos%2Fgeneric-landing-page%2Fsrc%2Fcomponents%2FProviders.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, props, owner, debugStack, debugTask) {\n      var refProp = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== refProp ? refProp : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        maybeKey,\n        getOwner(),\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (type, config, maybeKey, isStaticChildren) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsc0dBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCLElBQUksY0FBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL1BlZHJvU1NEL1Byb2pldG9zL2dlbmVyaWMtbGFuZGluZy1wYWdlL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9BQ1RJVklUWV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkFjdGl2aXR5XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVW5rbm93bk93bmVyKCkge1xuICAgICAgcmV0dXJuIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHByb3BzLCBvd25lciwgZGVidWdTdGFjaywgZGVidWdUYXNrKSB7XG4gICAgICB2YXIgcmVmUHJvcCA9IHByb3BzLnJlZjtcbiAgICAgIHR5cGUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIF9vd25lcjogb3duZXJcbiAgICAgIH07XG4gICAgICBudWxsICE9PSAodm9pZCAwICE9PSByZWZQcm9wID8gcmVmUHJvcCA6IG51bGwpXG4gICAgICAgID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgZ2V0OiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgIH0pXG4gICAgICAgIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHsgZW51bWVyYWJsZTogITEsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgdHlwZS5fc3RvcmUgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdJbmZvXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnU3RhY2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdTdGFja1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdUYXNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnVGFza1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHR5cGUucHJvcHMpLCBPYmplY3QuZnJlZXplKHR5cGUpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqc3hERVZJbXBsKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgIGlmICh2b2lkIDAgIT09IGNoaWxkcmVuKVxuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbilcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID0gMDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbisrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dKTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbik7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5XCIgIT09IGs7XG4gICAgICAgIH0pO1xuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID1cbiAgICAgICAgICAwIDwga2V5cy5sZW5ndGhcbiAgICAgICAgICAgID8gXCJ7a2V5OiBzb21lS2V5LCBcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiXG4gICAgICAgICAgICA6IFwie2tleTogc29tZUtleX1cIjtcbiAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gfHxcbiAgICAgICAgICAoKGtleXMgPVxuICAgICAgICAgICAgMCA8IGtleXMubGVuZ3RoID8gXCJ7XCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIHsuLi5wcm9wc30gLz5cXG5SZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsXG4gICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2b2lkIDAgIT09IG1heWJlS2V5ICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIG1heWJlS2V5KSk7XG4gICAgICBoYXNWYWxpZEtleShjb25maWcpICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgY29uZmlnLmtleSkpO1xuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgICBjaGlsZHJlbiAmJlxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgICBtYXliZUtleSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlXG4gICAgICAgICAgICA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICA6IHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBSZWFjdEVsZW1lbnQoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgZ2V0T3duZXIoKSxcbiAgICAgICAgZGVidWdTdGFjayxcbiAgICAgICAgZGVidWdUYXNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlKSB7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJlxuICAgICAgICBudWxsICE9PSBub2RlICYmXG4gICAgICAgIG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJlxuICAgICAgICBub2RlLl9zdG9yZSAmJlxuICAgICAgICAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgfVxuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksXG4gICAgICBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgICAgIFJFQUNUX0FDVElWSVRZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuYWN0aXZpdHlcIiksXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGNyZWF0ZVRhc2sgPSBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgPyBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9O1xuICAgIFJlYWN0ID0ge1xuICAgICAgcmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lOiBmdW5jdGlvbiAoY2FsbFN0YWNrRm9yRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxTdGFja0ZvckVycm9yKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG4gICAgdmFyIGRpZFdhcm5BYm91dEVsZW1lbnRSZWYgPSB7fTtcbiAgICB2YXIgdW5rbm93bk93bmVyRGVidWdTdGFjayA9IFJlYWN0LnJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZS5iaW5kKFxuICAgICAgUmVhY3QsXG4gICAgICBVbmtub3duT3duZXJcbiAgICApKCk7XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnVGFzayA9IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUoVW5rbm93bk93bmVyKSk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9O1xuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIGV4cG9ydHMuanN4REVWID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgIHZhciB0cmFja0FjdHVhbE93bmVyID1cbiAgICAgICAgMWU0ID4gUmVhY3RTaGFyZWRJbnRlcm5hbHMucmVjZW50bHlDcmVhdGVkT3duZXJTdGFja3MrKztcbiAgICAgIHJldHVybiBqc3hERVZJbXBsKFxuICAgICAgICB0eXBlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyXG4gICAgICAgICAgPyBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKVxuICAgICAgICAgIDogdW5rbm93bk93bmVyRGVidWdTdGFjayxcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lciA/IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUodHlwZSkpIDogdW5rbm93bk93bmVyRGVidWdUYXNrXG4gICAgICApO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL1BlZHJvU1NEL1Byb2pldG9zL2dlbmVyaWMtbGFuZGluZy1wYWdlL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"5ca8748ce06f\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyIvVm9sdW1lcy9QZWRyb1NTRC9Qcm9qZXRvcy9nZW5lcmljLWxhbmRpbmctcGFnZS9zcmMvYXBwL2dsb2JhbHMuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNWNhODc0OGNlMDZmXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Providers.tsx":
/*!**************************************!*\
  !*** ./src/components/Providers.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Providers)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _src_context_CartContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/src/context/CartContext */ \"(app-pages-browser)/./src/context/CartContext.tsx\");\n/* harmony import */ var _vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vis.gl/react-google-maps */ \"(app-pages-browser)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\nconst GOOGLE_API_KEY = \"AIzaSyDMioy9cvyMa6p-9N_kahW8BLB7UTMHmjc\" || 0;\nfunction Providers(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_vis_gl_react_google_maps__WEBPACK_IMPORTED_MODULE_2__.APIProvider, {\n        apiKey: GOOGLE_API_KEY,\n        libraries: [\n            \"places\"\n        ],\n        language: \"pt-BR\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_src_context_CartContext__WEBPACK_IMPORTED_MODULE_1__.CartProvider, {\n            children: children\n        }, void 0, false, {\n            fileName: \"/Volumes/PedroSSD/Projetos/generic-landing-page/src/components/Providers.tsx\",\n            lineNumber: 16,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Volumes/PedroSSD/Projetos/generic-landing-page/src/components/Providers.tsx\",\n        lineNumber: 11,\n        columnNumber: 5\n    }, this);\n}\n_c = Providers;\nvar _c;\n$RefreshReg$(_c, \"Providers\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1Byb3ZpZGVycy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFHeUQ7QUFDRDtBQUV4RCxNQUFNRSxpQkFBaUJDLHlDQUFzQyxJQUFJLENBQUU7QUFFcEQsU0FBU0csVUFBVSxLQUFxQztRQUFyQyxFQUFFQyxRQUFRLEVBQTJCLEdBQXJDO0lBQ2hDLHFCQUNFLDhEQUFDTixrRUFBV0E7UUFDVk8sUUFBUU47UUFDUk8sV0FBVztZQUFDO1NBQVM7UUFDckJDLFVBQVM7a0JBRVQsNEVBQUNWLGtFQUFZQTtzQkFBRU87Ozs7Ozs7Ozs7O0FBR3JCO0tBVndCRCIsInNvdXJjZXMiOlsiL1ZvbHVtZXMvUGVkcm9TU0QvUHJvamV0b3MvZ2VuZXJpYy1sYW5kaW5nLXBhZ2Uvc3JjL2NvbXBvbmVudHMvUHJvdmlkZXJzLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBDYXJ0UHJvdmlkZXIgfSBmcm9tIFwiQC9zcmMvY29udGV4dC9DYXJ0Q29udGV4dFwiO1xuaW1wb3J0IHsgQVBJUHJvdmlkZXIgfSBmcm9tIFwiQHZpcy5nbC9yZWFjdC1nb29nbGUtbWFwc1wiO1xuXG5jb25zdCBHT09HTEVfQVBJX0tFWSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0dPT0dMRV9BUElfS0VZIHx8IFwiXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFByb3ZpZGVycyh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0Tm9kZSB9KSB7XG4gIHJldHVybiAoXG4gICAgPEFQSVByb3ZpZGVyXG4gICAgICBhcGlLZXk9e0dPT0dMRV9BUElfS0VZfVxuICAgICAgbGlicmFyaWVzPXtbXCJwbGFjZXNcIl19XG4gICAgICBsYW5ndWFnZT1cInB0LUJSXCJcbiAgICA+XG4gICAgICA8Q2FydFByb3ZpZGVyPntjaGlsZHJlbn08L0NhcnRQcm92aWRlcj5cbiAgICA8L0FQSVByb3ZpZGVyPlxuICApO1xufVxuIl0sIm5hbWVzIjpbIkNhcnRQcm92aWRlciIsIkFQSVByb3ZpZGVyIiwiR09PR0xFX0FQSV9LRVkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfR09PR0xFX0FQSV9LRVkiLCJQcm92aWRlcnMiLCJjaGlsZHJlbiIsImFwaUtleSIsImxpYnJhcmllcyIsImxhbmd1YWdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Providers.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/context/CartContext.tsx":
/*!*************************************!*\
  !*** ./src/context/CartContext.tsx ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CartProvider: () => (/* binding */ CartProvider),\n/* harmony export */   useCart: () => (/* binding */ useCart)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ CartProvider,useCart auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\nconst CartContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst CartProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [items, setItems] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"CartProvider.useState\": ()=>{\n            if (false) {}\n            const saved = sessionStorage.getItem(\"cart_items\");\n            return saved ? JSON.parse(saved) : [];\n        }\n    }[\"CartProvider.useState\"]);\n    const [isOpen, setIsOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CartProvider.useEffect\": ()=>{\n            sessionStorage.setItem(\"cart_items\", JSON.stringify(items));\n        }\n    }[\"CartProvider.useEffect\"], [\n        items\n    ]);\n    const addItem = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"CartProvider.useCallback[addItem]\": (product)=>{\n            setItems({\n                \"CartProvider.useCallback[addItem]\": (prev)=>{\n                    const existing = prev.find({\n                        \"CartProvider.useCallback[addItem].existing\": (i)=>i.id === product.id\n                    }[\"CartProvider.useCallback[addItem].existing\"]);\n                    if (existing) {\n                        return prev.map({\n                            \"CartProvider.useCallback[addItem]\": (i)=>i.id === product.id ? {\n                                    ...i,\n                                    quantity: i.quantity + 1\n                                } : i\n                        }[\"CartProvider.useCallback[addItem]\"]);\n                    }\n                    return [\n                        ...prev,\n                        {\n                            ...product,\n                            quantity: 1\n                        }\n                    ];\n                }\n            }[\"CartProvider.useCallback[addItem]\"]);\n            setIsOpen(true);\n        }\n    }[\"CartProvider.useCallback[addItem]\"], []);\n    const removeItem = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"CartProvider.useCallback[removeItem]\": (id)=>{\n            setItems({\n                \"CartProvider.useCallback[removeItem]\": (prev)=>prev.filter({\n                        \"CartProvider.useCallback[removeItem]\": (i)=>i.id !== id\n                    }[\"CartProvider.useCallback[removeItem]\"])\n            }[\"CartProvider.useCallback[removeItem]\"]);\n        }\n    }[\"CartProvider.useCallback[removeItem]\"], []);\n    const updateQuantity = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"CartProvider.useCallback[updateQuantity]\": (id, qty)=>{\n            if (qty <= 0) {\n                setItems({\n                    \"CartProvider.useCallback[updateQuantity]\": (prev)=>prev.filter({\n                            \"CartProvider.useCallback[updateQuantity]\": (i)=>i.id !== id\n                        }[\"CartProvider.useCallback[updateQuantity]\"])\n                }[\"CartProvider.useCallback[updateQuantity]\"]);\n            } else {\n                setItems({\n                    \"CartProvider.useCallback[updateQuantity]\": (prev)=>prev.map({\n                            \"CartProvider.useCallback[updateQuantity]\": (i)=>i.id === id ? {\n                                    ...i,\n                                    quantity: qty\n                                } : i\n                        }[\"CartProvider.useCallback[updateQuantity]\"])\n                }[\"CartProvider.useCallback[updateQuantity]\"]);\n            }\n        }\n    }[\"CartProvider.useCallback[updateQuantity]\"], []);\n    const clearCart = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"CartProvider.useCallback[clearCart]\": ()=>{\n            setItems([]);\n            sessionStorage.removeItem(\"cart_items\");\n        }\n    }[\"CartProvider.useCallback[clearCart]\"], []);\n    const count = items.reduce((acc, i)=>acc + i.quantity, 0);\n    const total = items.reduce((acc, i)=>{\n        var _i_price;\n        return acc + ((_i_price = i.price) !== null && _i_price !== void 0 ? _i_price : 0) * i.quantity;\n    }, 0);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CartContext.Provider, {\n        value: {\n            items,\n            count,\n            total,\n            isOpen,\n            setIsOpen,\n            addItem,\n            removeItem,\n            updateQuantity,\n            clearCart\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Volumes/PedroSSD/Projetos/generic-landing-page/src/context/CartContext.tsx\",\n        lineNumber: 83,\n        columnNumber: 5\n    }, undefined);\n};\n_s(CartProvider, \"G7ptOjndj9lz4Xa/ru7k4v4o6us=\");\n_c = CartProvider;\nconst useCart = ()=>{\n    _s1();\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(CartContext);\n    if (!ctx) throw new Error(\"useCart must be used inside CartProvider\");\n    return ctx;\n};\n_s1(useCart, \"/dMy7t63NXD4eYACoT93CePwGrg=\");\nvar _c;\n$RefreshReg$(_c, \"CartProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0L0NhcnRDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBUWU7QUFtQmYsTUFBTU0sNEJBQWNMLG9EQUFhQSxDQUE4Qk07QUFFeEQsTUFBTUMsZUFBd0Q7UUFBQyxFQUNwRUMsUUFBUSxFQUNUOztJQUNDLE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHUiwrQ0FBUUE7aUNBQWE7WUFDN0MsSUFBSSxLQUE2QixFQUFFLEVBQVU7WUFDN0MsTUFBTVMsUUFBUUMsZUFBZUMsT0FBTyxDQUFDO1lBQ3JDLE9BQU9GLFFBQVFHLEtBQUtDLEtBQUssQ0FBQ0osU0FBUyxFQUFFO1FBQ3ZDOztJQUNBLE1BQU0sQ0FBQ0ssUUFBUUMsVUFBVSxHQUFHZiwrQ0FBUUEsQ0FBQztJQUVyQ0UsZ0RBQVNBO2tDQUFDO1lBQ1JRLGVBQWVNLE9BQU8sQ0FBQyxjQUFjSixLQUFLSyxTQUFTLENBQUNWO1FBQ3REO2lDQUFHO1FBQUNBO0tBQU07SUFFVixNQUFNVyxVQUFVakIsa0RBQVdBOzZDQUFDLENBQUNrQjtZQUMzQlg7cURBQVMsQ0FBQ1k7b0JBQ1IsTUFBTUMsV0FBV0QsS0FBS0UsSUFBSTtzRUFBQyxDQUFDQyxJQUFNQSxFQUFFQyxFQUFFLEtBQUtMLFFBQVFLLEVBQUU7O29CQUNyRCxJQUFJSCxVQUFVO3dCQUNaLE9BQU9ELEtBQUtLLEdBQUc7aUVBQUMsQ0FBQ0YsSUFDZkEsRUFBRUMsRUFBRSxLQUFLTCxRQUFRSyxFQUFFLEdBQUc7b0NBQUUsR0FBR0QsQ0FBQztvQ0FBRUcsVUFBVUgsRUFBRUcsUUFBUSxHQUFHO2dDQUFFLElBQUlIOztvQkFFL0Q7b0JBQ0EsT0FBTzsyQkFBSUg7d0JBQU07NEJBQUUsR0FBR0QsT0FBTzs0QkFBRU8sVUFBVTt3QkFBRTtxQkFBRTtnQkFDL0M7O1lBQ0FYLFVBQVU7UUFDWjs0Q0FBRyxFQUFFO0lBRUwsTUFBTVksYUFBYTFCLGtEQUFXQTtnREFBQyxDQUFDdUI7WUFDOUJoQjt3REFBUyxDQUFDWSxPQUFTQSxLQUFLUSxNQUFNO2dFQUFDLENBQUNMLElBQU1BLEVBQUVDLEVBQUUsS0FBS0E7OztRQUNqRDsrQ0FBRyxFQUFFO0lBRUwsTUFBTUssaUJBQWlCNUIsa0RBQVdBO29EQUFDLENBQUN1QixJQUFxQk07WUFDdkQsSUFBSUEsT0FBTyxHQUFHO2dCQUNadEI7Z0VBQVMsQ0FBQ1ksT0FBU0EsS0FBS1EsTUFBTTt3RUFBQyxDQUFDTCxJQUFNQSxFQUFFQyxFQUFFLEtBQUtBOzs7WUFDakQsT0FBTztnQkFDTGhCO2dFQUFTLENBQUNZLE9BQ1JBLEtBQUtLLEdBQUc7d0VBQUMsQ0FBQ0YsSUFBT0EsRUFBRUMsRUFBRSxLQUFLQSxLQUFLO29DQUFFLEdBQUdELENBQUM7b0NBQUVHLFVBQVVJO2dDQUFJLElBQUlQOzs7WUFFN0Q7UUFDRjttREFBRyxFQUFFO0lBRUwsTUFBTVEsWUFBWTlCLGtEQUFXQTsrQ0FBQztZQUM1Qk8sU0FBUyxFQUFFO1lBQ1hFLGVBQWVpQixVQUFVLENBQUM7UUFDNUI7OENBQUcsRUFBRTtJQUVMLE1BQU1LLFFBQVF6QixNQUFNMEIsTUFBTSxDQUFDLENBQUNDLEtBQWFYLElBQWdCVyxNQUFNWCxFQUFFRyxRQUFRLEVBQUU7SUFDM0UsTUFBTVMsUUFBUTVCLE1BQU0wQixNQUFNLENBQ3hCLENBQUNDLEtBQWFYO1lBQXVCQTtlQUFQVyxNQUFNLENBQUNYLENBQUFBLFdBQUFBLEVBQUVhLEtBQUssY0FBUGIsc0JBQUFBLFdBQVcsS0FBS0EsRUFBRUcsUUFBUTtPQUMvRDtJQUdGLHFCQUNFLDhEQUFDdkIsWUFBWWtDLFFBQVE7UUFDbkJDLE9BQU87WUFDTC9CO1lBQ0F5QjtZQUNBRztZQUNBckI7WUFDQUM7WUFDQUc7WUFDQVM7WUFDQUU7WUFDQUU7UUFDRjtrQkFFQ3pCOzs7Ozs7QUFHUCxFQUFFO0dBckVXRDtLQUFBQTtBQXVFTixNQUFNa0MsVUFBVTs7SUFDckIsTUFBTUMsTUFBTXpDLGlEQUFVQSxDQUFDSTtJQUN2QixJQUFJLENBQUNxQyxLQUFLLE1BQU0sSUFBSUMsTUFBTTtJQUMxQixPQUFPRDtBQUNULEVBQUU7SUFKV0QiLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL1BlZHJvU1NEL1Byb2pldG9zL2dlbmVyaWMtbGFuZGluZy1wYWdlL3NyYy9jb250ZXh0L0NhcnRDb250ZXh0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0LCB7XG4gIGNyZWF0ZUNvbnRleHQsXG4gIHVzZUNvbnRleHQsXG4gIHVzZVN0YXRlLFxuICB1c2VDYWxsYmFjayxcbiAgdXNlRWZmZWN0LFxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IE1lbnVJdGVtIH0gZnJvbSBcIi4uL3R5cGVzL3N0b3JlXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FydEl0ZW0gZXh0ZW5kcyBNZW51SXRlbSB7XG4gIHF1YW50aXR5OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBDYXJ0Q29udGV4dFR5cGUge1xuICBpdGVtczogQ2FydEl0ZW1bXTtcbiAgY291bnQ6IG51bWJlcjtcbiAgdG90YWw6IG51bWJlcjtcbiAgaXNPcGVuOiBib29sZWFuO1xuICBzZXRJc09wZW46IChpc09wZW46IGJvb2xlYW4pID0+IHZvaWQ7XG4gIGFkZEl0ZW06IChwcm9kdWN0OiBNZW51SXRlbSkgPT4gdm9pZDtcbiAgcmVtb3ZlSXRlbTogKGlkOiBzdHJpbmcgfCBudW1iZXIpID0+IHZvaWQ7XG4gIHVwZGF0ZVF1YW50aXR5OiAoaWQ6IHN0cmluZyB8IG51bWJlciwgcXR5OiBudW1iZXIpID0+IHZvaWQ7XG4gIGNsZWFyQ2FydDogKCkgPT4gdm9pZDtcbn1cblxuY29uc3QgQ2FydENvbnRleHQgPSBjcmVhdGVDb250ZXh0PENhcnRDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuZXhwb3J0IGNvbnN0IENhcnRQcm92aWRlcjogUmVhY3QuRkM8eyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0+ID0gKHtcbiAgY2hpbGRyZW4sXG59KSA9PiB7XG4gIGNvbnN0IFtpdGVtcywgc2V0SXRlbXNdID0gdXNlU3RhdGU8Q2FydEl0ZW1bXT4oKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gW107XG4gICAgY29uc3Qgc2F2ZWQgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFwiY2FydF9pdGVtc1wiKTtcbiAgICByZXR1cm4gc2F2ZWQgPyBKU09OLnBhcnNlKHNhdmVkKSA6IFtdO1xuICB9KTtcbiAgY29uc3QgW2lzT3Blbiwgc2V0SXNPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJjYXJ0X2l0ZW1zXCIsIEpTT04uc3RyaW5naWZ5KGl0ZW1zKSk7XG4gIH0sIFtpdGVtc10pO1xuXG4gIGNvbnN0IGFkZEl0ZW0gPSB1c2VDYWxsYmFjaygocHJvZHVjdDogTWVudUl0ZW0pID0+IHtcbiAgICBzZXRJdGVtcygocHJldikgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBwcmV2LmZpbmQoKGkpID0+IGkuaWQgPT09IHByb2R1Y3QuaWQpO1xuICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgIHJldHVybiBwcmV2Lm1hcCgoaSkgPT5cbiAgICAgICAgICBpLmlkID09PSBwcm9kdWN0LmlkID8geyAuLi5pLCBxdWFudGl0eTogaS5xdWFudGl0eSArIDEgfSA6IGksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gWy4uLnByZXYsIHsgLi4ucHJvZHVjdCwgcXVhbnRpdHk6IDEgfV07XG4gICAgfSk7XG4gICAgc2V0SXNPcGVuKHRydWUpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgcmVtb3ZlSXRlbSA9IHVzZUNhbGxiYWNrKChpZDogc3RyaW5nIHwgbnVtYmVyKSA9PiB7XG4gICAgc2V0SXRlbXMoKHByZXYpID0+IHByZXYuZmlsdGVyKChpKSA9PiBpLmlkICE9PSBpZCkpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgdXBkYXRlUXVhbnRpdHkgPSB1c2VDYWxsYmFjaygoaWQ6IHN0cmluZyB8IG51bWJlciwgcXR5OiBudW1iZXIpID0+IHtcbiAgICBpZiAocXR5IDw9IDApIHtcbiAgICAgIHNldEl0ZW1zKChwcmV2KSA9PiBwcmV2LmZpbHRlcigoaSkgPT4gaS5pZCAhPT0gaWQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SXRlbXMoKHByZXYpID0+XG4gICAgICAgIHByZXYubWFwKChpKSA9PiAoaS5pZCA9PT0gaWQgPyB7IC4uLmksIHF1YW50aXR5OiBxdHkgfSA6IGkpKSxcbiAgICAgICk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgY29uc3QgY2xlYXJDYXJ0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldEl0ZW1zKFtdKTtcbiAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFwiY2FydF9pdGVtc1wiKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGNvdW50ID0gaXRlbXMucmVkdWNlKChhY2M6IG51bWJlciwgaTogQ2FydEl0ZW0pID0+IGFjYyArIGkucXVhbnRpdHksIDApO1xuICBjb25zdCB0b3RhbCA9IGl0ZW1zLnJlZHVjZShcbiAgICAoYWNjOiBudW1iZXIsIGk6IENhcnRJdGVtKSA9PiBhY2MgKyAoaS5wcmljZSA/PyAwKSAqIGkucXVhbnRpdHksXG4gICAgMCxcbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxDYXJ0Q29udGV4dC5Qcm92aWRlclxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgaXRlbXMsXG4gICAgICAgIGNvdW50LFxuICAgICAgICB0b3RhbCxcbiAgICAgICAgaXNPcGVuLFxuICAgICAgICBzZXRJc09wZW4sXG4gICAgICAgIGFkZEl0ZW0sXG4gICAgICAgIHJlbW92ZUl0ZW0sXG4gICAgICAgIHVwZGF0ZVF1YW50aXR5LFxuICAgICAgICBjbGVhckNhcnQsXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0NhcnRDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHVzZUNhcnQgPSAoKSA9PiB7XG4gIGNvbnN0IGN0eCA9IHVzZUNvbnRleHQoQ2FydENvbnRleHQpO1xuICBpZiAoIWN0eCkgdGhyb3cgbmV3IEVycm9yKFwidXNlQ2FydCBtdXN0IGJlIHVzZWQgaW5zaWRlIENhcnRQcm92aWRlclwiKTtcbiAgcmV0dXJuIGN0eDtcbn07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJDYXJ0Q29udGV4dCIsInVuZGVmaW5lZCIsIkNhcnRQcm92aWRlciIsImNoaWxkcmVuIiwiaXRlbXMiLCJzZXRJdGVtcyIsInNhdmVkIiwic2Vzc2lvblN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwiaXNPcGVuIiwic2V0SXNPcGVuIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImFkZEl0ZW0iLCJwcm9kdWN0IiwicHJldiIsImV4aXN0aW5nIiwiZmluZCIsImkiLCJpZCIsIm1hcCIsInF1YW50aXR5IiwicmVtb3ZlSXRlbSIsImZpbHRlciIsInVwZGF0ZVF1YW50aXR5IiwicXR5IiwiY2xlYXJDYXJ0IiwiY291bnQiLCJyZWR1Y2UiLCJhY2MiLCJ0b3RhbCIsInByaWNlIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZUNhcnQiLCJjdHgiLCJFcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/context/CartContext.tsx\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FVolumes%2FPedroSSD%2FProjetos%2Fgeneric-landing-page%2Fnode_modules%2F%40vercel%2Fanalytics%2Fdist%2Freact%2Findex.mjs%22%2C%22ids%22%3A%5B%22Analytics%22%5D%7D&modules=%7B%22request%22%3A%22%2FVolumes%2FPedroSSD%2FProjetos%2Fgeneric-landing-page%2Fnode_modules%2F%40vercel%2Fspeed-insights%2Fdist%2Freact%2Findex.mjs%22%2C%22ids%22%3A%5B%22SpeedInsights%22%5D%7D&modules=%7B%22request%22%3A%22%2FVolumes%2FPedroSSD%2FProjetos%2Fgeneric-landing-page%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FVolumes%2FPedroSSD%2FProjetos%2Fgeneric-landing-page%2Fsrc%2Fcomponents%2FProviders.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);